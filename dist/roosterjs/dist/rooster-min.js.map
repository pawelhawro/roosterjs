{"version":3,"sources":["webpack://roosterjs/webpack/bootstrap","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/icons/icons.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/AbstractButton.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/contains.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTagOfNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/Position.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/execCommand.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/createRange.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafSibling.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitParentNode.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/applyInlineStyle.ts","webpack://roosterjs/./packages/roosterjs-html-sanitizer/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/wrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/collapseNodes.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyTextStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitTextNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/shouldSkipNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getComputedStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeEmpty.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/canMoveCurrentSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/cacheGetEventData.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/processList.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/fromHtml.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getFirstLastBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/ImageInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/LinkInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getFirstLastInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/Browser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/changeElementTag.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/isPositionAtBeginningOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/queryElements.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/unwrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/table/VTable.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/clearProceedingSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/ContentEditFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/collapseSelectedBlocks.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setBackgroundColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontName.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setTextColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBold.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleItalic.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleUnderline.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/CopyPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/darkMode/getColorNormalizedContent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/DOMEventPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EditPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/FirefoxTypeAfterLink.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/cacheGetContentSearcher.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/clearEventDataCache.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/MouseUpPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/TypeInContainerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/undo/Undo.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/isCharacterValue.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/isModifierKey.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/calculateDefaultFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/hasFocus.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/toggleTagCore.ts","webpack://roosterjs/./packages/roosterjs-html-sanitizer/lib/utils/getInheritableStyles.ts","webpack://roosterjs/./packages/roosterjs-html-sanitizer/lib/utils/htmlToDom.ts","webpack://roosterjs/./packages/roosterjs-html-sanitizer/lib/utils/cloneObject.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/CustomData.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/LevelLists.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/utils/DOM.ts","webpack://roosterjs/./packages/roosterjs/lib/index.ts","webpack://roosterjs/./packages/roosterjs/lib/createEditor.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/HyperLink/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/BodyScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/extractClipboardEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getPendableFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/matchLink.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/adjustNodeInsertPosition.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTextContent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getPositionRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/addSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/moveCurrentSnapsnot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/createSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/features/autoLinkFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearBlockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/createLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/getFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/Editor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/adjustBrowserBehavior.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/createEditorCore.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/undo/UndoSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/attachDomEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/editWithUndo.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/focus.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/getCustomData.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/getSelectionRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/insertNode.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/selectRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/triggerEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/mapPluginEvents.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/darkMode/convertContentToDarkMode.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/cacheGetElementAtCursor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertImage.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/insertTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/editTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/formatTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/removeLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/replaceWithNode.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setAlignment.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setDirection.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setImageAltText.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setIndentation.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBullet.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleNumbering.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBlockQuote.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleCodeBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleStrikethrough.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSubscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSuperscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleHeader.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setJustifyFull.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/features/shortcutFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/features/insertLineBeforeStructuredNodeFeature.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/features/tableFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/features/listFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit/features/quoteFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/buildClipboardData.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/fragmentHandler.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/excelConverter/convertPastedContentFromExcel.ts","webpack://roosterjs/./packages/roosterjs-html-sanitizer/lib/sanitizer/HtmlSanitizer.ts","webpack://roosterjs/./packages/roosterjs-html-sanitizer/lib/utils/getAllowedValues.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/convertPastedContentFromWord.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/wordConverter.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/WordConverterArguments.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/wordConverter/converterUtils.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste/textToHtml.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Watermark/Watermark.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/TableResize/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/CustomReplace/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs/lib/createEditorGui.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/plugins/TabPressPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/EditorWithGui.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/AlignCenterButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/AlignJustifyButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/AlignLeftButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/AlignRightButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/BoldButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/BulletListButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/ClearStyleButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/DecreaseIndentButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/EditorGuiToolbarPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/FontSizeDropdownButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/HeaderButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/IncreaseIndentButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/ItalicButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/guiplugins/MergeFieldsGuiPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/utils/createSidebar.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/NumListButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/guiplugins/PageBreakGuiPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/RedoButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/Spacer.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/SubscriptButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/SuperscriptButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/UnderlineButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/UndoButton.ts","webpack://roosterjs/./packages/roosterjs-editor-gui/lib/EditorGui/buttons/ZoomButton.ts","webpack://roosterjs/./packages/roosterjs-plugin-image-resize/lib/index.ts","webpack://roosterjs/./packages/roosterjs-plugin-image-resize/lib/ImageResize.ts","webpack://roosterjs/./packages/roosterjs-plugin-picker/lib/index.ts","webpack://roosterjs/./packages/roosterjs-plugin-picker/lib/PickerPlugin.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","default","Browser","getBrowserInfo","getComputedStyle","PendableFormatCommandMap","splitBalancedNodeRange","getNextLeafSibling","getPreviousLeafSibling","getFirstLeafNode","getLastLeafNode","getRangeFromSelectionPath","FONT_SIZES","TAGS_TO_UNWRAP","TAGS_TO_STOP_UNWRAP","ATTRIBUTES_TO_PRESERVE","getElementBasedFormatState","getStyleBasedFormatState","getPendableFormatState","bold","italic","underline","fontSize","textLeft","textCenter","textRight","textJustify","numList","bulletList","incIndent","decIndent","pageBreak","mergeField","undo","redo","clearStyle","superscript","subscript","strike","header","zoom","editor","this","span","generateElement","append","div","appendChild","document","createElement","className","innerHTML","getIcon","addEventListener","e","doAction","cacheGetContentSearcher","clearContentSearcherCache","container","contained","treatSameNodeAsContain","Node","commonAncestorContainer","nodeType","parentNode","contains","node","tagName","toUpperCase","nodeOrPosition","offsetOrPosType","offset","getIndexOfNode","isAtEnd","nextSibling","getEndOffset","endOffset","Math","max","min","element","normalize","firstChild","newOffset","lastChild","childNodes","Position","equalTo","position","isAfter","move","getStart","range","startContainer","startOffset","getEnd","endContainer","previousSibling","nodeValue","length","pendableFormatCommands","command","focus","formatter","getDocument","execCommand","getSelectionRange","collapsed","addUndoSnapshot","keys","map","indexOf","isPendableFormatCommand","triggerPluginEvent","formatState","findHeadTailLeafNode","containerBlockNode","isTail","result","sibling","rootNode","getBlockContext","headNode","tailNode","nodes","createRange","arg1","arg2","arg3","arg4","start","end","isNodePosition","Array","getPositionFromPath","ownerDocument","getFocusablePosition","setStart","setEnd","arg","path","parent","parentBlock","inlineElement","nodeChain","push","currentNode","tag","resolveInlineElement","getLeafSibling","startNode","isNext","getSibling","getChild","curNode","shouldContinue","node1","node2","compareDocumentPosition","splitParentNode","splitBefore","newParent","cloneNode","removeAttribute","insertBefore","temp","ZERO_WIDTH_SPACE","updateLiFontSize","isInnerNode","getTagOfNode","parentElement","from","children","style","callback","createTextNode","insertNode","applyTextStyle","select","firstNode","lastNode","contentTraverser","getSelectionTraverser","currentInlineElement","nextInlineElement","getNextInlineElement","applyStyle","splitWithFragment","wrapper","Element","test","root","selector","closest","matches","msMatchesSelector","containerNode","getTextContent","textContent","getContainerNode","getParentBlock","getStartPosition","getEndPosition","isTextualInlineElement","pos","styler","getDecoratedInline","toString","PartialInlineElement","thisStart","otherEnd","to","nextNode","previousNode","getDefaultContentEditFeatures","collapseToSingleElement","getStartNode","getEndNode","equals","blockElement","collapse","ref","isStart","canSplitParent","slice","startIndex","endIndex","BLOCK_ELEMENT_TAGS","split","BLOCK_DISPLAY_STYLES","display","HTML_VOID_ELEMENTS","scoper","createBodyTraverser","ContentTraverser","createSelectionTraverser","createBlockTraverser","currentBlock","getStartBlockElement","getNextBlockElement","getPreviousNextBlockElement","getPreviousBlockElement","current","currentBlockElement","leaf","newBlock","isBlockInScope","currentInline","getStartInlineElement","getPreviousNextInlineElement","getPreviousInlineElement","newInline","getInlineElementBeforeAfter","previousInlineElement","getNextPreviousInlineElement","trimInlineElement","STYLETAGS","callStylerWithInnerNode","formatNodes","formatNode","parentTag","every","shift","forEach","removeChild","textNode","returnFirstPart","firstPart","substr","secondPart","newNode","CRLF","getComputedStyles","styleNames","styles","defaultView","window","getPropertyValue","toLowerCase","px2Pt","px","round","parseFloat","styleName","isPartial","VISIBLE_ELEMENT_TAGS","VISIBLE_CHILD_ELEMENT_SELECTOR","join","trim","replace","trimContent","querySelectorAll","snapshots","step","newIndex","currentIndex","event","eventDataCache","TEMP_NODE_CLASS","TEMP_NODE_HTML","clonedNode","relativeSelectionPath","isChrome","parentLINode","getElementAtCursor","currentRange","getSelectionPath","traverser","block","tempNode","fromHtml","isVoidHtmlElement","isBlockElement","workaroundForChrome","newParentNode","existingList","queryElements","deleteNode","newList","HTMLElement","replaceChild","body","newRange","listItem","item","firstSpan","STRUCTURE_NODE_TAGS","endNode","StartEndBlockElement","blockContext","html","getFirstLastBlockElement","isFirst","getLeafNode","userAgent","appVersion","isIE11OrGreater","isIE","isFirefox","isSafari","isEdge","isWebKit","isMac","isWin","isIEOrEdge","navigator","newTag","newElement","attributes","attr","setAttribute","marginTop","marginBottom","areAllPrevousNodesEmpty","targetNode","checkPosition","targets","some","target","forEachCallback","scope","elements","filter","nodeContainedByRangeOnly","startPosition","endPosition","targetPositions","isIntersectWithNodeRange","trs","table","HTMLTableElement","td","getTableFromTd","rows","cells","row","tr","rowIndex","sourceCol","targetCol","col","colSpan","rowSpan","spanLeft","spanAbove","writeBack","moveChildren","cell","recalcSpans","applyFormat","format","borderCollapse","backgroundColor","bgColorOdd","bgColorEven","borderTop","getBorderStyle","topBorderColor","borderBottom","bottomBorderColor","borderLeft","verticalBorderColor","borderRight","edit","operation","currentRow","currentCell","splice","cloneCell","countSpanAbove","colIndex","nextCell","getCell","newCell","getTd","forEachCellOfCurrentColumn","countSpanLeft","forEachCellOfColumn","forEachCellOfCurrentRow","rowStep","aboveCell","belowCell","colStep","leftCell","rightCell","splitRow","forEachCellOfRow","getCurrentTd","HTMLTableCellElement","fromNode","toNode","removedSize","totalSize","autoLink","indentWhenTab","outdentWhenShiftTab","outdentWhenBackspaceOnEmptyFirstLine","outdentWhenEnterOnEmptyLine","mergeInNewLineWhenBackspaceOnFirstChar","unquoteWhenBackspaceOnEmptyFirstLine","unquoteWhenEnterOnEmptyLine","autoBullet","tabInTable","upDownInTable","insertLineBeforeStructuredNodeFeature","defaultShortcut","unlinkWhenBackspaceAfterLink","smartOrderedList","smartOrderedListStyles","isEmptyBlockUnderTR","blocks","color","isDarkMode","darkModeColor","lightModeColor","dataset","ogsb","fontName","fontFamily","lineHeight","ogsc","onCopy","selectionRange","clipboardEvent","copyFragment","cloneContents","normalizedContent","containerDiv","clipboardData","setData","innerText","preventDefault","getName","initialize","copyDisposer","addDomEventHandler","dispose","isDataAttributeSettable","newStyle","content","el","DocumentFragment","allChildElements","getElementsByTagName","ogac","ogab","disableRestoreSelectionOnFocus","inIme","onNativeEvent","runAsync","type","onFocus","cachedPosition","cachedFormatState","restorePendingFormatState","clear","restoreSavedRange","onBlur","saveSelectionRange","onScroll","rawEvent","scrollContainer","getScrollContainer","disposer","compositionstart","compositionend","drop","cut","removeEventListener","onPluginEvent","eventType","getCurrentPosition","isInIME","featureMap","autoCompleteSnapshot","autoCompleteChangeSource","addFeature","shouldHandleEvent","handleEvent","setContent","contentChanged","currentFeature","findFeature","source","feature","array","performAutoComplete","changeSource","snapshot","data","features","hasFunctionKey","ctrlKey","altKey","metaKey","which","allowFunctionKeys","getInlineElementBefore","LinkInlineElement","CONTENTSEARCHER_KEY","getContentSearcherOfCursor","onMouseUp","removeMouseUpEventListener","mouseUpEventListerAdded","onKeyPress","ensureTypeInElement","getBlockElementAtNode","shouldSetNodeStyles","isNodeEmpty","wasNodeJustCreatedByKeyboardEvent","updateCursor","replaceSelection","insertOnNewLine","getDefaultFormat","findClosestElementAncestor","tryNormalizeTyping","preserveSnapshots","maxBufferSize","canUndo","canRedo","onKeyDown","clearRedoForInput","isRestoring","undoSnapshots","hasNewContent","restoreSnapshot","getSnapshotsManager","canMove","getContent","addSnapshot","delta","evt","lastKeyPress","clearRedo","CTRL_CHARCODE","ALT_CHARCODE","META_CHARCODE","isCtrlKey","isAltKey","isMetaKey","DARK_MODE_DEFAULT_FORMAT","backgroundColors","textColors","baseFormat","inDarkMode","textColor","currentStyles","hasFocus","core","activeElement","contentDiv","UNWRAPPABLE_NODES","DEFAULT_STYLER","_","wrapFunction","unwrapFunction","wrap","unwrap","startBlock","endBlock","collapseNodes","INHERITABLE_PROPERTIES","win","START_FRAGMENT","END_FRAGMENT","lastIndexOf","before","after","substring","preserveFragmentOnly","fragmentHandler","doc","DOMParser","parseFromString","sourceHtml","cloneObject","assign","existingObj","NODE_ID_ATTRIBUTE_NAME","getAndSetNodeId","customData","id","getAttribute","nextNodeId","dict","listsMetadata","currentUniqueListId","text","clazz","additionalPlugins","initialContent","plugins","HyperLink","Paste","ContentEdit","concat","options","defaultFormat","Editor","getTooltipCallback","onLinkClick","href","onMouse","a","tryGetHref","setEditorDomAttribute","mouseover","mouseout","anchor","button","open","getFirstBlockElement","getFirstInlineElement","startFrom","Range","blockNode","getLastInlineElement","getFirstLastInlineElementFromBlockElement","startInline","getInlineElementAfter","inScope","selStartBlock","selEndBlock","inline","startPartial","endPartial","WHITESPACE_REGEX","inlineElements","getWordBefore","word","traverse","inlineBefore","inlineAfter","getSubStringBefore","getRangeFromText","exactMatch","textIndex","forEachTextInlineElement","textInline","nodeContent","nodeIndex","charCodeAt","getNearestNonTextInlineElement","nearestNonTextInlineElement","traversingComplete","previousInline","exec","elementStyle","fontWeight","fontStyle","textDecoration","CLIPBOARD_HTML_HEADER_REGEX","getImage","dataTransfer","fileCount","items","getAsFile","files","file","workaroundForEdge","headerValues","parseInt","types","getData","image","undefined","getAsString","isBold","isItalic","isUnderline","isStrikeThrough","isSubscript","isSuperscript","reduce","state","queryCommandState","httpExcludeRegEx","domainPortWithUrlRegEx","domainPortRegEx","linkMatchRules","http","match","RegExp","except","normalizeUrl","url","https","mailto","notes","unc","ftp","news","telnet","gopher","wais","schema","rule","scheme","originalUrl","normalizedUrl","adjustSteps","nodeToInsert","safeRemove","querySelector","normalizedPosition","splitter","rootNodeToInsert","rootNodes","hasBrNextToRoot","listNode","tdNode","trNode","newTable","currentTable","shouldInsertListAsText","handler","normalizeRect","clientRect","left","right","top","bottom","rect","getBoundingClientRect","rects","getClientRects","getPositionPath","unshift","isPreviousText","removeCount","maxSize","featureSet","getFilteredFeatures","addContentEditFeature","allFeatures","IndentWhenTab","OutdentWhenShiftTab","OutdentWhenBackOn1stEmptyLine","OutdentWhenEnterOnEmptyLine","MergeInNewLine","UnquoteWhenBackOnEmpty1stLine","UnquoteWhenEnterOnEmptyLine","TabInTable","UpDownInTable","InsertLineBeforeStructuredNodeFeature","AutoBullet","AutoLink","UnlinkWhenBackspaceAfterLink","DefaultShortcut","getSmartOrderedList","TRAILING_PUNCTUATION_REGEX","MINIMUM_LENGTH","cacheGetLinkData","cacheGetEventData","link","matchLink","searcher","trailingPunctuation","str","linkData","replaceWithNode","removeLink","MIN_FONT_SIZE","MAX_FONT_SIZE","getNewFontSize","pt","changeBase","fontSizes","floor","ceil","last","change","canCollapse","tagsToStopUnwrap","tagsToUnwrap","attributesToPreserve","groups","stopUnwrapSelector","group","first","clearNodeFormat","allChildrenAreBlock","previousValue","returnBlockElement","clearAttribute","styleArray","STYLES_TO_REMOVE","isDefaultFormatEmpty","removeProperty","URI_REGEX","MAILTO_REGEX","FTP_REGEX","TEMP_TITLE","getAnchorNodeAtCursor","updateAnchorDisplayText","displayText","altText","prefix","search","applyLinkPrefix","title","listTag","cacheGetElementAtCursor","headerTag","xel","alignStyle","textAlign","isContentDiv","isBullet","isNumbering","headerLevel","canUnlink","canAddImageAltText","isBlockQuote","alignLeft","alignCenter","alignRight","alignJustify","Error","plugin","eventDisposers","additionalEditFeatures","omitContentEditableAttributeChanges","isContentEditable","userSelect","msUserSelect","webkitUserSelect","contenteditableChanged","corePlugins","typeInContainer","isDisposed","option","darkModeOptions","getDarkModeOptions","darkModeTransform","convertContentToDarkMode","onExternalContentTransform","api","replaceNode","existingNode","getInlineElementAtNode","scopeOrCallback","Function","isEmpty","triggerExtractContentEvent","includeSelectionMarker","selectionPath","JSON","stringify","triggerContentChangedEvent","pathComment","parse","convertFunction","insertContent","allNodes","selectRange","getSelection","cachedSelectionRange","getFocusedPosition","sel","focusNode","focusOffset","getCursorRect","getPositionRect","nameOrMap","eventName","attachDomEvent","x","broadcast","triggerEvent","pluginEvent","editWithUndo","getCustomData","domEvent","getBodyTraverser","getBlockTraverser","PositionContentSearcher","requestAnimationFrame","setDarkModeState","nextDarkMode","currentContent","calculateDefaultFormat","changedToDarkMode","COMMANDS","createCoreApiMap","initValue","mouseUp","firefoxTypeAfterLink","copyPlugin","allPlugins","buildPluginList","eventHandlerPlugins","willHandleEventExclusively","currentUndoSnapshot","coreApiOverride","defaultApi","MAXSIZELIMIT","createSnapshots","canMoveCurrentSnapshot","moveCurrentSnapsnot","clearProceedingSnapshots","pluginEventType","beforeDispatch","onEvent","stopPropagation","isNested","tryGetFromCache","selection","rangeCount","getRangeAt","isBegin","insertedNode","refNode","rangeToRestore","cloneRange","deleteContents","adjustNodeInsertPosition","nodeForCursor","skipSameRange","needAddRange","removeAllRanges","addRange","handledExclusively","EVENT_MAPPING","keypress","keydown","keyup","mousedown","skipRootElement","childElements","CACHE_KEY_PREFIX","imageFile","reader","FileReader","onload","src","maxWidth","readAsDataURL","getTableCellWidth","columns","fragment","createDocumentFragment","cellSpacing","cellPadding","j","width","vtable","VTable","textOrRange","backupRange","alignment","align","direction","indentation","BLOCKQUOTE_TAG","borderColor","paddingLeft","PRE_TAG","CODE_TAG","CODE_NODE_TAG","codeBlock","level","wrapped","createCommand","winKey","macKey","action","commands","toggleBold","toggleItalic","toggleUnderline","toggleBullet","toggleNumbering","changeFontSize","cacheGetCommand","shiftKey","cmd","NEWLINE_HTML","CHILD_PARENT_TAG_MAP","TD","TH","LI","CHILD_SELECTOR","cacheGetStructuredElement","isPositionAtBeginningOf","cacheGetTableCell","firstTd","isUp","targetTd","hasShiftKey","anchorNode","anchorOffset","newContainer","newPos","setBaseAndExtent","toggleListAndPreventDefault","listInfo","cacheGetListElement","listElement","li","setIndentation","br","textBeforeCursor","rangeToDelete","tempBr","styleList","HTMLOListElement","ol","parentOl","listStyle","QUOTE_TAG","STRUCTURED_TAGS","cacheGetQuoteChild","quote","splitQuote","childOfQuote","preserved","attributeCallbacks","onPaste","pasteOriginal","snapshotBeforePaste","originalFormat","getCurrentFormat","rawHtml","sanitizeHtml","applyFormatting","sanitizer","HtmlSanitizer","pasteDisposer","paste","detectPasteOption","pasteText","pasteAndMergeFormat","pasteOption","mergeCurrentFormat","applyToElements","internalPaste","insertImage","elementTransform","parents","getFormatState","htmlToDom","convertGlobalCssToInlineCss","getInheritableStyles","sanitize","CONTAINER_HTML","extractClipboardEvent","originalSelectionRange","tempDiv","pasteDiv","getTempDivForPaste","retrieveHtmlViaTempDiv","WORD_ATTRIBUTE_NAME","WORD_ATTRIBUTE_VALUE","EXCEL_ATTRIBUTE_NAME","EXCEL_ATTRIBUTE_VALUE","LAST_TD_END_REGEX","LAST_TR_END_REGEX","LAST_TR_REGEX","LAST_TABLE_REGEX","trMatch","tableMatch","styleCallbacks","border","additionalAllowAttributes","styleNode","elementCallbacks","getStyleCallbacks","allowedTags","getAllowedTags","additionalAllowedTags","allowedAttributes","getAllowedAttributes","defaultStyleValues","getDefaultStyleValues","additionalDefaultStyleValues","additionalGlobalStyleNodes","allowPreserveWhiteSpace","convertInlineCss","additionalStyleNodes","currentElementOrStyle","convertCssOnly","processNode","styleNodes","toArray","reverse","sheet","styleSheet","styleRule","cssRules","cssText","CSSRule","STYLE_RULE","selectorText","currentStyle","context","isElement","ELEMENT_NODE","isText","TEXT_NODE","allowElement","insidePRE","thisStyle","processAttributes","processCss","child","next","getAttributeNode","pair","isInheritable","keep","attribute","list","ALLOWED_HTML_TAGS","ALLOWED_HTML_ATTRIBUTES","DEFAULT_STYLE_VALUES","overflow","padding","float","removeValue","removeWidthForLiAndDiv","unique","index","self","additionalTags","additionalAttributes","toLocaleLowerCase","additionalDefaultStyles","callbacks","wordConverter","createWordConverter","wordConverterArgs","createWordConverterArguments","processNodesDiscovery","processNodeConvert","nextUniqueId","numBulletsConverted","numNumberedConverted","createCustomData","lists","listItems","currentListIdsByLevels","createLevelLists","lastProcessedItem","LOOKUP_DEPTH","UNIQUE_LIST_ID_CUSTOM_DATA","MSO_LIST_STYLE_NAME","LINE_BREAKS","getOrCreateListForNode","metadata","listMetadata","recurringGetOrCreateListAtNode","possibleList","getRealPreviousSibling","listId","getObject","uniqueListId","setObject","convertListIfNeeded","cleanupListIgnore","levels","nodesToRemove","isEmptySpan","fixWordListComments","isIgnoreNode","getListItemMetadata","listatt","getStyleValue","listprops","wordListId","originalNode","isFakeBullet","fakeBullet","getFakeBulletText","removeComments","nextElement","endComment","getRealNextSibling","newSpan","prevSibling","isEmptyTextNode","textStyle","inStyles","nvpair","resetCurrentLists","args","ll","itemMetadata","levelInfo","ignore","numberOfItems","secondFakeBullet","firstFakeBullet","lines","line","WATERMARK_REGEX","watermark","handleWatermark","showHideWatermark","blur","hideWatermark","isWatermarkShowing","removeWartermarkFromHtml","ignoreCachedState","showWatermark","watermarkNode","pageX","onMouseOver","srcElement","calcAndShowHandle","onMouseDown","initialPageX","attachMouseEvents","getResizeHandle","borderWidth","cancelEvent","onMouseMove","adjustHandle","detachMouseEvents","isNaN","clientWidth","isRtl","setTableColumnWidth","onMouseOverDisposer","clickIntoCurrentTd","handle","offsetLeft","offsetWidth","height","offsetHeight","getPosition","offsetParent","scrollLeft","offsetTop","scrollTop","makeReplacement","sourceString","replacementHTML","matchSourceCaseSensitive","defaultReplacements","replacements","updateReplacements","newReplacements","longestReplacementLength","apply","replacement","replacementEndCharacters","endChars","Set","lastChar","add","toLocaleUpperCase","getReplacementEndCharacters","has","stringToSearch","getMatchingReplacement","matchingText","matchingRange","parsingSpan","lowerCaseStringToSearch","sourceMatch","replacementMatch","mergeFields","EditorWithGui","getEditor","isInListElement","keyCode","whiteSpace","mergefields","toolbarDiv","workspaceDiv","editorWrapperDiv","editorDiv","toolbarplugin","setEditorGui","guiplugins","g","toolbar","getButton","updateState","getContentDiv","getEditorDiv","getEditorWrapper","getWorkspace","setAlignment","classList","remove","setJustifyFull","clearFormat","isCollapsed","clearBlockFormat","gui","sizes","optionsSpans","Map","size","setFontSize","v","spanLabel","ec","optionsDiv","set","tw","empty","h1","h2","toggleHeader","fields","cssClass","MergeFieldButton","sidebar","setChecked","setUnChecked","dialog","opt","val","dialogClick","insertField","attachClickListener","HTMLDivElement","PageBreakButton","nextdiv","margin","toggleSubscript","toggleSuperscript","BEGIN_TAG","END_TAG","EXTRACT_HTML_REGEX","minWidth","minHeight","selectionBorderColor","forcePreserveRatio","resizableImageSelector","startResize","img","getSelectedImage","startPageX","startPageY","pageY","startWidth","startHeight","clientHeight","doResize","finishResize","cursor","stopEvent","widthChange","heightChange","newWidth","isWest","newHeight","isNorth","ratio","resizeDiv","removeResizeDivIfAny","previous","removeResizeDiv","hideResizeHandle","onDragStart","dragstart","contentEditable","currentImg","showResizeHandle","extractHtml","createResizeDiv","selectImageAfterUnSelect","referenceNode","createComment","pointerEvents","comment","ESC_CHARCODE","LEFT_ARROW_CHARCODE","UP_ARROW_CHARCODE","RIGHT_ARROW_CHARCODE","DOWN_ARROW_CHARCODE","DELETE_CHARCODE","dataProvider","pickerOptions","isPendingInputEventHandling","onInitalize","htmlNode","wordToReplace","getWord","lastKnownRange","setIsSuggesting","handleAutoComplete","isSuggesting","onDispose","onContentChanged","elementIdPrefix","eventHandledOnKeyDown","currentInputLength","calcInputLength","onKeyDownEvent","onAndroidInputEvent","shouldHandleKeyUpEvent","onKeyUpDomEvent","setLastKnownRange","onIsSuggestingChanged","setAriaOwns","setAriaActiveDescendant","cancelDefaultKeyDownEvent","stopImmediatePropagation","getIdValue","getNamedItem","getWordBeforeCursor","replacementNode","getRangeUntilAt","startPos","endPos","hasMatched","triggerCharacter","isCharacterValue","isModifierKey","trimmedWordBeforeCursor","wordBeforeCursorWithoutTriggerChar","wordBeforeCursor","queryStringUpdated","blockSuggestions","setCursorPoint","rangeNode","nodeBeforeCursor","setRangeStart","nodeBeforeNodeBeforeCursor","detach","targetPoint","y","bufferZone","keyboardEvent","shiftHighlight","isHorizontal","getSelectedIndex","selectOption","tryRemoveNode","nodeAfterCursor","nodeId","onRemove","newInputLength","inputType","wordBeforCursor","getInlineElementBeforeCursor","inlineElementBefore","inlineElementAfter","wordFromRange","wordFromCache","nodeOffset","suggestionsLabel","selectedIndex","suggestionLabelPrefix"],"mappings":"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","file":"rooster-min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 82);\n","export { default as NodeBlockElement } from './blockElements/NodeBlockElement';\r\nexport { default as getBlockElementAtNode } from './blockElements/getBlockElementAtNode';\r\nexport { default as getFirstLastBlockElement } from './blockElements/getFirstLastBlockElement';\r\nexport { default as StartEndBlockElement } from './blockElements/StartEndBlockElement';\r\n\r\nexport { default as ContentTraverser } from './contentTraverser/ContentTraverser';\r\nexport { default as PositionContentSearcher } from './contentTraverser/PositionContentSearcher';\r\n\r\nexport { default as getInlineElementAtNode } from './inlineElements/getInlineElementAtNode';\r\nexport { default as ImageInlineElement } from './inlineElements/ImageInlineElement';\r\nexport { default as LinkInlineElement } from './inlineElements/LinkInlineElement';\r\nexport { default as NodeInlineElement } from './inlineElements/NodeInlineElement';\r\nexport { default as PartialInlineElement } from './inlineElements/PartialInlineElement';\r\n\r\nexport { default as applyTextStyle } from './utils/applyTextStyle';\r\nexport { Browser, getBrowserInfo } from './utils/Browser';\r\nexport { default as applyFormat } from './utils/applyFormat';\r\nexport { default as changeElementTag } from './utils/changeElementTag';\r\nexport { default as collapseNodes } from './utils/collapseNodes';\r\nexport { default as contains } from './utils/contains';\r\nexport { default as extractClipboardEvent } from './utils/extractClipboardEvent';\r\nexport { default as findClosestElementAncestor } from './utils/findClosestElementAncestor';\r\nexport { default as fromHtml } from './utils/fromHtml';\r\nexport { default as getComputedStyles, getComputedStyle } from './utils/getComputedStyles';\r\nexport {\r\n    default as getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from './utils/getPendableFormatState';\r\nexport { default as getTagOfNode } from './utils/getTagOfNode';\r\nexport { default as isBlockElement } from './utils/isBlockElement';\r\nexport { default as isNodeEmpty } from './utils/isNodeEmpty';\r\nexport { default as isVoidHtmlElement } from './utils/isVoidHtmlElement';\r\nexport { default as matchLink } from './utils/matchLink';\r\nexport { default as adjustNodeInsertPosition } from './utils/adjustNodeInsertPosition';\r\nexport { default as queryElements } from './utils/queryElements';\r\nexport { default as splitParentNode, splitBalancedNodeRange } from './utils/splitParentNode';\r\nexport { default as unwrap } from './utils/unwrap';\r\nexport { default as wrap } from './utils/wrap';\r\nexport { getNextLeafSibling, getPreviousLeafSibling } from './utils/getLeafSibling';\r\nexport { getFirstLeafNode, getLastLeafNode } from './utils/getLeafNode';\r\nexport { default as getTextContent } from './utils/getTextContent';\r\nexport { default as splitTextNode } from './utils/splitTextNode';\r\n\r\nexport { default as VTable, VCell } from './table/VTable';\r\n\r\nexport { default as Position } from './selection/Position';\r\nexport { default as createRange, getRangeFromSelectionPath } from './selection/createRange';\r\nexport { default as getPositionRect } from './selection/getPositionRect';\r\nexport { default as isPositionAtBeginningOf } from './selection/isPositionAtBeginningOf';\r\nexport { default as getSelectionPath } from './selection/getSelectionPath';\r\n\r\nexport { default as addSnapshot } from './snapshots/addSnapshot';\r\nexport { default as canMoveCurrentSnapshot } from './snapshots/canMoveCurrentSnapshot';\r\nexport { default as clearProceedingSnapshots } from './snapshots/clearProceedingSnapshots';\r\nexport { default as moveCurrentSnapsnot } from './snapshots/moveCurrentSnapsnot';\r\nexport { default as createSnapshots } from './snapshots/createSnapshots';\r\n","export { default as changeFontSize, FONT_SIZES } from './format/changeFontSize';\r\nexport {\r\n    default as clearBlockFormat,\r\n    TAGS_TO_UNWRAP,\r\n    TAGS_TO_STOP_UNWRAP,\r\n    ATTRIBUTES_TO_PRESERVE,\r\n} from './format/clearBlockFormat';\r\nexport { default as clearFormat } from './format/clearFormat';\r\nexport { default as createLink } from './format/createLink';\r\nexport {\r\n    default as getFormatState,\r\n    getElementBasedFormatState,\r\n    getStyleBasedFormatState,\r\n} from './format/getFormatState';\r\nexport { default as insertImage } from './format/insertImage';\r\nexport { default as insertTable } from './table/insertTable';\r\nexport { default as editTable } from './table/editTable';\r\nexport { default as formatTable } from './table/formatTable';\r\nexport { default as removeLink } from './format/removeLink';\r\nexport { default as replaceWithNode } from './format/replaceWithNode';\r\nexport { default as setAlignment } from './format/setAlignment';\r\nexport { default as setBackgroundColor } from './format/setBackgroundColor';\r\nexport { default as setTextColor } from './format/setTextColor';\r\nexport { default as setDirection } from './format/setDirection';\r\nexport { default as setFontName } from './format/setFontName';\r\nexport { default as setFontSize } from './format/setFontSize';\r\nexport { default as setImageAltText } from './format/setImageAltText';\r\nexport { default as setIndentation } from './format/setIndentation';\r\nexport { default as toggleBold } from './format/toggleBold';\r\nexport { default as toggleBullet } from './format/toggleBullet';\r\nexport { default as toggleItalic } from './format/toggleItalic';\r\nexport { default as toggleNumbering } from './format/toggleNumbering';\r\nexport { default as toggleBlockQuote } from './format/toggleBlockQuote';\r\nexport { default as toggleCodeBlock } from './format/toggleCodeBlock';\r\nexport { default as toggleStrikethrough } from './format/toggleStrikethrough';\r\nexport { default as toggleSubscript } from './format/toggleSubscript';\r\nexport { default as toggleSuperscript } from './format/toggleSuperscript';\r\nexport { default as toggleUnderline } from './format/toggleUnderline';\r\nexport { default as toggleHeader } from './format/toggleHeader';\r\nexport { default as setJustifyFull } from './format/setJustifyFull';\r\n\r\n// @deprecated the function getPendableFormatState will still be available from\r\n// roosterjs-editor-dom package, keep export it here just for compatibility\r\nexport { getPendableFormatState } from 'roosterjs-editor-dom';\r\n","const icons = {\r\n    bold:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M3,14l0,-13l4.217,0c1.286,0 2.304,0.275 3.054,0.825c0.751,0.55 1.127,1.266 1.127,2.149c0,0.737 -0.214,1.377 -0.64,1.921c-0.426,0.544 -1.016,0.931 -1.77,1.161l0,0.036c0.914,0.103 1.645,0.434 2.192,0.993c0.547,0.559 0.82,1.286 0.82,2.18c0,1.112 -0.448,2.013 -1.344,2.702c-0.896,0.689 -2.027,1.033 -3.392,1.033l-4.264,0Zm2.197,-11.268l0,3.698l1.427,0c0.766,0 1.367,-0.177 1.803,-0.53c0.436,-0.354 0.653,-0.854 0.653,-1.5c0,-1.112 -0.76,-1.668 -2.28,-1.668l-1.603,0Zm0,5.43l0,4.116l1.881,0c0.822,0 1.457,-0.186 1.905,-0.558c0.448,-0.372 0.672,-0.884 0.672,-1.537c0,-1.347 -0.955,-2.021 -2.864,-2.021l-1.594,0Z\" style=\"fill:#666\" /></svg>',\r\n    italic:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 6,1 V 2 H 6.5 H 11.5 H 12 V 1 H 11.5 H 6.5 Z M 4,13 V 14 H 4.5 H 9.5 H 10 V 13 H 9.5 H 4.5 Z M 8.5976562,1.4179688 L 8.5078125,1.9101562 L 6.5078125,12.910156 L 6.4179688,13.402344 L 7.4023438,13.582031 L 7.4921875,13.089844 L 9.4921875,2.0898438 L 9.5820312,1.5976562 Z\" style=\"fill:#666666\" /></svg>',\r\n    underline:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 3,1 V 1.5 V 8.7714844 C 3,10.000201 3.5781679,11.15746 4.5605469,11.894531 A 0.50005,0.50005 0 0 0 4.5625,11.894531 C 4.6601893,11.967552 4.7609913,12.045118 4.8652344,12.123047 C 6.4251553,13.29186 8.5748447,13.29186 10.134766,12.123047 A 0.50005,0.50005 0 0 0 10.136719,12.121094 C 10.234295,12.047413 10.329739,11.974616 10.423828,11.904297 A 0.50005,0.50005 0 0 0 10.425781,11.904297 C 11.417529,11.161058 12,9.9927146 12,8.7539062 V 1.5 V 1 H 11 V 1.5 V 8.7539062 C 11,9.6790979 10.564471,10.548754 9.8242188,11.103516 C 9.7287034,11.174905 9.6312052,11.248264 9.5332031,11.322266 C 8.3252608,12.226279 6.672401,12.227061 5.4648438,11.322266 C 5.3630868,11.246195 5.260467,11.16873 5.1601562,11.09375 C 4.4285352,10.544821 4,9.686768 4,8.7714844 V 1.5 V 1 Z M 2,14 V 15 H 2.5 H 12.5 H 13 V 14 H 12.5 H 2.5 Z\" style=\"fill:#666666\" /></svg>',\r\n    fontSize:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 4.9785156,5 A 0.50005,0.50005 0 0 0 4.5410156,5.2988281 L 1.0410156,13.298828 L 0.84179688,13.757812 L 1.7578125,14.158203 L 1.9589844,13.701172 L 5,6.75 L 8.0410156,13.701172 L 8.2421875,14.158203 L 9.1582031,13.757812 L 8.9589844,13.298828 L 5.4589844,5.2988281 A 0.50005,0.50005 0 0 0 4.9785156,5 Z M 2.8125,10 V 11 H 7.1875 V 10 Z\" style=\"fill:#666666\" /> <path d=\"M 10.349609,5.6425781 L 9.6503906,6.3574219 L 12.576172,9.2070312 L 15.357422,6.3496094 L 14.642578,5.6503906 L 12.556641,7.7929688 Z M 12.423828,0.79296875 L 9.6425781,3.6503906 L 10.357422,4.3496094 L 12.443359,2.2070312 L 14.650391,4.3574219 L 15.349609,3.6425781 Z\" style=\"fill:#3a85f0\" /></svg>',\r\n    textLeft:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 2,1 V 2 H 2.5 H 13.5 H 14 V 1 H 13.5 H 2.5 Z M 2,4 V 5 H 2.5 H 9.5 H 10 V 4 H 9.5 H 2.5 Z M 2,7 V 8 H 2.5 H 13.5 H 14 V 7 H 13.5 H 2.5 Z M 2,10 V 11 H 2.5 H 9.5 H 10 V 10 H 9.5 H 2.5 Z M 2,13 V 14 H 2.5 H 13.5 H 14 V 13 H 13.5 H 2.5 Z\" style=\"fill:#666666\" /></svg>',\r\n    textCenter:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 2,1 V 2 H 2.5 H 13.5 H 14 V 1 H 13.5 H 2.5 Z M 4,4 V 5 H 4.5 H 11.5 H 12 V 4 H 11.5 H 4.5 Z M 2,7 V 8 H 2.5 H 13.5 H 14 V 7 H 13.5 H 2.5 Z M 4,10 V 11 H 4.5 H 11.5 H 12 V 10 H 11.5 H 4.5 Z M 2,13 V 14 H 2.5 H 13.5 H 14 V 13 H 13.5 H 2.5 Z\" style=\"fill:#666666\" /></svg>',\r\n    textRight:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 2,1 V 2 H 2.5 H 13.5 H 14 V 1 H 13.5 H 2.5 Z M 6,4 V 5 H 6.5 H 13.5 H 14 V 4 H 13.5 H 6.5 Z M 2,7 V 8 H 2.5 H 13.5 H 14 V 7 H 13.5 H 2.5 Z M 6,10 V 11 H 6.5 H 13.5 H 14 V 10 H 13.5 H 6.5 Z M 2,13 V 14 H 2.5 H 13.5 H 14 V 13 H 13.5 H 2.5 Z\" style=\"fill:#666666\" /></svg>',\r\n    textJustify:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 2,1 V 2 H 2.5 H 13.5 H 14 V 1 H 13.5 H 2.5 Z M 2,4 V 5 H 2.5 H 13.5 H 14 V 4 H 13.5 H 2.5 Z M 2,7 V 8 H 2.5 H 13.5 H 14 V 7 H 13.5 H 2.5 Z M 2,10 V 11 H 2.5 H 13.5 H 14 V 10 H 13.5 H 2.5 Z M 2,13 V 14 H 2.5 H 13.5 H 14 V 13 H 13.5 H 2.5 Z\" style=\"fill:#666666\" /></svg>',\r\n    numList:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 6,2 V 3 H 6.5 H 14.5 H 15 V 2 H 14.5 H 6.5 Z M 6,7 V 8 H 6.5 H 14.5 H 15 V 7 H 14.5 H 6.5 Z M 6,12 V 13 H 6.5 H 14.5 H 15 V 12 H 14.5 H 6.5 Z\" style=\"fill:#666666\" /> <path d=\"M1.673,3.507l0.667,0l0,-1.622l0.076,-0.291l-0.232,0.253l-0.435,0.27l-0.249,-0.346l1.089,-0.771l0.351,0l0,2.507l0.653,0l0,0.493l-1.92,0l0,-0.493Z M3.487,6.779c0,0.141 -0.03,0.283 -0.089,0.426c-0.059,0.143 -0.134,0.283 -0.225,0.419c-0.09,0.137 -0.191,0.269 -0.302,0.398c-0.111,0.13 -0.22,0.249 -0.326,0.359l-0.254,0.172l0,0.021l0.342,-0.067l0.92,0l0,0.493l-2.031,0l0,-0.295c0.077,-0.073 0.164,-0.155 0.26,-0.246c0.097,-0.092 0.194,-0.189 0.291,-0.293c0.098,-0.104 0.194,-0.212 0.287,-0.323c0.093,-0.111 0.176,-0.221 0.247,-0.33c0.071,-0.11 0.129,-0.217 0.173,-0.323c0.045,-0.105 0.067,-0.203 0.067,-0.293c0,-0.106 -0.034,-0.197 -0.102,-0.271c-0.069,-0.075 -0.186,-0.112 -0.352,-0.112c-0.103,0 -0.209,0.02 -0.315,0.061c-0.107,0.041 -0.199,0.094 -0.276,0.158l-0.258,-0.421c0.128,-0.09 0.27,-0.166 0.427,-0.228c0.157,-0.062 0.345,-0.092 0.565,-0.092c0.136,0 0.263,0.016 0.38,0.05c0.117,0.034 0.217,0.083 0.302,0.148c0.084,0.064 0.15,0.146 0.198,0.246c0.047,0.1 0.071,0.214 0.071,0.343Z M2.362,13.566c0.101,0 0.189,-0.012 0.265,-0.036c0.075,-0.024 0.138,-0.057 0.189,-0.099c0.05,-0.042 0.089,-0.09 0.115,-0.145c0.027,-0.055 0.04,-0.112 0.04,-0.171c0,-0.152 -0.054,-0.264 -0.162,-0.337c-0.108,-0.073 -0.282,-0.109 -0.522,-0.109l-0.351,0l0,-0.312l0.573,-0.666l0.28,-0.194l-0.382,0.047l-0.805,0l0,-0.493l1.849,0l0,0.316l-0.666,0.775l-0.218,0.114l0,0.021l0.204,-0.026c0.11,0.009 0.214,0.033 0.314,0.072c0.099,0.039 0.186,0.093 0.262,0.16c0.075,0.068 0.135,0.151 0.18,0.251c0.044,0.1 0.066,0.215 0.066,0.347c0,0.166 -0.031,0.31 -0.095,0.432c-0.064,0.123 -0.15,0.224 -0.26,0.306c-0.11,0.081 -0.239,0.142 -0.387,0.181c-0.148,0.039 -0.308,0.059 -0.48,0.059c-0.071,0 -0.144,-0.003 -0.218,-0.008c-0.074,-0.006 -0.146,-0.015 -0.217,-0.028c-0.072,-0.012 -0.139,-0.027 -0.203,-0.042c-0.063,-0.015 -0.119,-0.034 -0.166,-0.057l0.169,-0.489c0.083,0.037 0.176,0.068 0.28,0.093c0.103,0.025 0.219,0.038 0.346,0.038Z\" style=\"fill:#3a85f0\" /></svg>',\r\n    bulletList:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 6,2 V 3 H 6.5 H 14.5 H 15 V 2 H 14.5 H 6.5 Z M 6,7 V 8 H 6.5 H 14.5 H 15 V 7 H 14.5 H 6.5 Z M 6,12 V 13 H 6.5 H 14.5 H 15 V 12 H 14.5 H 6.5 Z\" style=\"fill:#666666\" /> <path d=\"M 1.5,1.5 H 3.5 V 3.5 H 1.5 Z M 1.5,6.5 H 3.5 V 8.5 H 1.5 Z M 1.5,11.5 H 3.5 V 13.5 H 1.5 Z\" style=\"fill:#3a85f0\" /></svg>',\r\n    incIndent:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 7,1 V 2 H 7.5 H 14.5 H 15 V 1 H 14.5 H 7.5 Z M 7,4 V 5 H 7.5 H 11.955078 H 12.455078 V 4 H 11.955078 H 7.5 Z M 7,7 V 8 H 7.5 H 14.5 H 15 V 7 H 14.5 H 7.5 Z M 7,10 V 11 H 7.5 H 11.955078 H 12.455078 V 10 H 11.955078 H 7.5 Z M 7,13 V 14 H 7.5 H 14.5 H 15 V 13 H 14.5 H 7.5 Z\" style=\"fill:#666666\" /> <path d=\"M 3.0996094,4.6425781 L 2.4003906,5.3574219 L 4.5429688,7.4433594 L 2.3925781,9.6503906 L 3.1074219,10.349609 L 5.9570312,7.4238281 Z M 1,7 V 8 H 1.5 H 4.5 H 5 V 7 H 4.5 H 1.5 Z\" style=\"fill:#3a85f0\" /></svg>',\r\n    decIndent:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 7,1 V 2 H 7.5 H 14.5 H 15 V 1 H 14.5 H 7.5 Z M 7,4 V 5 H 7.5 H 11.955078 H 12.455078 V 4 H 11.955078 H 7.5 Z M 7,7 V 8 H 7.5 H 14.5 H 15 V 7 H 14.5 H 7.5 Z M 7,10 V 11 H 7.5 H 11.955078 H 12.455078 V 10 H 11.955078 H 7.5 Z M 7,13 V 14 H 7.5 H 14.5 H 15 V 13 H 14.5 H 7.5 Z\" style=\"fill:#666666\" /> <path d=\"M 3.9003906,4.6425781 L 1.0429688,7.4238281 L 3.8925781,10.349609 L 4.6074219,9.6503906 L 2.4570312,7.4433594 L 4.5996094,5.3574219 Z M 2,7 V 8 H 2.5 H 5.5 H 6 V 7 H 5.5 H 2.5 Z\" style=\"fill:#3a85f0\" /></svg>',\r\n    pageBreak:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 1,1 V 5.5 A 0.50005,0.50005 0 0 0 1.5,6 H 13.5 A 0.50005,0.50005 0 0 0 14,5.5 V 1 H 13 V 5 H 2 V 1 Z M 1.5,9 A 0.50005,0.50005 0 0 0 1,9.5 V 15 H 2 V 10 H 13 V 15 H 14 V 9.5 A 0.50005,0.50005 0 0 0 13.5,9 Z\" style=\"fill:#666666\" /> <path d=\"M 2,7 V 8 H 2.5 H 4.5 H 5 V 7 H 4.5 H 2.5 Z M 10,7 V 8 H 10.5 H 12.5 H 13 V 7 H 12.5 H 10.5 Z M 6,7 V 8 H 6.5 H 8.5 H 9 V 7 H 8.5 H 6.5 Z\" style=\"fill:#3a85f0\" /> <path d=\"M 2,1 H 13 V 5 H 2 Z M 2,10 H 13 V 15 H 2 Z\" style=\"fill:#ffffff\" /></svg>',\r\n    mergeField:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 1,1 V 2 H 1.5 H 14.5 H 15 V 1 H 14.5 H 1.5 Z M 1,5 V 6 H 1.5 H 4.5 H 5 V 5 H 4.5 H 1.5 Z M 1,10 V 11 H 1.5 H 14.5 H 15 V 10 H 14.5 H 1.5 Z M 1,14 V 15 H 1.5 H 14.5 H 15 V 14 H 14.5 H 1.5 Z\" style=\"fill:#666666\" /> <path d=\"M 6.5,4 A 0.50005,0.50005 0 0 0 6,4.5 V 7.5 A 0.50005,0.50005 0 0 0 6.5,8 H 14.5 A 0.50005,0.50005 0 0 0 15,7.5 V 4.5 A 0.50005,0.50005 0 0 0 14.5,4 Z M 7,5 H 14 V 7 H 7 Z\" style=\"fill:#3a85f0\" /> <path d=\"M 7,5 H 14 V 7 H 7 Z\" style=\"fill:#ffffff\" /></svg>',\r\n    undo:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 3,2 V 2.5 V 7 H 7.5 H 8 V 6 H 7.5 H 4 V 2.5 V 2 Z M 8.5,3 C 6.328033,3 4.4431549,4.2642466 3.5507812,6.0996094 L 3.3320312,6.5507812 L 4.2304688,6.9863281 L 4.4492188,6.5371094 C 5.1788451,5.0364722 6.715967,4 8.5,4 C 10.989469,4 13,6.0105314 13,8.5 C 13,10.989469 10.989469,13 8.5,13 H 8 V 14 H 8.5 C 11.530531,14 14,11.530531 14,8.5 C 14,5.4694686 11.530531,3 8.5,3 Z\" style=\"fill:#666666\" /></svg>',\r\n    redo:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 13,2 V 2.5 V 6 H 9.5 H 9 V 7 H 9.5 H 14 V 2.5 V 2 Z M 8.5,3 C 5.4694686,3 3,5.4694686 3,8.5 C 3,11.530531 5.4694686,14 8.5,14 H 9 V 13 H 8.5 C 6.0105314,13 4,10.989469 4,8.5 C 4,6.0105314 6.0105314,4 8.5,4 C 10.284033,4 11.821155,5.0364722 12.550781,6.5371094 L 12.769531,6.9863281 L 13.667969,6.5507812 L 13.449219,6.0996094 C 12.556845,4.2642466 10.671967,3 8.5,3 Z\" style=\"fill:#666666\" /></svg>',\r\n    clearStyle:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 5.1464844,1 A 0.50005,0.50005 0 0 0 4.7089844,1.2988281 L 1.2089844,9.2988281 L 1.0078125,9.7578125 L 1.9238281,10.158203 L 2.125,9.7011719 L 5.1679688,2.7480469 L 7.2558594,7.5195312 L 7.4550781,7.9765625 L 8.3710938,7.5761719 L 8.171875,7.1191406 L 5.625,1.2988281 A 0.50005,0.50005 0 0 0 5.1464844,1 Z M 2.9785156,6 V 7 H 7.3535156 V 6 Z\" style=\"fill:#3a85f0\" /> <path d=\"M 10.302734,6.5 A 0.50005,0.50005 0 0 0 9.9589844,6.6542969 L 4.4277344,12.433594 A 0.50005,0.50005 0 0 0 4.4433594,13.140625 L 6.21875,14.839844 A 0.50005,0.50005 0 0 0 6.5644531,14.978516 H 7.7109375 H 8.6992188 A 0.50005,0.50005 0 0 0 9.0605469,14.824219 L 13.572266,10.111328 A 0.50005,0.50005 0 0 0 13.556641,9.4042969 L 10.666016,6.6386719 A 0.50005,0.50005 0 0 0 10.302734,6.5 Z M 10.335938,7.7070312 L 12.503906,9.78125 L 8.4863281,13.978516 H 7.7109375 H 6.765625 L 5.4960938,12.763672 Z M 7.0917969,10.384766 L 6.3886719,11.095703 C 6.4372413,11.143727 9.1484375,13.853516 9.1484375,13.853516 L 9.8554688,13.146484 C 9.8554688,13.146484 7.2212274,10.512742 7.0917969,10.384766 Z M 6.4726562,10.886719 L 5.765625,11.59375 L 8.5273438,14.353516 L 9.234375,13.646484 Z M 5.8515625,11.384766 L 5.1484375,12.095703 C 5.1956754,12.14241 7.90625,14.853516 7.90625,14.853516 L 8.6132812,14.146484 C 8.6132812,14.146484 5.9823246,11.514058 5.8515625,11.384766 Z M 5.4863281,11.779297 L 4.7539062,12.460938 C 4.8476048,12.561235 6.9746094,14.822266 6.9746094,14.822266 L 7.703125,14.136719 C 7.703125,14.136719 5.5346296,11.831 5.4863281,11.779297 Z M 10.5,13.978516 V 14.978516 H 15 V 13.978516 Z\" style=\"fill:#666666\" /></svg>',\r\n    superscript:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M11.44,6.832l2.859,0l0,1.168l-4.487,0l0,-0.481c0,-0.327 0.058,-0.621 0.174,-0.881c0.116,-0.26 0.262,-0.493 0.438,-0.7c0.175,-0.206 0.367,-0.389 0.576,-0.548c0.208,-0.159 0.407,-0.303 0.595,-0.43c0.197,-0.134 0.371,-0.262 0.519,-0.384c0.149,-0.122 0.275,-0.243 0.377,-0.363c0.102,-0.121 0.178,-0.242 0.228,-0.366c0.05,-0.123 0.075,-0.255 0.075,-0.394c0,-0.274 -0.081,-0.48 -0.245,-0.62c-0.163,-0.14 -0.412,-0.21 -0.747,-0.21c-0.58,0 -1.135,0.219 -1.665,0.656l0,-1.24c0.586,-0.359 1.248,-0.539 1.985,-0.539c0.341,0 0.648,0.042 0.919,0.127c0.271,0.085 0.501,0.206 0.689,0.363c0.188,0.158 0.331,0.349 0.43,0.573c0.099,0.225 0.148,0.475 0.148,0.751c0,0.295 -0.047,0.556 -0.143,0.785c-0.096,0.229 -0.223,0.437 -0.381,0.624c-0.158,0.187 -0.341,0.359 -0.548,0.515c-0.207,0.156 -0.422,0.307 -0.644,0.453c-0.151,0.101 -0.296,0.201 -0.435,0.301c-0.14,0.099 -0.263,0.197 -0.369,0.294c-0.107,0.096 -0.192,0.191 -0.254,0.283c-0.063,0.092 -0.094,0.18 -0.094,0.263Z\" style=\"fill:#3a85f0\" /> <path d=\"M 2.6660156,6.9589844 L 1.9589844,7.6660156 L 8.6464844,14.353516 L 9.3535156,13.646484 Z M 8.6464844,6.9589844 L 1.9589844,13.646484 L 2.6660156,14.353516 L 9.3535156,7.6660156 Z\" style=\"fill:#666666\" /></svg>',\r\n    subscript:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M11.44,12.832l2.859,0l0,1.168l-4.487,0l0,-0.481c0,-0.327 0.058,-0.621 0.174,-0.881c0.116,-0.26 0.262,-0.493 0.438,-0.7c0.175,-0.206 0.367,-0.389 0.576,-0.548c0.208,-0.159 0.407,-0.303 0.595,-0.43c0.197,-0.134 0.371,-0.262 0.519,-0.384c0.149,-0.122 0.275,-0.243 0.377,-0.363c0.102,-0.121 0.178,-0.242 0.228,-0.366c0.05,-0.123 0.075,-0.255 0.075,-0.394c0,-0.274 -0.081,-0.48 -0.245,-0.62c-0.163,-0.14 -0.412,-0.21 -0.747,-0.21c-0.58,0 -1.135,0.219 -1.665,0.656l0,-1.24c0.586,-0.359 1.248,-0.539 1.985,-0.539c0.341,0 0.648,0.042 0.919,0.127c0.271,0.085 0.501,0.206 0.689,0.363c0.188,0.158 0.331,0.349 0.43,0.573c0.099,0.225 0.148,0.475 0.148,0.751c0,0.295 -0.047,0.556 -0.143,0.785c-0.096,0.229 -0.223,0.437 -0.381,0.624c-0.158,0.187 -0.341,0.359 -0.548,0.515c-0.207,0.156 -0.422,0.307 -0.644,0.453c-0.151,0.101 -0.296,0.201 -0.435,0.301c-0.14,0.099 -0.263,0.197 -0.369,0.294c-0.107,0.096 -0.192,0.191 -0.254,0.283c-0.063,0.092 -0.094,0.18 -0.094,0.263Z\" style=\"fill:#3a85f0\" /> <path d=\"M 2.6660156,1.9589844 L 1.9589844,2.6660156 L 8.6464844,9.3535156 L 9.3535156,8.6464844 Z M 8.6464844,1.9589844 L 1.9589844,8.6464844 L 2.6660156,9.3535156 L 9.3535156,2.6660156 Z\" style=\"fill:#666666\" /></svg>',\r\n    strike:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 2,7 V 8 H 14 V 7 Z\" style=\"fill:#3a85f0\" /> <path d=\"M11.68,9c0.024,0.043 0.046,0.087 0.068,0.132c0.168,0.342 0.252,0.732 0.252,1.17c0,0.588 -0.125,1.085 -0.376,1.489c-0.25,0.405 -0.588,0.735 -1.012,0.988c-0.424,0.254 -0.913,0.438 -1.465,0.551c-0.552,0.113 -1.136,0.17 -1.751,0.17c-0.205,0 -0.457,-0.015 -0.756,-0.045c-0.299,-0.029 -0.605,-0.072 -0.918,-0.129c-0.313,-0.057 -0.609,-0.126 -0.888,-0.207c-0.279,-0.081 -0.504,-0.172 -0.675,-0.275l0,-1.984c0.188,0.162 0.411,0.308 0.67,0.438c0.259,0.129 0.534,0.238 0.825,0.328c0.29,0.089 0.58,0.157 0.871,0.206c0.29,0.049 0.558,0.073 0.803,0.073c0.854,0 1.49,-0.135 1.909,-0.405c0.418,-0.27 0.628,-0.661 0.628,-1.174c0,-0.275 -0.07,-0.514 -0.21,-0.717c-0.139,-0.202 -0.334,-0.387 -0.585,-0.554c-0.027,-0.019 -0.055,-0.037 -0.084,-0.055l2.694,0Zm-7.228,-3c-0.027,-0.05 -0.052,-0.1 -0.075,-0.152c-0.151,-0.329 -0.227,-0.715 -0.227,-1.158c0,-0.545 0.13,-1.019 0.389,-1.421c0.259,-0.402 0.601,-0.734 1.025,-0.996c0.424,-0.262 0.907,-0.456 1.448,-0.583c0.541,-0.127 1.093,-0.19 1.657,-0.19c1.281,0 2.215,0.138 2.801,0.413l0,1.903c-0.694,-0.475 -1.588,-0.713 -2.682,-0.713c-0.301,0 -0.602,0.027 -0.901,0.081c-0.299,0.054 -0.566,0.143 -0.803,0.267c-0.236,0.125 -0.428,0.284 -0.576,0.478c-0.148,0.194 -0.222,0.429 -0.222,0.705c0,0.259 0.057,0.483 0.171,0.672c0.113,0.189 0.28,0.361 0.499,0.518c0.083,0.059 0.173,0.118 0.27,0.176l-2.774,0Z\" style=\"fill:#666\" /></svg>',\r\n    header:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M15,9l0,1.375l-1,0l0,-0.375l-1,0l0,4l0.5,0.5l0,0.5l-2,0l0,-0.5l0.5,-0.5l0,-4l-1,0l0,0.375l-1,0l0,-1.375l5,0Z M3,10l-2,0l0,-9l2,0l0,3l3,0l0,-3l2,0l0,9l-2,0l0,-4l-3,0l0,4Z\" style=\"fill:#666\" /></svg>',\r\n    zoom:\r\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path d=\"M 5.5,2 C 3.0206409,2 1,4.0206409 1,6.5 C 1,8.9793591 3.0206409,11 5.5,11 C 7.9793591,11 10,8.9793591 10,6.5 C 10,4.0206409 7.9793591,2 5.5,2 Z M 5.5,3 C 7.4389189,3 9,4.5610811 9,6.5 C 9,8.4389189 7.4389189,10 5.5,10 C 3.5610811,10 2,8.4389189 2,6.5 C 2,4.5610811 3.5610811,3 5.5,3 Z M 8.6035156,9.3964844 L 7.8964844,10.103516 L 12.396484,14.603516 L 13.103516,13.896484 Z\" style=\"fill:#666666\" /> <path d=\"M 3,6 V 7 H 8 V 6 Z M 5,4 V 9 H 6 V 4 Z\" style=\"fill:#3a85f0\" /></svg>',\r\n};\r\n\r\nexport default icons;\r\n","import EditorToolbarButton from '../interfaces/EditorToolbarButton';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Interface of an editor plugin\r\n */\r\nexport default abstract class AbstractButton implements EditorToolbarButton {\r\n    protected editor: Editor;\r\n    protected span: HTMLElement;\r\n\r\n    constructor(editor: Editor) {\r\n        this.editor = editor;\r\n        this.span = this.generateElement();\r\n    }\r\n\r\n    abstract getName(): string;\r\n\r\n    abstract getIcon(): string;\r\n\r\n    abstract doAction(): void;\r\n\r\n    abstract updateState(state: FormatState): void;\r\n\r\n    public append(div: HTMLDivElement) {\r\n        div.appendChild(this.span);\r\n    }\r\n\r\n    public generateElement(): HTMLSpanElement {\r\n        let span = <HTMLSpanElement>document.createElement('span');\r\n        span.className = 'btn';\r\n        span.innerHTML = this.getIcon();\r\n        span.addEventListener('click', (e: MouseEvent) => {\r\n            this.doAction();\r\n        });\r\n        return span;\r\n    }\r\n}\r\n","// Interfaces\r\nexport {\r\n    ContentEditFeature,\r\n    GenericContentEditFeature,\r\n    Keys,\r\n} from './interfaces/ContentEditFeature';\r\nexport { default as CustomData, CustomDataMap } from './interfaces/CustomData';\r\nexport {\r\n    default as EditorCore,\r\n    CorePlugins,\r\n    CoreApiMap,\r\n    AttachDomEvent,\r\n    EditWithUndo,\r\n    Focus,\r\n    GetCustomData,\r\n    GetSelectionRange,\r\n    HasFocus,\r\n    InsertNode,\r\n    Select,\r\n    SelectRange,\r\n    TriggerEvent,\r\n} from './interfaces/EditorCore';\r\nexport { default as EditorOptions } from './interfaces/EditorOptions';\r\nexport { default as EditorPlugin } from './interfaces/EditorPlugin';\r\nexport { default as UndoService } from './interfaces/UndoService';\r\nexport { default as UndoSnapshotsService } from './interfaces/UndoSnapshotsService';\r\n\r\n// Classes\r\nexport { default as Editor } from './editor/Editor';\r\nexport { default as Undo } from './undo/Undo';\r\n\r\n// Core Plugins\r\nexport { default as EditPlugin } from './corePlugins/EditPlugin';\r\nexport { default as MouseUpPlugin } from './corePlugins/MouseUpPlugin';\r\nexport { default as DOMEventPlugin } from './corePlugins/DOMEventPlugin';\r\nexport { default as TypeInContainerPlugin } from './corePlugins/TypeInContainerPlugin';\r\nexport { default as FirefoxTypeAfterLink } from './corePlugins/FirefoxTypeAfterLink';\r\nexport { default as CopyPlugin } from './corePlugins/CopyPlugin';\r\n\r\n// Event APIs\r\nexport { default as cacheGetEventData } from './eventApi/cacheGetEventData';\r\nexport { default as clearEventDataCache } from './eventApi/clearEventDataCache';\r\nexport {\r\n    cacheGetContentSearcher,\r\n    clearContentSearcherCache,\r\n} from './eventApi/cacheGetContentSearcher';\r\nexport { default as cacheGetElementAtCursor } from './eventApi/cacheGetElementAtCursor';\r\nexport { default as isModifierKey } from './eventApi/isModifierKey';\r\nexport { default as isCharacterValue } from './eventApi/isCharacterValue';\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Test if a node contains another node\r\n * @param container The container node\r\n * @param contained The node to check if it is inside container\r\n * @param treatSameNodeAsContain When container and contained are the same node,\r\n * return true if this param is set to true, otherwise return false. Default value is false\r\n * @returns True if contained is insied container, or they are the same node when treatSameNodeAsContain is true.\r\n * Otherwise false.\r\n */\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean;\r\n\r\n/**\r\n * Test if a node contains a given range\r\n * @param container The container node\r\n * @param contained The range to check if it is inside container\r\n * @returns True if contained is insied container, otherwise false\r\n */\r\nexport default function contains(container: Node, contained: Range): boolean;\r\n\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node | Range,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean {\r\n    if (!container || !contained) {\r\n        return false;\r\n    }\r\n\r\n    if (treatSameNodeAsContain && container == contained) {\r\n        return true;\r\n    }\r\n\r\n    if (!(contained instanceof Node)) {\r\n        contained = contained && contained.commonAncestorContainer;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (contained && contained.nodeType == NodeType.Text) {\r\n        contained = contained.parentNode;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (container.nodeType != NodeType.Element) {\r\n        return !!treatSameNodeAsContain && container == contained;\r\n    }\r\n\r\n    return !!(treatSameNodeAsContain || container != contained) && container.contains(contained);\r\n}\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the html tag of a node, or empty if it is not an element\r\n * @param node The node to get tag of\r\n * @returns Tag name in upper case if the given node is an Element, or empty string otherwise\r\n */\r\nexport default function getTagOfNode(node: Node): string {\r\n    return node && node.nodeType == NodeType.Element ? (<Element>node).tagName.toUpperCase() : '';\r\n}\r\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represent a position in DOM tree by the node and its offset index\r\n */\r\nexport default class Position implements NodePosition {\r\n    readonly node: Node;\r\n    readonly element: HTMLElement;\r\n    readonly offset: number;\r\n    readonly isAtEnd: boolean;\r\n\r\n    /**\r\n     * Clone and validate a position from existing position.\r\n     * If the given position has invalid offset, this function will return a corrected value.\r\n     * @param position The original position to clone from\r\n     */\r\n    constructor(position: NodePosition);\r\n\r\n    /**\r\n     * Create a Position from node and an offset number\r\n     * @param node The node of this position\r\n     * @param offset Offset of this position\r\n     */\r\n    constructor(node: Node, offset: number);\r\n\r\n    /**\r\n     * Create a Position from node and a type of position\r\n     * @param node The node of this position\r\n     * @param positionType Type of the postion, can be Begin, End, Before, After\r\n     */\r\n    constructor(node: Node, positionType: PositionType);\r\n\r\n    constructor(nodeOrPosition: Node | NodePosition, offsetOrPosType?: number) {\r\n        if ((<NodePosition>nodeOrPosition).node) {\r\n            this.node = (<NodePosition>nodeOrPosition).node;\r\n            offsetOrPosType = (<NodePosition>nodeOrPosition).offset;\r\n        } else {\r\n            this.node = <Node>nodeOrPosition;\r\n        }\r\n\r\n        switch (offsetOrPosType) {\r\n            case PositionType.Before:\r\n                this.offset = getIndexOfNode(this.node);\r\n                this.node = this.node.parentNode;\r\n                this.isAtEnd = false;\r\n                break;\r\n\r\n            case PositionType.After:\r\n                this.offset = getIndexOfNode(this.node) + 1;\r\n                this.isAtEnd = !this.node.nextSibling;\r\n                this.node = this.node.parentNode;\r\n                break;\r\n\r\n            case PositionType.End:\r\n                this.offset = getEndOffset(this.node);\r\n                this.isAtEnd = true;\r\n                break;\r\n\r\n            default:\r\n                let endOffset = getEndOffset(this.node);\r\n                this.offset = Math.max(0, Math.min(<number>offsetOrPosType, endOffset));\r\n                this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;\r\n                break;\r\n        }\r\n\r\n        this.element = findClosestElementAncestor(this.node);\r\n    }\r\n\r\n    /**\r\n     * Normalize this position to the leaf node, return the normalize result.\r\n     * If current position is already using leaf node, return this position object itself\r\n     */\r\n    normalize(): NodePosition {\r\n        if (this.node.nodeType == NodeType.Text || !this.node.firstChild) {\r\n            return this;\r\n        }\r\n\r\n        let node = this.node;\r\n        let newOffset: number | PositionType.Begin | PositionType.End = this.isAtEnd\r\n            ? PositionType.End\r\n            : this.offset;\r\n        while (node.nodeType == NodeType.Element && node.firstChild) {\r\n            node =\r\n                newOffset == PositionType.Begin\r\n                    ? node.firstChild\r\n                    : newOffset == PositionType.End\r\n                    ? node.lastChild\r\n                    : node.childNodes[<number>newOffset];\r\n            newOffset = this.isAtEnd ? PositionType.End : PositionType.Begin;\r\n        }\r\n        return new Position(node, newOffset);\r\n    }\r\n\r\n    /**\r\n     * Check if this position is equal to the given position\r\n     * @param position The position to check\r\n     */\r\n    equalTo(position: NodePosition): boolean {\r\n        return (\r\n            position &&\r\n            (this == position ||\r\n                (this.node == position.node &&\r\n                    this.offset == position.offset &&\r\n                    this.isAtEnd == position.isAtEnd))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if this position is after the given position\r\n     */\r\n    isAfter(position: NodePosition): boolean {\r\n        return this.node == position.node\r\n            ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset\r\n            : isNodeAfter(this.node, position.node);\r\n    }\r\n\r\n    /**\r\n     * Move this position with offset, returns a new position with a valid offset in the same node\r\n     * @param offset Offset to move with\r\n     */\r\n    move(offset: number) {\r\n        return new Position(this.node, Math.max(this.offset + offset, 0));\r\n    }\r\n\r\n    /**\r\n     * Get start position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getStart(range: Range) {\r\n        return new Position(range.startContainer, range.startOffset);\r\n    }\r\n\r\n    /**\r\n     * Get end position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getEnd(range: Range) {\r\n        return new Position(range.endContainer, range.endOffset);\r\n    }\r\n}\r\n\r\nfunction getIndexOfNode(node: Node): number {\r\n    let i = 0;\r\n    while ((node = node.previousSibling)) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\n\r\nfunction getEndOffset(node: Node): number {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return node.nodeValue.length;\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        return node.childNodes.length;\r\n    } else {\r\n        return 1;\r\n    }\r\n}\r\n","import { ChangeSource, DocumentCommand, PluginEventType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from 'roosterjs-editor-dom';\r\n\r\nlet pendableFormatCommands: string[] = null;\r\n\r\n/**\r\n * Execute a document command\r\n * @param editor The editor instance\r\n * @param command The command to execute\r\n * @param addUndoSnapshotWhenCollapsed Optional, set to true to always add undo snapshot even current selection is collapsed.\r\n * Default value is false.\r\n * @param doWorkaroundForList Optional, set to true to do workaround for list in order to keep current format.\r\n * Default value is false.\r\n */\r\nexport default function execCommand(editor: Editor, command: DocumentCommand) {\r\n    editor.focus();\r\n    let formatter = () => editor.getDocument().execCommand(command, false, null);\r\n\r\n    let range = editor.getSelectionRange();\r\n    if (range && range.collapsed) {\r\n        editor.addUndoSnapshot();\r\n        formatter();\r\n\r\n        if (isPendableFormatCommand(command)) {\r\n            // Trigger PendingFormatStateChanged event since we changed pending format state\r\n            editor.triggerPluginEvent(PluginEventType.PendingFormatStateChanged, {\r\n                formatState: getPendableFormatState(editor.getDocument()),\r\n            });\r\n        }\r\n    } else {\r\n        editor.addUndoSnapshot(formatter, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction isPendableFormatCommand(command: DocumentCommand): boolean {\r\n    if (!pendableFormatCommands) {\r\n        pendableFormatCommands = Object.keys(PendableFormatCommandMap).map(\r\n            key => PendableFormatCommandMap[key as PendableFormatNames]\r\n        );\r\n    }\r\n    return pendableFormatCommands.indexOf(command) >= 0;\r\n}\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport NodeBlockElement from './NodeBlockElement';\r\nimport StartEndBlockElement from './StartEndBlockElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This produces a block element from a a node\r\n * It needs to account for various HTML structure. Examples:\r\n * 1) &lt;root&gt;&lt;div&gt;abc&lt;/div&gt;&lt;/root&gt;\r\n *   This is most common the case, user passes in a node pointing to abc, and get back a block representing &lt;div&gt;abc&lt;/div&gt;\r\n * 2) &lt;root&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/root&gt;\r\n *   Common content for empty block, user passes node pointing to &lt;br&gt;, and get back a block representing &lt;p&gt;&lt;br&gt;&lt;/p&gt;\r\n * 3) &lt;root&gt;abc&lt;/root&gt;\r\n *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc\r\n *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node\r\n * 4) &lt;root&gt;&lt;div&gt;abc&lt;br&gt;123&lt;/div&gt;&lt;/root&gt;\r\n *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a &lt;BR&gt; to create a link break. There're two blocks:\r\n *   block1: 1) abc&lt;br&gt; block2: 123\r\n * 5) &lt;root&gt;&lt;div&gt;abc&lt;div&gt;123&lt;/div&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) &lt;div&gt;123&lt;/div&gt;\r\n * 6) &lt;root&gt;&lt;div&gt;abc&lt;span&gt;123&lt;br&gt;456&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   This is really tricky. Essentially there is a &lt;BR&gt; in middle of a span breaking the span into two blocks;\r\n *   block1: abc&lt;span&gt;123&lt;br&gt; block2: 456\r\n * In summary, given any arbitary node (leaf), to identify the head and tail of the block, following rules need to be followed:\r\n * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered\r\n * 2) same for identifying tail\r\n * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node\r\n * @param rootNode Root node of the scope, the block element will be inside of this node\r\n * @param node The node to get BlockElement start from\r\n */\r\nexport default function getBlockElementAtNode(rootNode: Node, node: Node): BlockElement {\r\n    if (!contains(rootNode, node)) {\r\n        return null;\r\n    }\r\n\r\n    // Identify the containing block. This serves as ceiling for traversing down below\r\n    // NOTE: this container block could be just the rootNode,\r\n    // which cannot be used to create block element. We will special case handle it later on\r\n    let containerBlockNode = StartEndBlockElement.getBlockContext(node);\r\n    if (containerBlockNode == node) {\r\n        return new NodeBlockElement(containerBlockNode);\r\n    }\r\n\r\n    // Find the head and leaf node in the block\r\n    let headNode = findHeadTailLeafNode(node, containerBlockNode, false /*isTail*/);\r\n    let tailNode = findHeadTailLeafNode(node, containerBlockNode, true /*isTail*/);\r\n\r\n    // At this point, we have the head and tail of a block, here are some examples and where head and tail point to\r\n    // 1) &lt;root&gt;&lt;div&gt;hello&lt;br&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: &lt;br&gt;\r\n    // 2) &lt;root&gt;&lt;div&gt;hello&lt;span style=\"font-family: Arial\"&gt;world&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: world\r\n    // Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block\r\n    // So we shall try to collapse as much as we can to the nearest common ancester\r\n    let nodes = collapseNodes(rootNode, headNode, tailNode, false /*canSplitParent*/);\r\n    headNode = nodes[0];\r\n    tailNode = nodes[nodes.length - 1];\r\n\r\n    if (headNode.parentNode != tailNode.parentNode) {\r\n        // Un-Balanced start and end, create a start-end block\r\n        return new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    } else {\r\n        // Balanced start and end (point to same parent), need to see if further collapsing can be done\r\n        while (!headNode.previousSibling && !tailNode.nextSibling) {\r\n            let parentNode = headNode.parentNode;\r\n            if (parentNode == containerBlockNode) {\r\n                // Has reached the container block\r\n                if (containerBlockNode != rootNode) {\r\n                    // If the container block is not the root, use the container block\r\n                    headNode = tailNode = parentNode;\r\n                }\r\n                break;\r\n            } else {\r\n                // Continue collapsing to parent\r\n                headNode = tailNode = parentNode;\r\n            }\r\n        }\r\n\r\n        // If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block\r\n        return headNode == tailNode && isBlockElement(headNode)\r\n            ? new NodeBlockElement(headNode as HTMLElement)\r\n            : new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    }\r\n}\r\n\r\n/**\r\n * Given a node and container block, identify the first/last leaf node\r\n * A leaf node is defined as deepest first/last node in a block\r\n * i.e. &lt;div&gt;&lt;span style=\"font-family: Arial\"&gt;abc&lt;/span&gt;&lt;/div&gt;, abc is the head leaf of the block\r\n * Often &lt;br&gt; or a child &lt;div&gt; is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf\r\n * i.e. &lt;div&gt;123&lt;br&gt;abc&lt;/div&gt;, abc is the head of a block because of a previous sibling &lt;br&gt;\r\n * i.e. &lt;div&gt;&lt;div&gt;123&lt;/div&gt;abc&lt;/div&gt;, abc is also the head of a block because of a previous sibling &lt;div&gt;\r\n */\r\nfunction findHeadTailLeafNode(node: Node, containerBlockNode: Node, isTail: boolean): Node {\r\n    let result = node;\r\n\r\n    if (getTagOfNode(result) == 'BR' && isTail) {\r\n        return result;\r\n    }\r\n\r\n    while (result) {\r\n        let sibling = node;\r\n        while (!(sibling = isTail ? node.nextSibling : node.previousSibling)) {\r\n            node = node.parentNode;\r\n            if (node == containerBlockNode) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        while (sibling) {\r\n            if (isBlockElement(sibling)) {\r\n                return result;\r\n            } else if (getTagOfNode(sibling) == 'BR') {\r\n                return isTail ? sibling : result;\r\n            }\r\n\r\n            node = sibling;\r\n            sibling = isTail ? node.firstChild : node.lastChild;\r\n        }\r\n\r\n        result = node;\r\n    }\r\n    return result;\r\n}\r\n","import isVoidHtmlElement from '../utils/isVoidHtmlElement';\r\nimport Position from './Position';\r\nimport { NodePosition, NodeType, PositionType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create a range around the given node(s)\r\n * @param startNode The start node to create range from\r\n * @param endNode The end node to create range from. If specified, the range will start before startNode and\r\n * end after endNode, otherwise, the range will start before and end after the start node\r\n * @returns A range start before the given node and end after the given node\r\n */\r\nexport default function createRange(startNode: Node, endNode?: Node): Range;\r\n\r\n/**\r\n * Create a collapsed range at the given node and offset\r\n * @param node The container node of the range\r\n * @param offset The offset of the range, can be a number or value of PositionType\r\n * @returns A range at the given node and offset\r\n */\r\nexport default function createRange(node: Node, offset: number | PositionType): Range;\r\n\r\n/**\r\n * Create a range with the given start/end container node and offset\r\n * @param startNode The start container node of the range\r\n * @param startOffset The start offset of the range\r\n * @param endNode The end container node of the range\r\n * @param endOffset The end offset of the range\r\n * @returns A range at the given start/end container node and offset\r\n */\r\nexport default function createRange(\r\n    startNode: Node,\r\n    startOffset: number | PositionType,\r\n    endNode: Node,\r\n    endOffset: number | PositionType\r\n): Range;\r\n\r\n/**\r\n * Create a range under the given rootNode with start and end selection paths\r\n * @param rootNode The root node that the selection paths start from\r\n * @param startPath The selection path of the start position of the range\r\n * @param endPath The selection path of the end position of the range\r\n * @returns A range with the given start and end selection paths\r\n */\r\nexport default function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n\r\n/**\r\n * Create a range with the start and end position\r\n * @param startPosition The start position of the range\r\n * @param endPosition The end position of the range, if not specified, the range will be collapsed at start position\r\n * @returns A range start at startPosition, end at endPosition, or startPosition when endPosition is not specified\r\n */\r\nexport default function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n\r\nexport default function createRange(\r\n    arg1: Node | NodePosition,\r\n    arg2?: number | number[] | Node | NodePosition,\r\n    arg3?: Node | number[],\r\n    arg4?: number\r\n): Range {\r\n    let start: NodePosition;\r\n    let end: NodePosition;\r\n\r\n    if (isNodePosition(arg1)) {\r\n        // function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n        start = arg1;\r\n        end = isNodePosition(arg2) ? arg2 : null;\r\n    } else if (arg1 instanceof Node) {\r\n        if (arg2 instanceof Array) {\r\n            // function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n            start = getPositionFromPath(arg1, arg2);\r\n            end = arg3 instanceof Array ? getPositionFromPath(arg1, arg3) : null;\r\n        } else if (typeof arg2 == 'number') {\r\n            // function createRange(node: Node, offset: number | PositionType): Range;\r\n            // function createRange(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): Range;\r\n            start = new Position(arg1, arg2);\r\n            end = arg3 instanceof Node ? new Position(arg3, arg4) : null;\r\n        } else if (arg2 instanceof Node || !arg2) {\r\n            // function createRange(startNode: Node, endNode?: Node): Range;\r\n            start = new Position(arg1, PositionType.Before);\r\n            end = new Position(<Node>arg2 || arg1, PositionType.After);\r\n        }\r\n    }\r\n\r\n    if (start && start.node) {\r\n        let range = start.node.ownerDocument.createRange();\r\n        start = getFocusablePosition(start);\r\n        end = getFocusablePosition(end || start);\r\n        range.setStart(start.node, start.offset);\r\n        range.setEnd(end.node, end.offset);\r\n\r\n        return range;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Convert to focusable position\r\n * If current node is a void element, we need to move up one level to put cursor outside void element\r\n */\r\nfunction getFocusablePosition(position: NodePosition) {\r\n    return position.node.nodeType == NodeType.Element && isVoidHtmlElement(position.node)\r\n        ? new Position(position.node, position.isAtEnd ? PositionType.After : PositionType.Before)\r\n        : position;\r\n}\r\n\r\nfunction isNodePosition(arg: any): arg is NodePosition {\r\n    return arg && arg.node;\r\n}\r\n\r\nfunction getPositionFromPath(node: Node, path: number[]): NodePosition {\r\n    if (!node || !path) {\r\n        return null;\r\n    }\r\n\r\n    // Iterate with a for loop to avoid mutating the passed in element path stack\r\n    // or needing to copy it.\r\n    let offset: number;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        offset = path[i];\r\n        if (\r\n            i < path.length - 1 &&\r\n            node &&\r\n            node.nodeType == NodeType.Element &&\r\n            node.childNodes.length > offset\r\n        ) {\r\n            node = node.childNodes[offset];\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return new Position(node, offset);\r\n}\r\n\r\n/**\r\n * @deprecated Use createRange instead\r\n * Get range from the given selection path\r\n * @param rootNode Root node of the selection path\r\n * @param path The selection path which contains start and end position path\r\n */\r\nexport function getRangeFromSelectionPath(rootNode: HTMLElement, path: SelectionPath) {\r\n    return createRange(rootNode, path.start, path.end);\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport ImageInlineElement from './ImageInlineElement';\r\nimport LinkInlineElement from './LinkInlineElement';\r\nimport NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param rootNode The root node of current scope\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(rootNode: Node, node: Node): InlineElement;\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param parentBlock Parent BlockElement of this node\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(\r\n    parentBlock: BlockElement,\r\n    node: Node\r\n): InlineElement;\r\n\r\nexport default function getInlineElementAtNode(\r\n    parent: Node | BlockElement,\r\n    node: Node\r\n): InlineElement {\r\n    // An inline element has to be in a block element, get the block first and then resolve through the factory\r\n    let parentBlock = parent instanceof Node ? getBlockElementAtNode(parent, node) : parent;\r\n    return node && parentBlock && resolveInlineElement(node, parentBlock);\r\n}\r\n\r\n/**\r\n * Resolve an inline element by a leaf node\r\n * @param node The node to resolve from\r\n * @param parentBlock The parent block element\r\n */\r\nfunction resolveInlineElement(node: Node, parentBlock: BlockElement): InlineElement {\r\n    let nodeChain = [node];\r\n    for (\r\n        let parent = node.parentNode;\r\n        parent && parentBlock.contains(parent);\r\n        parent = parent.parentNode\r\n    ) {\r\n        nodeChain.push(parent);\r\n    }\r\n\r\n    let inlineElement: InlineElement;\r\n\r\n    for (let i = nodeChain.length - 1; i >= 0 && !inlineElement; i--) {\r\n        let currentNode = nodeChain[i];\r\n        let tag = getTagOfNode(currentNode);\r\n        if (tag == 'A') {\r\n            inlineElement = new LinkInlineElement(currentNode, parentBlock);\r\n        } else if (tag == 'IMG') {\r\n            inlineElement = new ImageInlineElement(currentNode, parentBlock);\r\n        }\r\n    }\r\n\r\n    return inlineElement || new NodeInlineElement(node, parentBlock);\r\n}\r\n","import contains from './contains';\r\nimport shouldSkipNode from './shouldSkipNode';\r\n\r\n/**\r\n * This walks forwards/backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node\r\n */\r\nexport function getLeafSibling(rootNode: Node, startNode: Node, isNext: boolean): Node {\r\n    let result = null;\r\n    let getSibling = isNext\r\n        ? (node: Node) => node.nextSibling\r\n        : (node: Node) => node.previousSibling;\r\n    let getChild = isNext ? (node: Node) => node.firstChild : (node: Node) => node.lastChild;\r\n    if (contains(rootNode, startNode)) {\r\n        let curNode = startNode;\r\n        let shouldContinue = true;\r\n\r\n        while (shouldContinue) {\r\n            // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent\r\n            // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)\r\n            let parentNode = curNode.parentNode;\r\n            curNode = getSibling(curNode);\r\n            while (!curNode && parentNode != rootNode) {\r\n                curNode = getSibling(parentNode);\r\n                parentNode = parentNode.parentNode;\r\n            }\r\n\r\n            // Now traverse down to get first/last child\r\n            while (curNode && getChild(curNode)) {\r\n                curNode = getChild(curNode);\r\n            }\r\n\r\n            // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so\r\n            shouldContinue = curNode && shouldSkipNode(curNode);\r\n            if (!shouldContinue) {\r\n                // Found a good leaf node, assign and exit\r\n                result = curNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * This walks forwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n */\r\nexport function getNextLeafSibling(rootNode: Node, startNode: Node): Node {\r\n    return getLeafSibling(rootNode, startNode, true /*isNext*/);\r\n}\r\n\r\n/**\r\n * This walks backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n */\r\nexport function getPreviousLeafSibling(rootNode: Node, startNode: Node): Node {\r\n    return getLeafSibling(rootNode, startNode, false /*isNext*/);\r\n}\r\n","import { DocumentPosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Checks if node1 is after node2\r\n * @param node1 The node to check if it is after another node\r\n * @param node2 The node to check if another node is after this one\r\n * @returns True if node1 is after node2, otherwise false\r\n */\r\nexport default function isNodeAfter(node1: Node, node2: Node): boolean {\r\n    return !!(\r\n        node1 &&\r\n        node2 &&\r\n        (node2.compareDocumentPosition(node1) & DocumentPosition.Following) ==\r\n            DocumentPosition.Following\r\n    );\r\n}\r\n","import isNodeAfter from './isNodeAfter';\r\n\r\n/**\r\n * Split parent node of the given node before/after the given node.\r\n * When a parent node contains [A,B,C] and pass B as the given node,\r\n * If split before, the new nodes will be [A][B,C] and returns [A];\r\n * otherwise, it will be [A,B][C] and returns [C].\r\n * @param node The node to split before/after\r\n * @param splitBefore Whether split before or after\r\n * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),\r\n * we remove it. @default false\r\n * @returns The new parent node\r\n */\r\nexport default function splitParentNode(node: Node, splitBefore: boolean): Node {\r\n    if (!node || !node.parentNode) {\r\n        return null;\r\n    }\r\n\r\n    let parentNode = node.parentNode;\r\n    let newParent = parentNode.cloneNode(false /*deep*/) as HTMLElement;\r\n    newParent.removeAttribute('id');\r\n    if (splitBefore) {\r\n        while (parentNode.firstChild && parentNode.firstChild != node) {\r\n            newParent.appendChild(parentNode.firstChild);\r\n        }\r\n    } else {\r\n        while (node.nextSibling) {\r\n            newParent.appendChild(node.nextSibling);\r\n        }\r\n    }\r\n\r\n    // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true\r\n    if (newParent.firstChild && newParent.innerHTML != '') {\r\n        parentNode.parentNode.insertBefore(\r\n            newParent,\r\n            splitBefore ? parentNode : parentNode.nextSibling\r\n        );\r\n    } else {\r\n        newParent = null;\r\n    }\r\n\r\n    return newParent;\r\n}\r\n\r\n/**\r\n * Split parent node by a balanced node range\r\n * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.\r\n * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored\r\n * @returns The parent node of the given node range if the given nodes are balanced, otherwise null\r\n */\r\nexport function splitBalancedNodeRange(nodes: Node | Node[]): HTMLElement {\r\n    let start = nodes instanceof Array ? nodes[0] : nodes;\r\n    let end = nodes instanceof Array ? nodes[nodes.length - 1] : nodes;\r\n    let parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;\r\n    if (parentNode) {\r\n        if (isNodeAfter(start, end)) {\r\n            let temp = end;\r\n            end = start;\r\n            start = temp;\r\n        }\r\n        splitParentNode(start, true /*splitBefore*/);\r\n        splitParentNode(end, false /*splitBefore*/);\r\n    }\r\n\r\n    return parentNode as HTMLElement;\r\n}\r\n","import { applyTextStyle, getComputedStyle, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { ChangeSource, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\nconst ZERO_WIDTH_SPACE = '\\u200B';\r\n\r\n/**\r\n * Apply inline style to current selection\r\n * @param editor The editor instance\r\n * @param callback The callback function to apply style\r\n */\r\nexport default function applyInlineStyle(\r\n    editor: Editor,\r\n    callback: (element: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    editor.focus();\r\n    let range = editor.getSelectionRange();\r\n\r\n    if (range && range.collapsed) {\r\n        let node = range.startContainer;\r\n        let isEmptySpan =\r\n            getTagOfNode(node) == 'SPAN' &&\r\n            (!node.firstChild ||\r\n                (getTagOfNode(node.firstChild) == 'BR' && !node.firstChild.nextSibling));\r\n        if (isEmptySpan) {\r\n            editor.addUndoSnapshot();\r\n            callback(node as HTMLElement);\r\n            updateLiFontSize(node as HTMLElement);\r\n        } else {\r\n            let isZWSNode =\r\n                node &&\r\n                node.nodeType == NodeType.Text &&\r\n                node.nodeValue == ZERO_WIDTH_SPACE &&\r\n                getTagOfNode(node.parentNode) == 'SPAN';\r\n\r\n            if (!isZWSNode) {\r\n                editor.addUndoSnapshot();\r\n                // Create a new text node to hold the selection.\r\n                // Some content is needed to position selection into the span\r\n                // for here, we inject ZWS - zero width space\r\n                node = editor.getDocument().createTextNode(ZERO_WIDTH_SPACE);\r\n                range.insertNode(node);\r\n            }\r\n\r\n            applyTextStyle(node, (element, isInnerNode) => {\r\n                callback(element, isInnerNode);\r\n                updateLiFontSize(element, isInnerNode);\r\n            });\r\n            editor.select(node, PositionType.End);\r\n        }\r\n    } else {\r\n        // This is start and end node that get the style. The start and end needs to be recorded so that selection\r\n        // can be re-applied post-applying style\r\n        editor.addUndoSnapshot(() => {\r\n            let firstNode: Node;\r\n            let lastNode: Node;\r\n            let contentTraverser = editor.getSelectionTraverser();\r\n            let inlineElement = contentTraverser && contentTraverser.currentInlineElement;\r\n            while (inlineElement) {\r\n                let nextInlineElement = contentTraverser.getNextInlineElement();\r\n                inlineElement.applyStyle((element, isInnerNode) => {\r\n                    callback(element, isInnerNode);\r\n                    updateLiFontSize(element, isInnerNode);\r\n\r\n                    firstNode = firstNode || element;\r\n                    lastNode = element;\r\n                });\r\n                inlineElement = nextInlineElement;\r\n            }\r\n            if (firstNode && lastNode) {\r\n                editor.select(firstNode, PositionType.Before, lastNode, PositionType.After);\r\n            }\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n\r\n/**\r\n * Special case to change LI font-size to first span fontsize\r\n * @param element\r\n * @param isInnerNode\r\n */\r\nfunction updateLiFontSize(element: HTMLElement, isInnerNode?: boolean) {\r\n    if (!isInnerNode && getTagOfNode(element.parentElement) == 'LI') {\r\n        let index = Array.from(element.parentNode.children).indexOf(element);\r\n        if (index == 0) {\r\n            let fontSize = getComputedStyle(element, 'font-size');\r\n            element.parentElement.style.fontSize = fontSize;\r\n        }\r\n    }\r\n}\r\n","export { default as HtmlSanitizer } from './sanitizer/HtmlSanitizer';\r\nexport { default as HtmlSanitizerOptions } from './types/HtmlSanitizerOptions';\r\nexport { default as SanitizeHtmlOptions } from './types/SanitizeHtmlOptions';\r\nexport { default as htmlToDom, splitWithFragment } from './utils/htmlToDom';\r\nexport { default as getInheritableStyles } from './utils/getInheritableStyles';\r\nexport {\r\n    AttributeCallback,\r\n    AttributeCallbackMap,\r\n    ElementCallback,\r\n    Map,\r\n    StringMap,\r\n    StyleCallback,\r\n    StyleCallbackMap,\r\n    ElementCallbackMap,\r\n} from './types/maps';\r\n","import fromHtml from './fromHtml';\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML tag name\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap<T extends keyof HTMLElementTagNameMap>(\r\n    nodes: Node | Node[],\r\n    wrapper?: T\r\n): HTMLElementTagNameMap[T];\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML string, default value is DIV\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string): HTMLElement;\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML element, default value is a new DIV element\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: HTMLElement): HTMLElement;\r\n\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string | HTMLElement): HTMLElement {\r\n    nodes = !nodes ? [] : nodes instanceof Node ? [nodes] : nodes;\r\n    if (nodes.length == 0 || !nodes[0]) {\r\n        return null;\r\n    }\r\n\r\n    if (!(wrapper instanceof Element)) {\r\n        let document = nodes[0].ownerDocument;\r\n        wrapper = wrapper || 'div';\r\n        wrapper = /^\\w+$/.test(wrapper)\r\n            ? document.createElement(wrapper)\r\n            : (fromHtml(wrapper, document)[0] as HTMLElement);\r\n    }\r\n\r\n    let parentNode = nodes[0].parentNode;\r\n\r\n    if (parentNode) {\r\n        parentNode.insertBefore(wrapper, nodes[0]);\r\n    }\r\n\r\n    for (let node of nodes) {\r\n        wrapper.appendChild(node);\r\n    }\r\n\r\n    return wrapper;\r\n}\r\n","import contains from './contains';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\ninterface HTMLElementForIE extends HTMLElement {\r\n    msMatchesSelector: (selector: string) => boolean;\r\n}\r\n\r\n/**\r\n * Find closest element ancestor start from the given node which matches the given selector\r\n * @param node Find ancestor start from this node\r\n * @param root Root node where the search should stop at. The return value can never be this node\r\n * @param selector The expected selector. If null, return the first HTML Element found from start node\r\n * @returns An HTML element which matches the given selector. If the given start node matches the selector,\r\n * returns the given node\r\n */\r\nexport default function findClosestElementAncestor(\r\n    node: Node,\r\n    root?: Node,\r\n    selector?: string\r\n): HTMLElement {\r\n    node = !node ? null : node.nodeType == NodeType.Element ? node : node.parentNode;\r\n    let element = node && node.nodeType == NodeType.Element ? <HTMLElement>node : null;\r\n\r\n    if (element && selector) {\r\n        if (element.closest) {\r\n            element = element.closest(selector) as HTMLElement;\r\n        } else {\r\n            while (\r\n                element &&\r\n                element != root &&\r\n                !(element.matches || (<HTMLElementForIE>element).msMatchesSelector).call(\r\n                    element,\r\n                    selector\r\n                )\r\n            ) {\r\n                element = element.parentElement;\r\n            }\r\n        }\r\n    }\r\n\r\n    return !root || contains(root, element) ? element : null;\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport Position from '../selection/Position';\r\nimport {\r\n    BlockElement,\r\n    InlineElement,\r\n    NodePosition,\r\n    NodeType,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents an inline element that can be reprented by a single html node.\r\n * This serves as base for most inline element as it contains most implentation\r\n * of all operations that can happen on an inline element. Other sub inline elements mostly\r\n * just identify themself for a certain type\r\n */\r\nexport default class NodeInlineElement implements InlineElement {\r\n    constructor(private containerNode: Node, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * The text content for this inline element\r\n     */\r\n    public getTextContent(): string {\r\n        // nodeValue is better way to retrieve content for a text. Others, just use textContent\r\n        return this.containerNode.nodeType == NodeType.Text\r\n            ? this.containerNode.nodeValue\r\n            : this.containerNode.textContent;\r\n    }\r\n\r\n    /**\r\n     * Get the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.containerNode;\r\n    }\r\n\r\n    // Get the parent block\r\n    public getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of the inline element\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest first child node from the container\r\n        return new Position(this.containerNode, 0).normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the end position of the inline element\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest last child node from the container\r\n        return new Position(this.containerNode, PositionType.End).normalize();\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.containerNode && this.containerNode.nodeType == NodeType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks if an inline element is after the current inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && isNodeAfter(this.containerNode, inlineElement.getContainerNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if the given position is contained in the inline element\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        let start = this.getStartPosition();\r\n        let end = this.getEndPosition();\r\n        return pos && pos.isAfter(start) && end.isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to an inline element\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any): void {\r\n        applyTextStyle(this.containerNode, styler);\r\n    }\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport createRange from '../selection/createRange';\r\nimport Position from '../selection/Position';\r\nimport { BlockElement, InlineElement, NodePosition, PositionType } from 'roosterjs-editor-types';\r\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\r\n\r\n/**\r\n * This is a special version of inline element that identifies a section of an inline element\r\n * We often have the need to cut an inline element in half and perform some operation only on half of an inline element\r\n * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element\r\n * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter\r\n * It also offers some special methods that others don't have, i.e. nextInlineElement etc.\r\n */\r\nexport default class PartialInlineElement implements InlineElement {\r\n    constructor(\r\n        private inlineElement: InlineElement,\r\n        private start?: NodePosition,\r\n        private end?: NodePosition\r\n    ) {}\r\n\r\n    /**\r\n     * Get the full inline element that this partial inline decorates\r\n     */\r\n    public getDecoratedInline(): InlineElement {\r\n        return this.inlineElement;\r\n    }\r\n\r\n    /**\r\n     * Gets the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.inlineElement.getContainerNode();\r\n    }\r\n\r\n    /**\r\n     * Gets the parent block\r\n     */\r\n    public getParentBlock(): BlockElement {\r\n        return this.inlineElement.getParentBlock();\r\n    }\r\n\r\n    /**\r\n     * Gets the text content\r\n     */\r\n    public getTextContent(): string {\r\n        let range = createRange(this.getStartPosition(), this.getEndPosition());\r\n\r\n        return range.toString();\r\n    }\r\n\r\n    /**\r\n     * Get start position of this inline element.\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        return this.start || this.inlineElement.getStartPosition();\r\n    }\r\n\r\n    /**\r\n     * Get end position of this inline element.\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        return this.end || this.inlineElement.getEndPosition();\r\n    }\r\n\r\n    /**\r\n     * Get next partial inline element if it is not at the end boundary yet\r\n     */\r\n    public get nextInlineElement(): PartialInlineElement {\r\n        return this.end && new PartialInlineElement(this.inlineElement, this.end, null);\r\n    }\r\n\r\n    /**\r\n     * Get previous partial inline element if it is not at the begin boundary yet\r\n     */\r\n    public get previousInlineElement(): PartialInlineElement {\r\n        return this.start && new PartialInlineElement(this.inlineElement, null, this.start);\r\n    }\r\n\r\n    /**\r\n     * Checks if it contains a position\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.inlineElement && this.inlineElement.isTextualInlineElement();\r\n    }\r\n\r\n    /**\r\n     * Check if this inline element is after the other inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        let thisStart = this.getStartPosition();\r\n        let otherEnd = inlineElement && inlineElement.getEndPosition();\r\n        return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));\r\n    }\r\n\r\n    /**\r\n     * apply style\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any) {\r\n        let from = this.getStartPosition().normalize();\r\n        let to = this.getEndPosition().normalize();\r\n        let container = this.getContainerNode();\r\n\r\n        if (from.isAtEnd) {\r\n            let nextNode = getNextLeafSibling(container, from.node);\r\n            from = nextNode ? new Position(nextNode, PositionType.Begin) : null;\r\n        }\r\n        if (to.offset == 0) {\r\n            let previousNode = getPreviousLeafSibling(container, to.node);\r\n            to = previousNode ? new Position(previousNode, PositionType.End) : null;\r\n        }\r\n\r\n        applyTextStyle(container, styler, from, to);\r\n    }\r\n}\r\n","export { default as HyperLink } from './HyperLink/HyperLink';\r\nexport { default as ContentEdit } from './ContentEdit/ContentEdit';\r\nexport { default as Paste } from './Paste/Paste';\r\nexport {\r\n    default as ContentEditFeatures,\r\n    getDefaultContentEditFeatures,\r\n} from './ContentEdit/ContentEditFeatures';\r\nexport { default as Watermark } from './Watermark/Watermark';\r\nexport { default as TableResize } from './TableResize/TableResize';\r\nexport { default as CustomReplace, Replacement } from './CustomReplace/CustomReplace';\r\n","import contains from '../utils/contains';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents a content block that can be reprented by a single html block type element.\r\n * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.\r\n */\r\nexport default class NodeBlockElement implements BlockElement {\r\n    constructor(private element: HTMLElement) { }\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the start node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the end node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Checks if it refers to same block\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        // Ideally there is only one unique way to generate a block so we only need to compare the startNode\r\n        return this.element == blockElement.getStartNode();\r\n    }\r\n\r\n    /**\r\n     * Checks if a block is after the current block\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        // if the block's startNode is after current node endEnd, we say it is after\r\n        return isNodeAfter(this.element, blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if a certain html node is within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return contains(this.element, node, true /*treatSameNodeAsContain*/);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        return this.element.textContent;\r\n    }\r\n}\r\n","import contains from './contains';\r\nimport splitParentNode from './splitParentNode';\r\n\r\n/**\r\n * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n * split parent nodes if necessary\r\n * @param root The root node of the scope\r\n * @param start The start node\r\n * @param end The end node\r\n * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n * and the returned nodes will be all nodes from start trhough end after splitting\r\n * False to disallow split parent\r\n * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n * otherwise just return start and end\r\n */\r\nexport default function collapseNodes(\r\n    root: Node,\r\n    start: Node,\r\n    end: Node,\r\n    canSplitParent: boolean\r\n): Node[] {\r\n    if (!contains(root, start) || !contains(root, end)) {\r\n        return [];\r\n    }\r\n\r\n    start = collapse(root, start, end, true /*isStart*/, canSplitParent);\r\n    end = collapse(root, end, start, false /*isStart*/, canSplitParent);\r\n\r\n    if (contains(start, end, true /*treateSameNodeAsContain*/)) {\r\n        return [start];\r\n    } else if (contains(end, start)) {\r\n        return [end];\r\n    } else if (start.parentNode == end.parentNode) {\r\n        let nodes = [].slice.call(start.parentNode.childNodes) as Node[];\r\n        let startIndex = nodes.indexOf(start);\r\n        let endIndex = nodes.indexOf(end);\r\n        return nodes.slice(startIndex, endIndex + 1);\r\n    } else {\r\n        return [start, end];\r\n    }\r\n}\r\n\r\nfunction collapse(\r\n    root: Node,\r\n    node: Node,\r\n    ref: Node,\r\n    isStart: boolean,\r\n    canSplitParent: boolean\r\n): Node {\r\n    while (node.parentNode != root && !contains(node.parentNode, ref)) {\r\n        if ((isStart && node.previousSibling) || (!isStart && node.nextSibling)) {\r\n            if (!canSplitParent) {\r\n                break;\r\n            }\r\n            splitParentNode(node, isStart);\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return node;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\nconst BLOCK_ELEMENT_TAGS = 'ADDRESS,ARTICLE,ASIDE,BLOCKQUOTE,CANVAS,DD,DIV,DL,DT,FIELDSET,FIGCAPTION,FIGURE,FOOTER,FORM,H1,H2,H3,H4,H5,H6,HEADER,HR,LI,MAIN,NAV,NOSCRIPT,OL,OUTPUT,P,PRE,SECTION,TABLE,TD,TH,TFOOT,UL,VIDEO'.split(\r\n    ','\r\n);\r\nconst BLOCK_DISPLAY_STYLES = ['block', 'list-item', 'table-cell'];\r\n\r\n/**\r\n * Checks if the node is a block like element. Block like element are usually those P, DIV, LI, TD etc.\r\n * @param node The node to check\r\n * @returns True if the node is a block element, otherwise false\r\n */\r\nexport default function isBlockElement(node: Node): boolean {\r\n    let tag = getTagOfNode(node);\r\n    return !!(\r\n        tag &&\r\n        (BLOCK_DISPLAY_STYLES.indexOf((<HTMLElement>node).style.display) >= 0 ||\r\n            BLOCK_ELEMENT_TAGS.indexOf(tag) >= 0)\r\n    );\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * HTML void elements\r\n * Per https://www.w3.org/TR/html/syntax.html#syntax-elements, cannot have child nodes\r\n * This regex is used when we move focus to very begin of editor. We should avoid putting focus inside\r\n * void elements so users don't accidently create child nodes in them\r\n */\r\nconst HTML_VOID_ELEMENTS = 'AREA,BASE,BR,COL,COMMAND,EMBED,HR,IMG,INPUT,KEYGEN,LINK,META,PARAM,SOURCE,TRACK,WBR'.split(\r\n    ','\r\n);\r\n\r\n/**\r\n * Check if the given node is html void element. Void element cannot have childen\r\n * @param node The node to check\r\n */\r\nexport default function isVoidHtmlElement(node: Node): boolean {\r\n    return !!node && HTML_VOID_ELEMENTS.indexOf(getTagOfNode(node)) >= 0;\r\n}\r\n","import BodyScoper from './BodyScoper';\r\nimport EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport SelectionBlockScoper from './SelectionBlockScoper';\r\nimport SelectionScoper from './SelectionScoper';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, ContentPosition, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementBeforeAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\n\r\n/**\r\n * The provides traversing of content inside editor.\r\n * There are two ways to traverse, block by block, or inline element by inline element\r\n * Block and inline traversing is independent from each other, meanning if you traverse block by block, it does not change\r\n * the current inline element position\r\n */\r\nexport default class ContentTraverser {\r\n    private currentInline: InlineElement;\r\n    private currentBlock: BlockElement;\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param scoper Traversing scoper object to help scope the traversing\r\n     */\r\n    private constructor(private scoper: TraversingScoper) {}\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param rootNode The root node to traverse in\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    public static createBodyTraverser(rootNode: Node, startNode?: Node): ContentTraverser {\r\n        return new ContentTraverser(new BodyScoper(rootNode, startNode));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for the given selection\r\n     * @param rootNode The root node to traverse in\r\n     * @param range The selection range to scope the traversing\r\n     */\r\n    public static createSelectionTraverser(rootNode: Node, range: Range): ContentTraverser {\r\n        return new ContentTraverser(new SelectionScoper(rootNode, range));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for a block element which contains the given position\r\n     * @param rootNode The root node to traverse in\r\n     * @param position A position inside a block, traversing will be scoped within this block.\r\n     * If passing a range, the start position of this range will be used\r\n     * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart\r\n     */\r\n    public static createBlockTraverser(\r\n        rootNode: Node,\r\n        position: NodePosition | Range,\r\n        start: ContentPosition = ContentPosition.SelectionStart\r\n    ): ContentTraverser {\r\n        return new ContentTraverser(new SelectionBlockScoper(rootNode, position, start));\r\n    }\r\n\r\n    /**\r\n     * Get current block\r\n     */\r\n    public get currentBlockElement(): BlockElement {\r\n        // Prepare currentBlock from the scoper\r\n        if (!this.currentBlock) {\r\n            this.currentBlock = this.scoper.getStartBlockElement();\r\n        }\r\n\r\n        return this.currentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get next block element\r\n     */\r\n    public getNextBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous block element\r\n     */\r\n    public getPreviousBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextBlockElement(isNext: boolean): BlockElement {\r\n        let current = this.currentBlockElement;\r\n        let leaf = getLeafSibling(\r\n            this.scoper.rootNode,\r\n            isNext ? current.getEndNode() : current.getStartNode(),\r\n            isNext\r\n        );\r\n        let newBlock = leaf ? getBlockElementAtNode(this.scoper.rootNode, leaf) : null;\r\n\r\n        // Make sure this is right block:\r\n        // 1) the block is in scope per scoper\r\n        // 2) the block is after (for next) or before (for previous) the current block\r\n        // Then:\r\n        // 1) Re-position current block to newly found block\r\n        if (\r\n            newBlock &&\r\n            this.scoper.isBlockInScope(newBlock) &&\r\n            ((isNext && newBlock.isAfter(current)) || (!isNext && current.isAfter(newBlock)))\r\n        ) {\r\n            this.currentBlock = newBlock;\r\n            return this.currentBlock;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Current inline element getter\r\n     */\r\n    public get currentInlineElement(): InlineElement {\r\n        // Retrieve a start inline from scoper\r\n        if (!this.currentInline) {\r\n            this.currentInline = this.scoper.getStartInlineElement();\r\n        }\r\n\r\n        return this.currentInline instanceof EmptyInlineElement ? null : this.currentInline;\r\n    }\r\n\r\n    /**\r\n     * Get next inline element\r\n     */\r\n    public getNextInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous inline element\r\n     */\r\n    public getPreviousInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextInlineElement(isNext: boolean): InlineElement {\r\n        let current = this.currentInlineElement || this.currentInline;\r\n        let newInline: InlineElement;\r\n\r\n        if (current instanceof EmptyInlineElement) {\r\n            newInline = getInlineElementBeforeAfter(\r\n                this.scoper.rootNode,\r\n                current.getStartPosition(),\r\n                isNext\r\n            );\r\n            if (newInline && !current.getParentBlock().contains(newInline.getContainerNode())) {\r\n                newInline = null;\r\n            }\r\n        } else {\r\n            newInline = getNextPreviousInlineElement(this.scoper.rootNode, current, isNext);\r\n            newInline =\r\n                newInline &&\r\n                current &&\r\n                ((isNext && newInline.isAfter(current)) || (!isNext && current.isAfter(newInline)))\r\n                    ? newInline\r\n                    : null;\r\n        }\r\n\r\n        // For inline, we need to make sure:\r\n        // 1) it is really next/previous to current\r\n        // 2) pass on the new inline to this.scoper to do the triming and we still get back an inline\r\n        // Then\r\n        // 1) re-position current inline\r\n        if (newInline && (newInline = this.scoper.trimInlineElement(newInline))) {\r\n            this.currentInline = newInline;\r\n            return this.currentInline;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getNextPreviousInlineElement(\r\n    rootNode: Node,\r\n    current: InlineElement,\r\n    isNext: boolean\r\n): InlineElement {\r\n    if (!current) {\r\n        return null;\r\n    }\r\n    if (current instanceof PartialInlineElement) {\r\n        // if current is partial, get the the othe half of the inline unless it is no more\r\n        let result = isNext ? current.nextInlineElement : current.previousInlineElement;\r\n\r\n        if (result) {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    // Get a leaf node after startNode and use that base to find next inline\r\n    let startNode = current.getContainerNode();\r\n    startNode = getLeafSibling(rootNode, startNode, isNext);\r\n    return getInlineElementAtNode(rootNode, startNode);\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport Position from '../selection/Position';\r\nimport splitTextNode from './splitTextNode';\r\nimport wrap from './wrap';\r\nimport { getNextLeafSibling } from './getLeafSibling';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from './splitParentNode';\r\n\r\nconst STYLETAGS = 'SPAN,B,I,U,EM,STRONG,STRIKE,S,SMALL'.split(',');\r\n\r\n/**\r\n * Apply style using a styler function to the given container node in the given range\r\n * @param container The container node to apply style to\r\n * @param styler The styler function\r\n * @param from From position\r\n * @param to To position\r\n */\r\nexport default function applyTextStyle(\r\n    container: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any,\r\n    from: NodePosition = new Position(container, PositionType.Begin).normalize(),\r\n    to: NodePosition = new Position(container, PositionType.End).normalize()\r\n) {\r\n    let formatNodes: Node[] = [];\r\n\r\n    while (from && to && to.isAfter(from)) {\r\n        let formatNode = from.node;\r\n        let parentTag = getTagOfNode(formatNode.parentNode);\r\n\r\n        // The code below modifies DOM. Need to get the next sibling first otherwise you won't be able to reliably get a good next sibling node\r\n        let nextNode = getNextLeafSibling(container, formatNode);\r\n\r\n        if (formatNode.nodeType == NodeType.Text && ['TR', 'TABLE'].indexOf(parentTag) < 0) {\r\n            if (formatNode == to.node && !to.isAtEnd) {\r\n                formatNode = splitTextNode(<Text>formatNode, to.offset, true /*returnFirstPart*/);\r\n            }\r\n\r\n            if (from.offset > 0) {\r\n                formatNode = splitTextNode(\r\n                    <Text>formatNode,\r\n                    from.offset,\r\n                    false /*returnFirstPart*/\r\n                );\r\n            }\r\n\r\n            formatNodes.push(formatNode);\r\n        }\r\n\r\n        from = nextNode && new Position(nextNode, PositionType.Begin);\r\n    }\r\n\r\n    if (formatNodes.length > 0) {\r\n        if (formatNodes.every(node => node.parentNode == formatNodes[0].parentNode)) {\r\n            let newNode = formatNodes.shift();\r\n            formatNodes.forEach(node => {\r\n                newNode.nodeValue += node.nodeValue;\r\n                node.parentNode.removeChild(node);\r\n            });\r\n            formatNodes = [newNode];\r\n        }\r\n\r\n        formatNodes.forEach(node => {\r\n            // When apply style within style tags like B/I/U/..., we split the tag and apply outside them\r\n            // So that the inner style tag such as U, STRIKE can inherit the style we added\r\n            while (\r\n                getTagOfNode(node) != 'SPAN' &&\r\n                STYLETAGS.indexOf(getTagOfNode(node.parentNode)) >= 0\r\n            ) {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n\r\n            if (getTagOfNode(node) != 'SPAN') {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = wrap(node, 'SPAN');\r\n            }\r\n            styler(<HTMLElement>node);\r\n        });\r\n    }\r\n}\r\n\r\nfunction callStylerWithInnerNode(\r\n    node: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    if (node && node.nodeType == NodeType.Element) {\r\n        styler(node as HTMLElement, true /*isInnerNode*/);\r\n    }\r\n}\r\n","/**\r\n * Split a text node into two parts by an offset number, and return one of them\r\n * @param textNode The text node to split\r\n * @param offset The offset number to split at\r\n * @param returnFirstPart True to return the first part, then the passed in textNode will become the second part.\r\n * Otherwise return the second part, and the passed in textNode will become the first part\r\n */\r\nexport default function splitTextNode(textNode: Text, offset: number, returnFirstPart: boolean) {\r\n    const firstPart = textNode.nodeValue.substr(0, offset);\r\n    const secondPart = textNode.nodeValue.substr(offset);\r\n    const newNode = textNode.ownerDocument.createTextNode(returnFirstPart ? firstPart : secondPart);\r\n    textNode.nodeValue = returnFirstPart ? secondPart : firstPart;\r\n    textNode.parentNode.insertBefore(newNode, returnFirstPart ? textNode : textNode.nextSibling);\r\n    return newNode;\r\n}\r\n","import { getComputedStyle } from './getComputedStyles';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst CRLF = /^[\\r\\n]+$/gm;\r\n\r\n/**\r\n * Skip a node when any of following conditions are true\r\n * - it is neither Element nor Text\r\n * - it is a text node but is empty\r\n * - it is a text node but contains just CRLF (noisy text node that often comes in-between elements)\r\n * - has a display:none\r\n */\r\nexport default function shouldSkipNode(node: Node): boolean {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return !node.nodeValue || node.textContent == '' || CRLF.test(node.nodeValue);\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        return getComputedStyle(node, 'display') == 'none';\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n","import findClosestElementAncestor from './findClosestElementAncestor';\r\n\r\n/**\r\n * Get computed styles of a node\r\n * @param node The node to get computed styles from\r\n * @param styleNames Names of style to get, can be a single name or an array.\r\n * Default value is font-family, font-size, color, background-color\r\n * @returns An array of the computed styles\r\n */\r\nexport default function getComputedStyles(\r\n    node: Node,\r\n    styleNames: string | string[] = ['font-family', 'font-size', 'color', 'background-color']\r\n): string[] {\r\n    let element = findClosestElementAncestor(node);\r\n    let result: string[] = [];\r\n    styleNames = styleNames instanceof Array ? styleNames : [styleNames];\r\n    if (element) {\r\n        let win = element.ownerDocument.defaultView || window;\r\n        let styles = win.getComputedStyle(element);\r\n\r\n        if (styles) {\r\n            for (let style of styleNames) {\r\n                let value = (styles.getPropertyValue(style) || '').toLowerCase();\r\n                value = style == 'font-size' ? px2Pt(value) : value;\r\n                result.push(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * A shortcut for getComputedStyles() when only one style is to be retrieved\r\n * @param node The node to get style from\r\n * @param styleName The style name\r\n * @returns The style value\r\n */\r\nexport function getComputedStyle(node: Node, styleName: string): string {\r\n    return getComputedStyles(node, styleName)[0] || '';\r\n}\r\n\r\nfunction px2Pt(px: string) {\r\n    if (px && px.indexOf('px') == px.length - 2) {\r\n        // Edge may not handle the floating computing well which causes the calculated value is a little less than actual value\r\n        // So add 0.05 to fix it\r\n        return Math.round(parseFloat(px) * 75 + 0.05) / 100 + 'pt';\r\n    }\r\n    return px;\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport PartialInlineElement from './PartialInlineElement';\r\nimport shouldSkipNode from '../utils/shouldSkipNode';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport { InlineElement, NodePosition, NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get inline element before a position\r\n * This is mostly used when we want to get the inline element before selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement before\r\n */\r\nexport function getInlineElementBefore(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, false /*isAfter*/);\r\n}\r\n\r\n/**\r\n * Get inline element after a position\r\n * This is mostly used when we want to get the inline element after selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement after\r\n */\r\nexport function getInlineElementAfter(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, true /*isAfter*/);\r\n}\r\n\r\nexport function getInlineElementBeforeAfter(root: Node, position: NodePosition, isAfter: boolean) {\r\n    if (!root || !position || !position.node) {\r\n        return null;\r\n    }\r\n\r\n    position = position.normalize();\r\n    let { node, offset, isAtEnd } = position;\r\n    let isPartial = false;\r\n\r\n    if ((!isAfter && offset == 0 && !isAtEnd) || (isAfter && isAtEnd)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    } else if (\r\n        node.nodeType == NodeType.Text &&\r\n        ((!isAfter && !isAtEnd) || (isAfter && offset > 0))\r\n    ) {\r\n        isPartial = true;\r\n    }\r\n\r\n    if (node && shouldSkipNode(node)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    }\r\n\r\n    let inlineElement = getInlineElementAtNode(root, node);\r\n\r\n    if (inlineElement && (isPartial || inlineElement.contains(position))) {\r\n        inlineElement = isAfter\r\n            ? new PartialInlineElement(inlineElement, position, null)\r\n            : new PartialInlineElement(inlineElement, null, position);\r\n    }\r\n\r\n    return inlineElement;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst VISIBLE_ELEMENT_TAGS = ['IMG'];\r\nconst VISIBLE_CHILD_ELEMENT_SELECTOR = ['TABLE', 'IMG', 'LI'].join(',');\r\nconst ZERO_WIDTH_SPACE = /\\u200b/g;\r\n\r\n/**\r\n * Check if a given node has no visible content\r\n * @param node The node to check\r\n * @param trimContent Whether trim the text content so that spaces will be treated as empty.\r\n * Default value is false\r\n * @returns True if there isn't any visible element inside node, otherwise false\r\n */\r\nexport default function isNodeEmpty(node: Node, trimContent?: boolean) {\r\n    if (!node) {\r\n        return false;\r\n    } else if (node.nodeType == NodeType.Text) {\r\n        return trim(node.nodeValue, trimContent) == '';\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        let element = node as Element;\r\n        let textContent = trim(element.textContent, trimContent);\r\n        if (\r\n            textContent != '' ||\r\n            VISIBLE_ELEMENT_TAGS.indexOf(getTagOfNode(element)) >= 0 ||\r\n            element.querySelectorAll(VISIBLE_CHILD_ELEMENT_SELECTOR)[0]\r\n        ) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction trim(s: string, trim: boolean) {\r\n    s = s.replace(ZERO_WIDTH_SPACE, '');\r\n    return trim ? s.trim() : s;\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check whether can move current snapshot with the given step\r\n * @param snapshots The snapshots data structure to check\r\n * @param step The step to check, can be positive, negative or 0\r\n * @returns True if can move current snapshot with the given step, otherwise false\r\n */\r\nexport default function canMoveCurrentSnapshot(snapshots: Snapshots, step: number): boolean {\r\n    let newIndex = snapshots.currentIndex + step;\r\n    return newIndex >= 0 && newIndex < snapshots.snapshots.length;\r\n}\r\n","import { PluginEvent } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Gets the cached event data by cache key from event object if there is already one.\r\n * Otherwise, call getter function to create one, and cache it.\r\n * @param event The event object\r\n * @param key Cache key string, need to be unique\r\n * @param getter Getter function to get the object when it is not in cache yet\r\n */\r\nexport default function cacheGetEventData<T>(event: PluginEvent, key: string, getter: () => T): T {\r\n    let result =\r\n        event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)\r\n            ? <T>event.eventDataCache[key]\r\n            : getter();\r\n    if (event) {\r\n        event.eventDataCache = event.eventDataCache || {};\r\n        event.eventDataCache[key] = result;\r\n    }\r\n\r\n    return result;\r\n}\r\n","import { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    fromHtml,\r\n    isVoidHtmlElement,\r\n    isBlockElement,\r\n    Browser,\r\n    getSelectionPath,\r\n    getRangeFromSelectionPath,\r\n    getTagOfNode,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst TEMP_NODE_CLASS = 'ROOSTERJS_TEMP_NODE_FOR_LIST';\r\nconst TEMP_NODE_HTML = '<img class=\"' + TEMP_NODE_CLASS + '\">';\r\n\r\ntype ValidProcessListDocumentCommands =\r\n    | DocumentCommand.Outdent\r\n    | DocumentCommand.Indent\r\n    | DocumentCommand.InsertOrderedList\r\n    | DocumentCommand.InsertUnorderedList;\r\n\r\n/**\r\n * Browsers don't handle bullet/numbering list well, especially the formats when switching list statue\r\n * So we workaround it by always adding format to list element\r\n */\r\nexport default function processList(\r\n    editor: Editor,\r\n    command: ValidProcessListDocumentCommands\r\n): Node {\r\n    let clonedNode: Node;\r\n    let relativeSelectionPath;\r\n    if (Browser.isChrome && command == DocumentCommand.Outdent) {\r\n        const parentLINode = editor.getElementAtCursor('LI');\r\n        if (parentLINode) {\r\n            let currentRange = editor.getSelectionRange();\r\n            if (\r\n                currentRange.collapsed ||\r\n                (editor.getElementAtCursor('LI', currentRange.startContainer) == parentLINode &&\r\n                    editor.getElementAtCursor('LI', currentRange.endContainer) == parentLINode)\r\n            ) {\r\n                relativeSelectionPath = getSelectionPath(parentLINode, currentRange);\r\n                // Chrome has some bad behavior when outdenting\r\n                // in order to work around this, we need to take steps to deep clone the current node\r\n                // after the outdent, we'll replace the new LI with the cloned content.\r\n                clonedNode = parentLINode.cloneNode(true);\r\n            }\r\n        }\r\n\r\n        workaroundForChrome(editor);\r\n    }\r\n\r\n    let existingList = editor.getElementAtCursor('OL,UL');\r\n    editor.getDocument().execCommand(command, false, null);\r\n    let newParentNode: Node;\r\n    editor.queryElements('.' + TEMP_NODE_CLASS, node => {\r\n        newParentNode = node.parentNode;\r\n        editor.deleteNode(node);\r\n    });\r\n    let newList = editor.getElementAtCursor('OL,UL');\r\n    if (newList == existingList) {\r\n        newList = null;\r\n    }\r\n\r\n    if (newList && clonedNode && newParentNode) {\r\n        // if the clonedNode and the newLIParent share the same tag name\r\n        // we can 1:1 swap them\r\n        if (clonedNode instanceof HTMLElement) {\r\n            if (\r\n                newParentNode instanceof HTMLElement &&\r\n                clonedNode.tagName == newParentNode.tagName\r\n            ) {\r\n                newList.replaceChild(clonedNode, newParentNode);\r\n            }\r\n            if (relativeSelectionPath && document.body.contains(clonedNode)) {\r\n                let newRange = getRangeFromSelectionPath(clonedNode, relativeSelectionPath);\r\n                editor.select(newRange);\r\n            }\r\n        }\r\n        // The alternative case is harder to solve, but we didn't specifically handle this before either.\r\n    }\r\n\r\n    //change font-size of list elements\r\n    if (newList != null) {\r\n        for (let i = 0; i < newList.children.length; i++) {\r\n            let listItem = newList.children.item(i) as HTMLElement;\r\n\r\n            if (getTagOfNode(listItem) == 'LI') {\r\n                if (listItem.childNodes.length > 0) {\r\n                    let firstSpan = listItem.children.item(0) as HTMLElement;\r\n\r\n                    if (getTagOfNode(firstSpan) == 'SPAN') {\r\n                        listItem.style.fontSize = firstSpan.style.fontSize;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return newList;\r\n}\r\n\r\nfunction workaroundForChrome(editor: Editor) {\r\n    let traverser = editor.getSelectionTraverser();\r\n    let block = traverser && traverser.currentBlockElement;\r\n    while (block) {\r\n        let container = block.getStartNode();\r\n\r\n        if (container) {\r\n            // Add a temp <IMG> tag before all other nodes in the block to avoid Chrome remove existing format when toggle list\r\n            const tempNode = fromHtml(TEMP_NODE_HTML, editor.getDocument())[0];\r\n            if (isVoidHtmlElement(container) || !isBlockElement(container)) {\r\n                container.parentNode.insertBefore(tempNode, container);\r\n            } else {\r\n                container.insertBefore(tempNode, container.firstChild);\r\n            }\r\n        }\r\n\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n}\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport wrap from '../utils/wrap';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from '../utils/splitParentNode';\r\nimport createRange from '../selection/createRange';\r\n\r\nconst STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];\r\n\r\n/**\r\n * This reprents a block that is identified by a start and end node\r\n * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;\r\n * in that case, Hello&lt;BR&gt; is a block, World is another block\r\n * Such block cannot be represented by a NodeBlockElement since they don't chained up\r\n * to a single parent node, instead they have a start and end\r\n * This start and end must be in same sibling level and have same parent in DOM tree\r\n */\r\nexport default class StartEndBlockElement implements BlockElement {\r\n    constructor(private rootNode: Node, private startNode: Node, private endNode: Node) { }\r\n\r\n    static getBlockContext(node: Node): HTMLElement {\r\n        while (node && !isBlockElement(node)) {\r\n            node = node.parentNode;\r\n        }\r\n        return node as HTMLElement;\r\n    }\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        let nodes = collapseNodes(\r\n            StartEndBlockElement.getBlockContext(this.startNode),\r\n            this.startNode,\r\n            this.endNode,\r\n            true /*canSplitParent*/\r\n        );\r\n        let blockContext = StartEndBlockElement.getBlockContext(this.startNode);\r\n        while (\r\n            nodes[0] &&\r\n            nodes[0] != blockContext &&\r\n            nodes[0].parentNode != this.rootNode &&\r\n            STRUCTURE_NODE_TAGS.indexOf(getTagOfNode(nodes[0].parentNode)) < 0\r\n        ) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n        return nodes.length == 1 && isBlockElement(nodes[0])\r\n            ? (nodes[0] as HTMLElement)\r\n            : wrap(nodes);\r\n    }\r\n\r\n    /**\r\n     * Gets the start node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.startNode;\r\n    }\r\n\r\n    /**\r\n     * Gets the end node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.endNode;\r\n    }\r\n\r\n    /**\r\n     * Checks equals of two blocks\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        return (\r\n            this.startNode == blockElement.getStartNode() &&\r\n            this.endNode == blockElement.getEndNode()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if another block is after this current\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        return isNodeAfter(this.getStartNode(), blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if an Html node is contained within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return (\r\n            contains(this.startNode, node, true /*treatSameNodeAsContain*/) ||\r\n            contains(this.endNode, node, true /*treatSameNodeAsContain*/) ||\r\n            (isNodeAfter(node, this.startNode) && isNodeAfter(this.endNode, node))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        return createRange(this.getStartNode(), this.getEndNode()).toString();\r\n    }\r\n}\r\n","/**\r\n * Creates an HTML node array from html\r\n * @param html the html string to create HTML elements from\r\n * @param ownerDocument Owner document of the result HTML elements\r\n * @returns An HTML node array to represent the given html string\r\n */\r\nexport default function fromHtml(html: string, ownerDocument: HTMLDocument): Node[] {\r\n    let element = ownerDocument.createElement('DIV');\r\n    element.innerHTML = html;\r\n\r\n    return [].slice.call(element.childNodes);\r\n}\r\n","import getBlockElementAtNode from './getBlockElementAtNode';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the first/last BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n * @param isFirst True to get first BlockElement, false to get last BlockElement\r\n */\r\nexport default function getFirstLastBlockElement(rootNode: Node, isFirst: boolean): BlockElement {\r\n    let node = rootNode;\r\n    do {\r\n        node = node && (isFirst ? node.firstChild : node.lastChild);\r\n    } while (node && node.firstChild);\r\n    return node && getBlockElementAtNode(rootNode, node);\r\n}\r\n\r\n/**\r\n * Get the first BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n */\r\nexport function getFirstBlockElement(rootNode: Node): BlockElement {\r\n    return getFirstLastBlockElement(rootNode, true /*isFirst*/);\r\n}\r\n\r\n/**\r\n * Get the last BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n */\r\nexport function getLastBlockElement(rootNode: Node): BlockElement {\r\n    return getFirstLastBlockElement(rootNode, false /*isFirst*/);\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is an inline element representing an Html image\r\n */\r\nexport default class ImageInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is inline element presenting an html hyperlink\r\n */\r\nexport default class LinkInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport { getFirstLeafNode, getLastLeafNode } from '../utils/getLeafNode';\r\nimport { InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the first inline element inside the given node\r\n */\r\nexport function getFirstInlineElement(rootNode: Node): InlineElement {\r\n    // getFirstLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getFirstLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n\r\n/**\r\n * Get the last inline element inside the given node\r\n */\r\nexport function getLastInlineElement(rootNode: Node): InlineElement {\r\n    // getLastLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getLastLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n","import shouldSkipNode from './shouldSkipNode';\r\nimport { getLeafSibling } from './getLeafSibling';\r\n\r\n/**\r\n * Get first/last leaf node of the given root node.\r\n * @param rootNode Root node to get leaf node from\r\n * @param isFirst True to get first leaf node, false to get last leaf node\r\n */\r\nfunction getLeafNode(rootNode: Node, isFirst: boolean): Node {\r\n    let getChild = (node: Node): Node => (isFirst ? node.firstChild : node.lastChild);\r\n    let result = getChild(rootNode);\r\n    while (result && getChild(result)) {\r\n        result = getChild(result);\r\n    }\r\n\r\n    if (result && shouldSkipNode(result)) {\r\n        result = getLeafSibling(rootNode, result, isFirst);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Get the first meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getFirstLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, true /*isFirst*/);\r\n}\r\n\r\n/**\r\n * Get the last meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getLastLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, false /*isFirst*/);\r\n}\r\n","import { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represents an empty InlineElement.\r\n * This is used for ContentTraverser internally only.\r\n * An empty InlineElement means current position is at the end of a tag so nothing is included inside this element\r\n */\r\nexport default class EmptyInlineElement implements InlineElement {\r\n    constructor(private position: NodePosition, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * Get the text content of this inline element\r\n     */\r\n    getTextContent(): string {\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Get the container node of this inline element\r\n     */\r\n    getContainerNode(): Node {\r\n        return this.position.node;\r\n    }\r\n\r\n    /**\r\n     * Get the parent block element of this inline element\r\n     */\r\n    getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of this inline element\r\n     */\r\n    getStartPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Get the end position of this inline element\r\n     */\r\n    getEndPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given inline element is after this inline element\r\n     */\r\n    isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && this.position.isAfter(inlineElement.getEndPosition());\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    isTextualInlineElement(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given editor position is contained in this inline element\r\n     */\r\n    contains(position: NodePosition): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to a region of an inline element.\r\n     */\r\n    applyStyle(styler: (element: HTMLElement) => any): void {}\r\n}\r\n","import { BrowserInfo } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get current browser information from user agent string\r\n * @param userAgent The userAgent string of a browser\r\n * @param appVersion The appVersion string of a browser\r\n * @returns The BrowserInfo object calculated from the given userAgent and appVersion\r\n */\r\nexport function getBrowserInfo(userAgent: string, appVersion: string): BrowserInfo {\r\n    // checks whether the browser is running in IE\r\n    // IE11 will use rv in UA instead of MSIE. Unfortunately Firefox also uses this. We should also look for \"Trident\" to confirm this.\r\n    // There have been cases where companies using older version of IE and custom UserAgents have broken this logic (e.g. IE 10 and KellyServices)\r\n    // therefore we should check that the Trident/rv combo is not just from an older IE browser\r\n    let isIE11OrGreater = userAgent.indexOf('rv:') != -1 && userAgent.indexOf('Trident') != -1;\r\n    let isIE = userAgent.indexOf('MSIE') != -1 || isIE11OrGreater;\r\n\r\n    // IE11+ may also have 'Chrome', 'Firefox' and 'Safari' in user agent. But it will have 'trident' as well\r\n    let isChrome = false;\r\n    let isFirefox = false;\r\n    let isSafari = false;\r\n    let isEdge = false;\r\n    let isWebKit = userAgent.indexOf('WebKit') != -1;\r\n\r\n    if (!isIE) {\r\n        isChrome = userAgent.indexOf('Chrome') != -1;\r\n        isFirefox = userAgent.indexOf('Firefox') != -1;\r\n        if (userAgent.indexOf('Safari') != -1) {\r\n            // Android and Chrome have Safari in the user string\r\n            isSafari = userAgent.indexOf('Chrome') == -1 && userAgent.indexOf('Android') == -1;\r\n        }\r\n\r\n        // Sample Edge UA: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10121\r\n        isEdge = userAgent.indexOf('Edge') != -1;\r\n\r\n        // When it is edge, it should not be chrome or firefox. and it is also not webkit\r\n        if (isEdge) {\r\n            isWebKit = isChrome = isFirefox = false;\r\n        }\r\n    }\r\n\r\n    let isMac = appVersion.indexOf('Mac') != -1;\r\n    let isWin = appVersion.indexOf('Win') != -1 || appVersion.indexOf('NT') != -1;\r\n\r\n    return {\r\n        isMac,\r\n        isWin,\r\n        isWebKit,\r\n        isIE,\r\n        isIE11OrGreater,\r\n        isSafari,\r\n        isChrome,\r\n        isFirefox,\r\n        isEdge,\r\n        isIEOrEdge: isIE || isEdge,\r\n    };\r\n}\r\n\r\n/**\r\n * Browser object contains browser and operating system informations of current environment\r\n */\r\nexport const Browser = window\r\n    ? getBrowserInfo(window.navigator.userAgent, window.navigator.appVersion)\r\n    : {};\r\n","import getComputedStyles from './getComputedStyles';\r\nimport getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag<K extends keyof HTMLElementTagNameMap>(\r\n    element: HTMLElement,\r\n    newTag: K\r\n): HTMLElementTagNameMap[K];\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement;\r\n\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement {\r\n    if (!element || !newTag) {\r\n        return null;\r\n    }\r\n\r\n    let newElement = element.ownerDocument.createElement(newTag);\r\n\r\n    for (let i = 0; i < element.attributes.length; i++) {\r\n        let attr = element.attributes[i];\r\n        newElement.setAttribute(attr.name, attr.value);\r\n    }\r\n\r\n    while (element.firstChild) {\r\n        newElement.appendChild(element.firstChild);\r\n    }\r\n\r\n    if (getTagOfNode(element) == 'P' || getTagOfNode(newElement) == 'P') {\r\n        [newElement.style.marginTop, newElement.style.marginBottom] = getComputedStyles(element, [\r\n            'margin-top',\r\n            'margin-bottom',\r\n        ]);\r\n    }\r\n\r\n    if (element.parentNode) {\r\n        element.parentNode.replaceChild(newElement, element);\r\n    }\r\n\r\n    return newElement;\r\n}\r\n","import contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isNodeEmpty from '../utils/isNodeEmpty';\r\nimport { NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check if this position is at beginning of the given node.\r\n * This will return true if all nodes between the beginning of target node and the position are empty.\r\n * @param position The position to check\r\n * @param targetNode The node to check\r\n * @returns True if position is at beginning of the node, otherwise false\r\n */\r\nexport default function isPositionAtBeginningOf(position: NodePosition, targetNode: Node) {\r\n    if (position) {\r\n        let { node, offset } = position.normalize();\r\n        if (offset == 0) {\r\n            while (contains(targetNode, node) && areAllPrevousNodesEmpty(node)) {\r\n                node = node.parentNode;\r\n            }\r\n\r\n            return node == targetNode;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction areAllPrevousNodesEmpty(node: Node): boolean {\r\n    while (node.previousSibling) {\r\n        node = node.previousSibling;\r\n        if (getTagOfNode(node) == 'BR' || !isNodeEmpty(node)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n","import { DocumentPosition } from 'roosterjs-editor-types';\r\nimport { QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Query HTML elements in the container by a selector string\r\n * @param container Container element to query from\r\n * @param selector Selector string to query\r\n * @param forEachCallback An optional callback to be invoked on each node in query result\r\n * @param scope The scope of the query, default value is QueryScope.Body\r\n * @param range The selection range to query with. This is required when scope is not Body\r\n * @returns HTML Element array of the query result\r\n */\r\nexport default function queryElements(\r\n    container: HTMLElement,\r\n    selector: string,\r\n    forEachCallback?: (node: HTMLElement) => any,\r\n    scope: QueryScope = QueryScope.Body,\r\n    range?: Range\r\n): HTMLElement[] {\r\n    if (!container || !selector) {\r\n        return [];\r\n    }\r\n\r\n    let elements = [].slice.call(container.querySelectorAll(selector)) as HTMLElement[];\r\n\r\n    if (scope != QueryScope.Body && range) {\r\n        elements = elements.filter(element =>\r\n            isIntersectWithNodeRange(element, range, scope == QueryScope.InSelection)\r\n        );\r\n    }\r\n\r\n    if (forEachCallback) {\r\n        elements.forEach(forEachCallback);\r\n    }\r\n    return elements;\r\n}\r\n\r\nfunction isIntersectWithNodeRange(\r\n    node: Node,\r\n    range: Range,\r\n    nodeContainedByRangeOnly: boolean\r\n): boolean {\r\n    let startPosition = node.compareDocumentPosition(range.startContainer);\r\n    let endPosition = node.compareDocumentPosition(range.endContainer);\r\n    let targetPositions = [DocumentPosition.Same, DocumentPosition.Contains];\r\n\r\n    if (!nodeContainedByRangeOnly) {\r\n        targetPositions.push(DocumentPosition.ContainedBy);\r\n    }\r\n\r\n    return (\r\n        checkPosition(startPosition, targetPositions) || // intersectStart\r\n        checkPosition(endPosition, targetPositions) || // intersectEnd\r\n        (checkPosition(startPosition, [DocumentPosition.Preceding]) && // Contains\r\n            checkPosition(endPosition, [DocumentPosition.Following]) &&\r\n            !checkPosition(endPosition, [DocumentPosition.ContainedBy]))\r\n    );\r\n}\r\n\r\nfunction checkPosition(position: DocumentPosition, targets: DocumentPosition[]): boolean {\r\n    return targets.some(target =>\r\n        target == DocumentPosition.Same\r\n            ? position == DocumentPosition.Same\r\n            : (position & target) == target\r\n    );\r\n}\r\n","/**\r\n * Removes the node and keep all children in place, return the parentNode where the children are attached\r\n * @param node the node to remove\r\n */\r\nexport default function unwrap(node: Node): Node {\r\n    // Unwrap requires a parentNode\r\n    let parentNode = node ? node.parentNode : null;\r\n    if (!parentNode) {\r\n        return null;\r\n    }\r\n\r\n    while (node.firstChild) {\r\n        parentNode.insertBefore(node.firstChild, node);\r\n    }\r\n\r\n    parentNode.removeChild(node);\r\n    return parentNode;\r\n}\r\n","import { TableFormat, TableOperation } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represent a virtual cell of a virtual table\r\n */\r\nexport interface VCell {\r\n    /**\r\n     * The table cell object. The value will be null if this is an expanded virtual cell\r\n     */\r\n    td?: HTMLTableCellElement;\r\n\r\n    /**\r\n     * Whether this cell is spanned from left\r\n     */\r\n    spanLeft?: boolean;\r\n\r\n    /**\r\n     * Whether this cell is spanned from above\r\n     */\r\n    spanAbove?: boolean;\r\n}\r\n\r\n/**\r\n * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells\r\n */\r\nexport default class VTable {\r\n    /**\r\n     * The HTML table object\r\n     */\r\n    table: HTMLTableElement;\r\n\r\n    /**\r\n     * Virtual cells\r\n     */\r\n    cells: VCell[][];\r\n\r\n    /**\r\n     * Current row index\r\n     */\r\n    row: number;\r\n\r\n    /**\r\n     * Current column index\r\n     */\r\n    col: number;\r\n\r\n    private trs: HTMLTableRowElement[] = [];\r\n\r\n    /**\r\n     * Create a new instance of VTable object using HTML TABLE or TD node\r\n     * @param node The HTML Table or TD node\r\n     */\r\n    constructor(node: HTMLTableElement | HTMLTableCellElement) {\r\n        this.table = node instanceof HTMLTableElement ? node : getTableFromTd(node);\r\n        if (this.table) {\r\n            let currentTd = node instanceof HTMLTableElement ? null : node;\r\n            let trs = <HTMLTableRowElement[]>[].slice.call(this.table.rows);\r\n            this.cells = trs.map(row => []);\r\n            trs.forEach((tr, rowIndex) => {\r\n                this.trs[rowIndex % 2] = tr;\r\n                for (let sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {\r\n                    // Skip the cells which already initialized\r\n                    for (; this.cells[rowIndex][targetCol]; targetCol++) {}\r\n\r\n                    let td = tr.cells[sourceCol];\r\n                    if (td == currentTd) {\r\n                        this.col = targetCol;\r\n                        this.row = rowIndex;\r\n                    }\r\n\r\n                    for (let colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {\r\n                        for (let rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {\r\n                            this.cells[rowIndex + rowSpan][targetCol] = {\r\n                                td: colSpan + rowSpan == 0 ? td : null,\r\n                                spanLeft: colSpan > 0,\r\n                                spanAbove: rowSpan > 0,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write the virtual table back to DOM tree to represent the change of VTable\r\n     */\r\n    writeBack() {\r\n        if (this.cells) {\r\n            moveChildren(this.table);\r\n            this.cells.forEach((row, r) => {\r\n                let tr = cloneNode(this.trs[r % 2] || this.trs[0]);\r\n                this.table.appendChild(tr);\r\n                row.forEach((cell, c) => {\r\n                    if (cell.td) {\r\n                        this.recalcSpans(r, c);\r\n                        tr.appendChild(cell.td);\r\n                    }\r\n                });\r\n            });\r\n        } else if (this.table) {\r\n            this.table.parentNode.removeChild(this.table);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the given table format to this virtual table\r\n     * @param format Table format to apply\r\n     */\r\n    applyFormat(format: Partial<TableFormat>) {\r\n        if (!format || !this.table) {\r\n            return;\r\n        }\r\n        this.table.style.borderCollapse = 'collapse';\r\n        this.trs[0].style.backgroundColor = format.bgColorOdd || 'transparent';\r\n        if (this.trs[1]) {\r\n            this.trs[1].style.backgroundColor = format.bgColorEven || 'transparent';\r\n        }\r\n        this.cells.forEach(row =>\r\n            row\r\n                .filter(cell => cell.td)\r\n                .forEach(cell => {\r\n                    cell.td.style.borderTop = getBorderStyle(format.topBorderColor);\r\n                    cell.td.style.borderBottom = getBorderStyle(format.bottomBorderColor);\r\n                    cell.td.style.borderLeft = getBorderStyle(format.verticalBorderColor);\r\n                    cell.td.style.borderRight = getBorderStyle(format.verticalBorderColor);\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Edit table with given operation.\r\n     * @param operation Table operation\r\n     */\r\n    edit(operation: TableOperation) {\r\n        if (!this.table) {\r\n            return;\r\n        }\r\n\r\n        let currentRow = this.cells[this.row];\r\n        let currentCell = currentRow[this.col];\r\n        switch (operation) {\r\n            case TableOperation.InsertAbove:\r\n                this.cells.splice(this.row, 0, currentRow.map(cloneCell));\r\n                break;\r\n            case TableOperation.InsertBelow:\r\n                let newRow = this.row + this.countSpanAbove(this.row, this.col);\r\n                this.cells.splice(\r\n                    newRow,\r\n                    0,\r\n                    this.cells[newRow - 1].map((cell, colIndex) => {\r\n                        let nextCell = this.getCell(newRow, colIndex);\r\n                        if (nextCell.spanAbove) {\r\n                            return cloneCell(nextCell);\r\n                        } else if (cell.spanLeft) {\r\n                            let newCell = cloneCell(cell);\r\n                            newCell.spanAbove = false;\r\n                            return newCell;\r\n                        } else {\r\n                            return {\r\n                                td: cloneNode(this.getTd(this.row, colIndex)),\r\n                            };\r\n                        }\r\n                    })\r\n                );\r\n                break;\r\n\r\n            case TableOperation.InsertLeft:\r\n                this.forEachCellOfCurrentColumn((cell, row) => {\r\n                    row.splice(this.col, 0, cloneCell(cell));\r\n                });\r\n                break;\r\n            case TableOperation.InsertRight:\r\n                let newCol = this.col + this.countSpanLeft(this.row, this.col);\r\n                this.forEachCellOfColumn(newCol - 1, (cell, row, i) => {\r\n                    let nextCell = this.getCell(i, newCol);\r\n                    let newCell: VCell;\r\n                    if (nextCell.spanLeft) {\r\n                        newCell = cloneCell(nextCell);\r\n                    } else if (cell.spanAbove) {\r\n                        newCell = cloneCell(cell);\r\n                        newCell.spanLeft = false;\r\n                    } else {\r\n                        newCell = {\r\n                            td: cloneNode(this.getTd(i, this.col)),\r\n                        };\r\n                    }\r\n\r\n                    row.splice(newCol, 0, newCell);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.DeleteRow:\r\n                this.forEachCellOfCurrentRow((cell, i) => {\r\n                    let nextCell = this.getCell(this.row + 1, i);\r\n                    if (cell.td && cell.td.rowSpan > 1 && nextCell.spanAbove) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                });\r\n                this.cells.splice(this.row, 1);\r\n                break;\r\n\r\n            case TableOperation.DeleteColumn:\r\n                this.forEachCellOfCurrentColumn((cell, row, i) => {\r\n                    let nextCell = this.getCell(i, this.col + 1);\r\n                    if (cell.td && cell.td.colSpan > 1 && nextCell.spanLeft) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                    row.splice(this.col, 1);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.MergeAbove:\r\n            case TableOperation.MergeBelow:\r\n                let rowStep = operation == TableOperation.MergeAbove ? -1 : 1;\r\n                for (\r\n                    let rowIndex = this.row + rowStep;\r\n                    rowIndex >= 0 && rowIndex < this.cells.length;\r\n                    rowIndex += rowStep\r\n                ) {\r\n                    let cell = this.getCell(rowIndex, this.col);\r\n                    if (cell.td && !cell.spanAbove) {\r\n                        let aboveCell = rowIndex < this.row ? cell : currentCell;\r\n                        let belowCell = rowIndex < this.row ? currentCell : cell;\r\n                        if (aboveCell.td.colSpan == belowCell.td.colSpan) {\r\n                            moveChildren(belowCell.td, aboveCell.td);\r\n                            belowCell.td = null;\r\n                            belowCell.spanAbove = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.MergeLeft:\r\n            case TableOperation.MergeRight:\r\n                let colStep = operation == TableOperation.MergeLeft ? -1 : 1;\r\n                for (\r\n                    let colIndex = this.col + colStep;\r\n                    colIndex >= 0 && colIndex < this.cells[this.row].length;\r\n                    colIndex += colStep\r\n                ) {\r\n                    let cell = this.getCell(this.row, colIndex);\r\n                    if (cell.td && !cell.spanLeft) {\r\n                        let leftCell = colIndex < this.col ? cell : currentCell;\r\n                        let rightCell = colIndex < this.col ? currentCell : cell;\r\n                        if (leftCell.td.rowSpan == rightCell.td.rowSpan) {\r\n                            moveChildren(rightCell.td, leftCell.td);\r\n                            rightCell.td = null;\r\n                            rightCell.spanLeft = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.DeleteTable:\r\n                this.cells = null;\r\n                break;\r\n\r\n            case TableOperation.SplitVertically:\r\n                if (currentCell.td.rowSpan > 1) {\r\n                    this.getCell(this.row + 1, this.col).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    let splitRow = currentRow.map(cell => {\r\n                        return {\r\n                            td: cell == currentCell ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell != currentCell,\r\n                            spanLeft: cell.spanLeft,\r\n                        };\r\n                    });\r\n                    this.cells.splice(this.row + 1, 0, splitRow);\r\n                }\r\n                break;\r\n\r\n            case TableOperation.SplitHorizontally:\r\n                if (currentCell.td.colSpan > 1) {\r\n                    this.getCell(this.row, this.col + 1).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    this.forEachCellOfCurrentColumn((cell, row) => {\r\n                        row.splice(this.col + 1, 0, {\r\n                            td: row == currentRow ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell.spanAbove,\r\n                            spanLeft: row != currentRow,\r\n                        });\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current column and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => any) {\r\n        this.forEachCellOfColumn(this.col, callback);\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current row and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => any) {\r\n        this.forEachCellOfRow(this.row, callback);\r\n    }\r\n\r\n    /**\r\n     * Get a table cell using its row and column index. This function will always return an object\r\n     * even if the given indexes don't exist in table.\r\n     * @param row The row index\r\n     * @param col The column index\r\n     */\r\n    getCell(row: number, col: number): VCell {\r\n        return (this.cells && this.cells[row] && this.cells[row][col]) || {};\r\n    }\r\n\r\n    /**\r\n     * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell\r\n     */\r\n    getCurrentTd(): HTMLTableCellElement {\r\n        return this.getTd(this.row, this.col);\r\n    }\r\n\r\n    private getTd(row: number, col: number) {\r\n        if (this.cells) {\r\n            row = Math.min(this.cells.length - 1, row);\r\n            col = Math.min(this.cells[row].length - 1, col);\r\n            while (row >= 0 && col >= 0) {\r\n                let cell = this.getCell(row, col);\r\n                if (cell.td) {\r\n                    return cell.td;\r\n                } else if (cell.spanLeft) {\r\n                    col--;\r\n                } else if (cell.spanAbove) {\r\n                    row--;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private forEachCellOfColumn(\r\n        col: number,\r\n        callback: (cell: VCell, row: VCell[], i: number) => any\r\n    ) {\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            callback(this.getCell(i, col), this.cells[i], i);\r\n        }\r\n    }\r\n\r\n    private forEachCellOfRow(row: number, callback: (cell: VCell, i: number) => any) {\r\n        for (let i = 0; i < this.cells[row].length; i++) {\r\n            callback(this.getCell(row, i), i);\r\n        }\r\n    }\r\n\r\n    private recalcSpans(row: number, col: number) {\r\n        let td = this.getCell(row, col).td;\r\n        if (td) {\r\n            td.colSpan = this.countSpanLeft(row, col);\r\n            td.rowSpan = this.countSpanAbove(row, col);\r\n            if (td.colSpan == 1) {\r\n                td.removeAttribute('colSpan');\r\n            }\r\n            if (td.rowSpan == 1) {\r\n                td.removeAttribute('rowSpan');\r\n            }\r\n        }\r\n    }\r\n\r\n    private countSpanLeft(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = col + 1; i < this.cells[row].length; i++) {\r\n            let cell = this.getCell(row, i);\r\n            if (cell.td || !cell.spanLeft) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private countSpanAbove(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = row + 1; i < this.cells.length; i++) {\r\n            let cell = this.getCell(i, col);\r\n            if (cell.td || !cell.spanAbove) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nfunction getTableFromTd(td: HTMLTableCellElement) {\r\n    let result = <HTMLElement>td;\r\n    for (; result && result.tagName != 'TABLE'; result = result.parentElement) {}\r\n    return <HTMLTableElement>result;\r\n}\r\n\r\nfunction getBorderStyle(style: string): string {\r\n    return 'solid 1px ' + (style || 'transparent');\r\n}\r\n\r\n/**\r\n * Clone a table cell\r\n * @param cell The cell to clone\r\n */\r\nfunction cloneCell(cell: VCell): VCell {\r\n    return {\r\n        td: cloneNode(cell.td),\r\n        spanAbove: cell.spanAbove,\r\n        spanLeft: cell.spanLeft,\r\n    };\r\n}\r\n\r\n/**\r\n * Clone a node without its children.\r\n * @param node The node to clone\r\n */\r\nfunction cloneNode<T extends Node>(node: T): T {\r\n    let newNode = node ? <T>node.cloneNode(false /*deep*/) : null;\r\n    if (newNode && newNode instanceof HTMLTableCellElement) {\r\n        newNode.removeAttribute('id');\r\n        if (!newNode.firstChild) {\r\n            newNode.appendChild(node.ownerDocument.createElement('br'));\r\n        }\r\n    }\r\n    return newNode;\r\n}\r\n\r\n/**\r\n * Move all children from one node to another\r\n * @param fromNode The source node to move children from\r\n * @param toNode Target node. If not passed, children nodes of source node will be removed\r\n */\r\nfunction moveChildren(fromNode: Node, toNode?: Node) {\r\n    while (fromNode.firstChild) {\r\n        if (toNode) {\r\n            toNode.appendChild(fromNode.firstChild);\r\n        } else {\r\n            fromNode.removeChild(fromNode.firstChild);\r\n        }\r\n    }\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Clear all snapshots after the current one\r\n * @param snapshots The snapshots data structure to clear\r\n */\r\nexport default function clearProceedingSnapshots(snapshots: Snapshots) {\r\n    if (canMoveCurrentSnapshot(snapshots, 1)) {\r\n        let removedSize = 0;\r\n        for (let i = snapshots.currentIndex + 1; i < snapshots.snapshots.length; i++) {\r\n            removedSize += snapshots.snapshots[i].length;\r\n        }\r\n        snapshots.snapshots.splice(snapshots.currentIndex + 1);\r\n        snapshots.totalSize -= removedSize;\r\n    }\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Feature set for ContentEdit plugin.\r\n * Call getDefaultContentEditFeatures() to get default feature set.\r\n */\r\nexport default interface ContentEditFeatures {\r\n    /**\r\n     * When press Tab in a list, indent current list item\r\n     * @default true\r\n     */\r\n    indentWhenTab: boolean;\r\n\r\n    /**\r\n     * When press Shift+Tab in a list, outdent current list item\r\n     * @default true\r\n     */\r\n    outdentWhenShiftTab: boolean;\r\n\r\n    /**\r\n     * When press BaskSpace on empty line which is the first item of a list, outdent current list item\r\n     * @default true\r\n     */\r\n    outdentWhenBackspaceOnEmptyFirstLine: boolean;\r\n\r\n    /**\r\n     * When press Enter on empty line in a list, outdent current list item\r\n     * @default true for IE, false for other browsers since they have already had the behavior\r\n     */\r\n    outdentWhenEnterOnEmptyLine: boolean;\r\n\r\n    /**\r\n     * When press Backspace on first char in a list, make current item a new line of previous list item\r\n     * @default false\r\n     */\r\n    mergeInNewLineWhenBackspaceOnFirstChar: boolean;\r\n\r\n    /**\r\n     * When press BAckspace on empty line which is the first line of a blockquote, unquote current line\r\n     * @default true\r\n     */\r\n    unquoteWhenBackspaceOnEmptyFirstLine: boolean;\r\n\r\n    /**\r\n     * When press Enter on empty line in a blockquote, unquote current line\r\n     * @default true\r\n     */\r\n    unquoteWhenEnterOnEmptyLine: boolean;\r\n\r\n    /**\r\n     * When press space after an asterik or number in an empty line, toggle bullet/numbering\r\n     * @default true\r\n     */\r\n    autoBullet: boolean;\r\n\r\n    /**\r\n     * When press TAB or SHIFT+TAB key in table cell, jump to next/previous table cell\r\n     * @default true\r\n     */\r\n    tabInTable: boolean;\r\n\r\n    /**\r\n     * When press Up or Down in table cell, jump to the table cell above/below\r\n     * @default true for Chrome and safari, false for other browsers since they arleady have correct behavior\r\n     */\r\n    upDownInTable: boolean;\r\n\r\n    /**\r\n     * When press Enter at the beginning of first structured element (table, list) and there isn't line before the position\r\n     * we create a new line before so that user got a chance to enter content before the table or list\r\n     * @default false\r\n     */\r\n    insertLineBeforeStructuredNodeFeature: boolean;\r\n\r\n    /**\r\n     * When press Space or Enter after a hyperlink-like string, convert the string to a hyperlink\r\n     * @default true\r\n     */\r\n    autoLink: boolean;\r\n\r\n    /**\r\n     * Respond to default common keyboard short, i.e. Ctrl+B, Ctrl+I, Ctrl+U, Ctrl+Z, Ctrl+Y\r\n     * @default true\r\n     */\r\n    defaultShortcut: boolean;\r\n\r\n    /**\r\n     * Unlink when backspace right after a hyperlink\r\n     * @default false\r\n     */\r\n    unlinkWhenBackspaceAfterLink: boolean;\r\n\r\n    /**\r\n     * When generate ordered list, the list bullet will variare according its nesting level, in a loop of '1', 'a', 'i'\r\n     * @default false\r\n     */\r\n    smartOrderedList: boolean;\r\n\r\n    /**\r\n     * A style list for smart ordered list. This value is only effective when smartOrderedList is true\r\n     * @default ['lower-alpha', 'lower-roman', 'decimal']\r\n     */\r\n    smartOrderedListStyles: string[];\r\n}\r\n\r\n/**\r\n * Get default feature set of ContentEdit plugin\r\n */\r\nexport function getDefaultContentEditFeatures(): ContentEditFeatures {\r\n    return {\r\n        autoLink: true,\r\n        indentWhenTab: true,\r\n        outdentWhenShiftTab: true,\r\n        outdentWhenBackspaceOnEmptyFirstLine: true,\r\n        outdentWhenEnterOnEmptyLine: Browser.isIE,\r\n        mergeInNewLineWhenBackspaceOnFirstChar: false,\r\n        unquoteWhenBackspaceOnEmptyFirstLine: true,\r\n        unquoteWhenEnterOnEmptyLine: true,\r\n        autoBullet: true,\r\n        tabInTable: true,\r\n        upDownInTable: Browser.isChrome || Browser.isSafari,\r\n        insertLineBeforeStructuredNodeFeature: false,\r\n        defaultShortcut: true,\r\n        unlinkWhenBackspaceAfterLink: false,\r\n        smartOrderedList: false,\r\n        smartOrderedListStyles: ['lower-alpha', 'lower-roman', 'decimal'],\r\n    };\r\n}\r\n","import { BlockElement, NodeType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getTagOfNode, StartEndBlockElement } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Collapse all selected blocks, return single HTML elements for each block\r\n * @param editor The editor instance\r\n * @param forEachCallback A callback function to invoke for each of the collapsed element\r\n */\r\nexport default function collapseSelectedBlocked(\r\n    editor: Editor,\r\n    forEachCallback: (element: HTMLElement) => any\r\n) {\r\n    let traverser = editor.getSelectionTraverser();\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let blocks: BlockElement[] = [];\r\n    while (block) {\r\n        if (!isEmptyBlockUnderTR(block)) {\r\n            blocks.push(block);\r\n        }\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    blocks.forEach(block => {\r\n        let element = block.collapseToSingleElement();\r\n        forEachCallback(element);\r\n    });\r\n}\r\n\r\nfunction isEmptyBlockUnderTR(block: BlockElement): boolean {\r\n    let startNode = block.getStartNode();\r\n\r\n    return (\r\n        block instanceof StartEndBlockElement &&\r\n        startNode == block.getEndNode() &&\r\n        startNode.nodeType == NodeType.Text &&\r\n        ['TR', 'TABLE'].indexOf(getTagOfNode(startNode.parentNode)) >= 0\r\n    );\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set background color at current selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n **/\r\nexport default function setBackgroundColor(editor: Editor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset.ogsb = color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set font name at selection\r\n * @param editor The editor instance\r\n * @param fontName The fontName string, should be a valid CSS font-family style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontName(editor: Editor, fontName: string) {\r\n    fontName = fontName.trim();\r\n    // The browser provided execCommand creates a HTML <font> tag with face attribute. <font> is not HTML5 standard\r\n    // (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-family style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontFamily = isInnerNode ? '' : fontName;\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Set font size at selection\r\n * @param editor The editor instance\r\n * @param fontSize The fontSize string, should be a valid CSS font-size style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontSize(editor: Editor, fontSize: string) {\r\n    fontSize = fontSize.trim();\r\n    // The browser provided execCommand only accepts 1-7 point value. In addition, it uses HTML <font> tag with size attribute.\r\n    // <font> is not HTML5 standard (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-size style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontSize = isInnerNode ? '' : fontSize;\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set text color at selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n */\r\nexport default function setTextColor(editor: Editor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset.ogsc = color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle bold at selection\r\n * If selection is collapsed, it will only affect the following input after caret\r\n * If selection contains only bold text, the bold style will be removed\r\n * If selection contains only normal text, bold style will be added to the whole selected text\r\n * If selection contains both bold and normal text, bold stle will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBold(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Bold);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle italic at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only italic text, the italic style will be removed\r\n * If selection contains only normal text, italic style will be added to the whole selected text\r\n * If selection contains both italic and normal text, italic stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleItalic(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Italic);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle underline at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only underlined text, the underline style will be removed\r\n * If selection contains only normal text, underline style will be added to the whole selected text\r\n * If selection contains both underlined and normal text, the underline style will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleUnderline(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Underline);\r\n}\r\n","import getColorNormalizedContent from '../darkMode/getColorNormalizedContent';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Copy plugin, hijacks copy events to normalize the content to the clipboard.\r\n */\r\nexport default class CopyPlugin implements EditorPlugin {\r\n    private editor: Editor;\r\n    private copyDisposer: () => void;\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Copy';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    public initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.copyDisposer = editor.addDomEventHandler('copy', this.onCopy);\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose() {\r\n        this.copyDisposer();\r\n        this.copyDisposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    private onCopy = (event: Event) => {\r\n        // if it's dark mode...\r\n        if (this.editor && this.editor.isDarkMode()) {\r\n            // get whatever the current selection range is\r\n            const selectionRange = this.editor.getSelectionRange();\r\n            if (selectionRange && !selectionRange.collapsed) {\r\n                const clipboardEvent = (event as ClipboardEvent);\r\n                const copyFragment = this.editor.getSelectionRange().cloneContents();\r\n\r\n                // revert just this selected range to light mode colors\r\n                const normalizedContent = getColorNormalizedContent(copyFragment);\r\n                const containerDiv = this.editor.getDocument().createElement('div');\r\n\r\n                // Leverage script execution policy on CEDs to try and prevent XSS\r\n                containerDiv.setAttribute('contenteditable', 'true');\r\n                containerDiv.innerHTML = normalizedContent;\r\n\r\n                // put it on the clipboard\r\n                clipboardEvent.clipboardData.setData('text/html', normalizedContent);\r\n                clipboardEvent.clipboardData.setData('text/plain', containerDiv.innerText)\r\n\r\n                event.preventDefault();\r\n            }\r\n        }\r\n    }\r\n}\r\n","export default function getColorNormalizedContent(content: string | DocumentFragment): string {\r\n    let el = document.createElement('div');\r\n    // Leverage script execution policy on CEDs to try and prevent XSS\r\n    el.setAttribute('contenteditable', 'true');\r\n    if (content instanceof DocumentFragment) {\r\n        el.appendChild(content);\r\n    } else {\r\n        el.innerHTML = content;\r\n    }\r\n    const allChildElements = el.getElementsByTagName('*') as HTMLCollectionOf<HTMLElement>;\r\n    [].forEach.call(allChildElements, (element: HTMLElement) => {\r\n        if (element.dataset) {\r\n            // Reset color styles based on the content of the ogsc/ogsb data element.\r\n            // If those data properties are empty or do not exist, set them anyway to clear the content.\r\n            element.style.color = isDataAttributeSettable(element.dataset.ogsc)\r\n                ? element.dataset.ogsc\r\n                : '';\r\n            element.style.backgroundColor = isDataAttributeSettable(element.dataset.ogsb)\r\n                ? element.dataset.ogsb\r\n                : '';\r\n\r\n            // Some elements might have set attribute colors. We need to reset these as well.\r\n            if (isDataAttributeSettable(element.dataset.ogac)) {\r\n                element.setAttribute('color', element.dataset.ogac);\r\n            } else {\r\n                element.removeAttribute('color');\r\n            }\r\n\r\n            if (isDataAttributeSettable(element.dataset.ogab)) {\r\n                element.setAttribute('bgcolor', element.dataset.ogab);\r\n            } else {\r\n                element.removeAttribute('bgcolor');\r\n            }\r\n\r\n            // Clean up any remaining data attributes.\r\n            if (element.dataset.ogsc) {\r\n                delete element.dataset.ogsc;\r\n            }\r\n\r\n            if (element.dataset.ogsb) {\r\n                delete element.dataset.ogsb;\r\n            }\r\n\r\n            if (element.dataset.ogac) {\r\n                delete element.dataset.ogac;\r\n            }\r\n\r\n            if (element.dataset.ogab) {\r\n                delete element.dataset.ogab;\r\n            }\r\n        }\r\n    });\r\n    const newContent = el.innerHTML;\r\n    return newContent;\r\n}\r\n\r\nfunction isDataAttributeSettable(newStyle: string) {\r\n    return newStyle && newStyle != 'undefined' && newStyle != 'null';\r\n}","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport {\r\n    Browser,\r\n    getPendableFormatState,\r\n    Position,\r\n    PendableFormatNames,\r\n    PendableFormatCommandMap,\r\n} from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    PluginEventType,\r\n    NodePosition,\r\n    PendableFormatState,\r\n    PluginEvent,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * DOMEventPlugin handles customized DOM events, including:\r\n * 1. IME state management\r\n * 2. Selection management\r\n * 3. Cut and Drop management\r\n * 4. Pending format state management\r\n * 5. Scroll container and scroll event management\r\n */\r\nexport default class DOMEventPlugin implements EditorPlugin {\r\n    private editor: Editor;\r\n    private inIme = false;\r\n    private disposer: () => void;\r\n    private cachedPosition: NodePosition;\r\n    private cachedFormatState: PendableFormatState;\r\n\r\n    constructor(private disableRestoreSelectionOnFocus: boolean) {}\r\n\r\n    getName() {\r\n        return 'DOMEvent';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n\r\n        this.disposer = editor.addDomEventHandler({\r\n            // 1. IME state management\r\n            compositionstart: () => (this.inIme = true),\r\n            compositionend: (rawEvent: CompositionEvent) => {\r\n                this.inIme = false;\r\n                editor.triggerPluginEvent(PluginEventType.CompositionEnd, {\r\n                    rawEvent,\r\n                });\r\n            },\r\n\r\n            // 2. Cut and drop management\r\n            drop: this.onNativeEvent,\r\n            cut: this.onNativeEvent,\r\n\r\n            // 3. Selection mangement\r\n            focus: this.onFocus,\r\n            [Browser.isIEOrEdge ? 'beforedeactivate' : 'blur']: this.onBlur,\r\n        });\r\n\r\n        this.editor.getScrollContainer().addEventListener('scroll', this.onScroll);\r\n    }\r\n\r\n    dispose() {\r\n        this.editor.getScrollContainer().removeEventListener('scroll', this.onScroll);\r\n\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.editor = null;\r\n        this.clear();\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        switch (event.eventType) {\r\n            case PluginEventType.PendingFormatStateChanged:\r\n                // Got PendingFormatStateChagned event, cache current position and pending format\r\n                this.cachedPosition = this.getCurrentPosition();\r\n                this.cachedFormatState = event.formatState;\r\n                break;\r\n            case PluginEventType.KeyDown:\r\n            case PluginEventType.MouseDown:\r\n            case PluginEventType.ContentChanged:\r\n                // If content or position is changed (by keyboard, mouse, or code),\r\n                // check if current position is still the same with the cached one (if exist),\r\n                // and clear cached format if position is changed since it is out-of-date now\r\n                if (\r\n                    this.cachedPosition &&\r\n                    !this.cachedPosition.equalTo(this.getCurrentPosition())\r\n                ) {\r\n                    this.clear();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restore cached pending format state (if exist) to current selection\r\n     */\r\n    public restorePendingFormatState() {\r\n        if (this.cachedFormatState) {\r\n            let formatState = getPendableFormatState(this.editor.getDocument());\r\n            (<PendableFormatNames[]>Object.keys(PendableFormatCommandMap)).forEach(key => {\r\n                if (this.cachedFormatState[key] != formatState[key]) {\r\n                    this.editor\r\n                        .getDocument()\r\n                        .execCommand(PendableFormatCommandMap[key], false, null);\r\n                }\r\n            });\r\n            this.cachedPosition = this.getCurrentPosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in IME input sequence\r\n     * @returns True if editor is in IME input sequence, otherwise false\r\n     */\r\n    public isInIME() {\r\n        return this.inIme;\r\n    }\r\n\r\n    private onNativeEvent = (e: UIEvent) => {\r\n        this.editor.runAsync(() => {\r\n            this.editor.addUndoSnapshot(\r\n                () => {},\r\n                e.type == 'cut' ? ChangeSource.Cut : ChangeSource.Drop\r\n            );\r\n        });\r\n    };\r\n\r\n    private onFocus = () => {\r\n        if (this.disableRestoreSelectionOnFocus) {\r\n            if (this.cachedPosition && this.cachedFormatState) {\r\n                let range = this.editor.getSelectionRange();\r\n                if (\r\n                    range.collapsed &&\r\n                    Position.getStart(range)\r\n                        .normalize()\r\n                        .equalTo(this.cachedPosition)\r\n                ) {\r\n                    this.restorePendingFormatState();\r\n                } else {\r\n                    this.clear();\r\n                }\r\n            }\r\n        } else {\r\n            this.editor.restoreSavedRange();\r\n        }\r\n    };\r\n\r\n    private onBlur = () => {\r\n        this.editor.saveSelectionRange();\r\n    };\r\n\r\n    private onScroll = (e: UIEvent) => {\r\n        this.editor.triggerPluginEvent(PluginEventType.Scroll, {\r\n            rawEvent: e,\r\n            scrollContainer: this.editor.getScrollContainer(),\r\n        });\r\n    };\r\n\r\n    private clear() {\r\n        this.cachedPosition = null;\r\n        this.cachedFormatState = null;\r\n    }\r\n\r\n    private getCurrentPosition() {\r\n        let range = this.editor.getSelectionRange();\r\n        return range && Position.getStart(range).normalize();\r\n    }\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport { GenericContentEditFeature, Keys } from '../interfaces/ContentEditFeature';\r\nimport {\r\n    ChangeSource,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginKeyboardEvent,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Edit Component helps handle Content edit features\r\n */\r\nexport default class EditPlugin implements EditorPlugin {\r\n    private editor: Editor;\r\n    private featureMap: { [key: number]: GenericContentEditFeature<PluginEvent>[] } = {};\r\n\r\n    private autoCompleteSnapshot: string = null;\r\n    private autoCompleteChangeSource: string = null;\r\n\r\n    getName() {\r\n        return 'Edit';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.addFeature({\r\n            keys: [Keys.BACKSPACE],\r\n            shouldHandleEvent: () => this.autoCompleteSnapshot !== null,\r\n            handleEvent: (event: PluginKeyboardEvent, editor: Editor) => {\r\n                event.rawEvent.preventDefault();\r\n                editor.setContent(this.autoCompleteSnapshot, false /*triggerContentChangedEvent*/);\r\n            },\r\n        });\r\n    }\r\n\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        let contentChanged = false;\r\n        let currentFeature = this.findFeature(event);\r\n\r\n        switch (event.eventType) {\r\n            case PluginEventType.ContentChanged:\r\n                contentChanged = this.autoCompleteChangeSource != event.source;\r\n                break;\r\n            case PluginEventType.MouseDown:\r\n            case PluginEventType.KeyDown:\r\n                contentChanged = true;\r\n                break;\r\n        }\r\n\r\n        if (currentFeature) {\r\n            currentFeature.handleEvent(event, this.editor);\r\n        }\r\n\r\n        if (contentChanged) {\r\n            this.autoCompleteSnapshot = null;\r\n            this.autoCompleteChangeSource = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a Content Edit feature\r\n     * @param feature The feature to add\r\n     */\r\n    addFeature(feature: GenericContentEditFeature<PluginEvent>) {\r\n        feature.keys.forEach(key => {\r\n            let array = this.featureMap[key] || [];\r\n            array.push(feature);\r\n            this.featureMap[key] = array;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Perform an auto complete action in the callback, save a snapsnot of content before the action,\r\n     * and trigger ContentChangedEvent with the change source if specified\r\n     * @param callback The auto complete callback, return value will be used as data field of ContentChangedEvent\r\n     * @param changeSource Chagne source of ContentChangedEvent. If not passed, no ContentChangedEvent will be  triggered\r\n     */\r\n    performAutoComplete(callback: () => any, changeSource?: ChangeSource | string) {\r\n        this.editor.addUndoSnapshot((start, end, snapshot) => {\r\n            let data = callback();\r\n            this.autoCompleteSnapshot = snapshot;\r\n            this.autoCompleteChangeSource = changeSource;\r\n            return data;\r\n        }, changeSource);\r\n    }\r\n\r\n    private findFeature(event: PluginEvent) {\r\n        let hasFunctionKey = false;\r\n        let features: GenericContentEditFeature<PluginEvent>[];\r\n\r\n        if (event.eventType == PluginEventType.KeyDown) {\r\n            let rawEvent = event.rawEvent;\r\n            hasFunctionKey = rawEvent.ctrlKey || rawEvent.altKey || rawEvent.metaKey;\r\n            features = this.featureMap[rawEvent.which];\r\n        } else if (event.eventType == PluginEventType.ContentChanged) {\r\n            features = this.featureMap[Keys.CONTENTCHANGED];\r\n        }\r\n        return (\r\n            features &&\r\n            features.filter(\r\n                feature =>\r\n                    (feature.allowFunctionKeys || !hasFunctionKey) &&\r\n                    feature.shouldHandleEvent(event, this.editor)\r\n            )[0]\r\n        );\r\n    }\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport { cacheGetContentSearcher } from '../eventApi/cacheGetContentSearcher';\r\nimport { LinkInlineElement, Position } from 'roosterjs-editor-dom';\r\nimport { PluginEvent, PluginEventType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * FirefoxTypeAfterLink Component helps handle typing event when cursor is right after a link.\r\n * When typing after a link, Firefox will always put the new charactor inside link.\r\n * This plugin overrides this behavior to make it consistent with other browsers.\r\n */\r\nexport default class FirefoxTypeAfterLink implements EditorPlugin {\r\n    private editor: Editor;\r\n\r\n    getName() {\r\n        return 'FirefoxTypeAfterLink';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.KeyPress) {\r\n            let range = this.editor.getSelectionRange();\r\n            if (range && range.collapsed && this.editor.getElementAtCursor('A[href]')) {\r\n                let searcher = cacheGetContentSearcher(event, this.editor);\r\n                let inlineElement = searcher.getInlineElementBefore();\r\n                if (inlineElement instanceof LinkInlineElement) {\r\n                    this.editor.select(\r\n                        new Position(inlineElement.getContainerNode(), PositionType.After)\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","import cacheGetEventData from './cacheGetEventData';\r\nimport clearEventDataCache from './clearEventDataCache';\r\nimport Editor from '../editor/Editor';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\nimport { PositionContentSearcher } from 'roosterjs-editor-dom';\r\n\r\nconst CONTENTSEARCHER_KEY = 'CONTENTSEARCHER';\r\n\r\n/**\r\n * Try get existing PositionContentSearcher from an event. If there isn't one, create a new one from editor.\r\n * @param event The plugin event, it stores the event cached data for looking up.\r\n * If passed as null, we will create a new PositionContentSearcher\r\n * @param editor The editor instance\r\n * @returns The PositionContentSearcher object\r\n */\r\nexport function cacheGetContentSearcher(\r\n    event: PluginEvent,\r\n    editor: Editor\r\n): PositionContentSearcher {\r\n    return cacheGetEventData(event, CONTENTSEARCHER_KEY, () => editor.getContentSearcherOfCursor());\r\n}\r\n\r\n/**\r\n * Clear the PositionContentSearcher in a plugin event.\r\n * This is called when the content is changed\r\n * @param event The plugin event\r\n */\r\nexport function clearContentSearcherCache(event: PluginEvent) {\r\n    clearEventDataCache(event, CONTENTSEARCHER_KEY);\r\n}\r\n","import { PluginEvent } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Clear a cached object by its key from an event object\r\n * @param event The event object\r\n * @param key The cache key\r\n */\r\nexport default function clearEventDataCache(event: PluginEvent, key: string): void {\r\n    if (event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)) {\r\n        delete event.eventDataCache[key];\r\n    }\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport { PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * MouseUp Component helps handle mouse up event\r\n * this can trigger mouse up event after mousedown happens in editor\r\n * even mouse up is happening outside editor\r\n */\r\nexport default class MouseUpPlugin implements EditorPlugin {\r\n    private mouseUpEventListerAdded: boolean;\r\n    private editor: Editor;\r\n\r\n    getName() {\r\n        return 'MouseUp';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    dispose() {\r\n        this.removeMouseUpEventListener();\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.MouseDown && !this.mouseUpEventListerAdded) {\r\n            this.editor\r\n                .getDocument()\r\n                .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);\r\n            this.mouseUpEventListerAdded = true;\r\n        }\r\n    }\r\n\r\n    private removeMouseUpEventListener() {\r\n        if (this.mouseUpEventListerAdded) {\r\n            this.mouseUpEventListerAdded = false;\r\n            this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);\r\n        }\r\n    }\r\n\r\n    private onMouseUp = (rawEvent: MouseEvent) => {\r\n        if (this.editor) {\r\n            this.removeMouseUpEventListener();\r\n            this.editor.triggerPluginEvent(PluginEventType.MouseUp, {\r\n                rawEvent,\r\n            });\r\n        }\r\n    };\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport {\r\n    applyFormat,\r\n    Browser,\r\n    findClosestElementAncestor,\r\n    fromHtml,\r\n    isNodeEmpty,\r\n    Position,\r\n} from 'roosterjs-editor-dom';\r\nimport {\r\n    ContentPosition,\r\n    NodePosition,\r\n    PluginKeyboardEvent,\r\n    PositionType,\r\n    PluginEvent,\r\n    PluginEventType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Typing Component helps to ensure typing is always happening under a DOM container\r\n */\r\nexport default class TypeInContainerPlugin implements EditorPlugin {\r\n    private editor: Editor;\r\n\r\n    getName() {\r\n        return 'TypeInContainer';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.KeyPress) {\r\n            this.onKeyPress(event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ensure we are typing in an HTML Element inside editor, and apply default format if current block is empty\r\n     * @param node Current node\r\n     * @param event (optional) The keyboard event that we are ensuring is typing in an element.\r\n     * @returns A new position to select\r\n     */\r\n    ensureTypeInElement(position: NodePosition, event?: PluginKeyboardEvent): NodePosition {\r\n        let result = position.normalize();\r\n        let block = this.editor.getBlockElementAtNode(result.node);\r\n        let formatNode: HTMLElement;\r\n\r\n        if (block) {\r\n            formatNode = block.collapseToSingleElement();\r\n\r\n            // if the block is empty, apply default format\r\n            // Otherwise, leave it as it is as we don't want to change the style for existing data\r\n            // unless the block was just created by the keyboard event (e.g. ctrl+a & start typing)\r\n            const shouldSetNodeStyles =\r\n                isNodeEmpty(formatNode) ||\r\n                (event && this.wasNodeJustCreatedByKeyboardEvent(event, formatNode));\r\n            formatNode = formatNode && shouldSetNodeStyles ? formatNode : null;\r\n        } else {\r\n            // Only reason we don't get the selection block is that we have an empty content div\r\n            // which can happen when users removes everything (i.e. select all and DEL, or backspace from very end to begin)\r\n            // The fix is to add a DIV wrapping, apply default format and move cursor over\r\n            formatNode = fromHtml(\r\n                Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>',\r\n                this.editor.getDocument()\r\n            )[0] as HTMLElement;\r\n            this.editor.insertNode(formatNode, {\r\n                position: ContentPosition.End,\r\n                updateCursor: false,\r\n                replaceSelection: false,\r\n                insertOnNewLine: false,\r\n            });\r\n\r\n            // element points to a wrapping node we added \"<div><br></div>\". We should move the selection left to <br>\r\n            result = new Position(formatNode.firstChild, PositionType.Begin);\r\n        }\r\n\r\n        if (formatNode) {\r\n            applyFormat(formatNode, this.editor.getDefaultFormat(), this.editor.isDarkMode());\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private onKeyPress(event: PluginKeyboardEvent) {\r\n        // If normalization was not possible before the keypress,\r\n        // check again after the keyboard event has been processed by browser native behaviour.\r\n        //\r\n        // This handles the case where the keyboard event that first inserts content happens when\r\n        // there is already content under the selection (e.g. Ctrl+a -> type new content).\r\n        //\r\n        // Only scheudle when the range is not collapsed to catch this edge case.\r\n        let range = this.editor.getSelectionRange();\r\n\r\n        if (!range || this.editor.contains(findClosestElementAncestor(range.startContainer))) {\r\n            return;\r\n        }\r\n\r\n        if (range.collapsed) {\r\n            this.tryNormalizeTyping(event, range);\r\n        } else if (!range.collapsed) {\r\n            this.editor.runAsync(() => {\r\n                this.tryNormalizeTyping(event);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * When typing goes directly under content div, many things can go wrong\r\n     * We fix it by wrapping it with a div and reposition cursor within the div\r\n     */\r\n    private tryNormalizeTyping(event: PluginKeyboardEvent, range?: Range) {\r\n        let position = this.ensureTypeInElement(\r\n            Position.getStart(range || this.editor.getSelectionRange()),\r\n            event\r\n        );\r\n        this.editor.select(position);\r\n    }\r\n\r\n    private wasNodeJustCreatedByKeyboardEvent(event: PluginKeyboardEvent, formatNode: HTMLElement) {\r\n        return (\r\n            event.rawEvent.target instanceof Node &&\r\n            event.rawEvent.target.contains(formatNode) &&\r\n            event.rawEvent.key === formatNode.innerText\r\n        );\r\n    }\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport UndoService from '../interfaces/UndoService';\r\nimport UndoSnapshots from './UndoSnapshots';\r\nimport UndoSnapshotsService from '../interfaces/UndoSnapshotsService';\r\nimport { PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\nconst KEY_BACKSPACE = 8;\r\nconst KEY_DELETE = 46;\r\nconst KEY_SPACE = 32;\r\nconst KEY_ENTER = 13;\r\nconst KEY_PAGEUP = 33;\r\nconst KEY_DOWN = 40;\r\n\r\n/**\r\n * Provides snapshot based undo service for Editor\r\n */\r\nexport default class Undo implements UndoService {\r\n    private editor: Editor;\r\n    private isRestoring: boolean;\r\n    private hasNewContent: boolean;\r\n    private lastKeyPress: number;\r\n\r\n    protected undoSnapshots: UndoSnapshotsService;\r\n\r\n    /**\r\n     * Create an instance of Undo\r\n     * @param preserveSnapshots True to preserve the snapshots after dispose, this allows\r\n     * this object to be reused when editor is disposed and created again\r\n     * @param maxBufferSize The max buffer size for snapshots. Default value is 10MB\r\n     */\r\n    constructor(private preserveSnapshots?: boolean, private maxBufferSize: number = 1e7) { }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Undo';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    public initialize(editor: Editor): void {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose() {\r\n        this.editor = null;\r\n\r\n        if (!this.preserveSnapshots) {\r\n            this.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    public onPluginEvent(event: PluginEvent): void {\r\n        // if editor is in IME, don't do anything\r\n        if (this.editor.isInIME()) {\r\n            return;\r\n        }\r\n\r\n        switch (event.eventType) {\r\n            case PluginEventType.EditorReady:\r\n                if (!this.preserveSnapshots || (!this.canUndo() && !this.canRedo())) {\r\n                    // Only add initial snapshot when we don't need to preserve snapshots or there is no existing snapshot\r\n                    // Otherwise preserved undo/redo state may be ruined\r\n                    this.addUndoSnapshot();\r\n                }\r\n                break;\r\n            case PluginEventType.KeyDown:\r\n                this.onKeyDown(event.rawEvent);\r\n                break;\r\n            case PluginEventType.KeyPress:\r\n                this.onKeyPress(event.rawEvent);\r\n                break;\r\n            case PluginEventType.CompositionEnd:\r\n                this.clearRedoForInput();\r\n                this.addUndoSnapshot();\r\n                break;\r\n            case PluginEventType.ContentChanged:\r\n                if (!this.isRestoring) {\r\n                    this.clearRedoForInput();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all existing undo snapshots\r\n     */\r\n    public clear() {\r\n        this.undoSnapshots = null;\r\n        this.hasNewContent = false;\r\n    }\r\n\r\n    /**\r\n     * Restore an undo snapshot to editor\r\n     */\r\n    public undo(): void {\r\n        if (this.hasNewContent) {\r\n            this.addUndoSnapshot();\r\n        }\r\n\r\n        this.restoreSnapshot(-1 /*previousSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Restore a redo snapshot to editor\r\n     */\r\n    public redo(): void {\r\n        this.restoreSnapshot(1 /*nextSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Whether there is a snapshot for undo\r\n     */\r\n    public canUndo(): boolean {\r\n        return this.hasNewContent || this.getSnapshotsManager().canMove(-1 /*previousSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Whether there is a snapshot for redo\r\n     */\r\n    public canRedo(): boolean {\r\n        return this.getSnapshotsManager().canMove(1 /*nextSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Add an undo snapshot\r\n     */\r\n    public addUndoSnapshot(): string {\r\n        let snapshot = this.editor.getContent(\r\n            false /*triggerExtractContentEvent*/,\r\n            true /* includeSelectionMarker */\r\n        );\r\n        this.getSnapshotsManager().addSnapshot(snapshot);\r\n        this.hasNewContent = false;\r\n        return snapshot;\r\n    }\r\n\r\n    protected getSnapshotsManager(): UndoSnapshotsService {\r\n        if (!this.undoSnapshots) {\r\n            this.undoSnapshots = new UndoSnapshots(this.maxBufferSize);\r\n        }\r\n        return this.undoSnapshots;\r\n    }\r\n\r\n    private restoreSnapshot(delta: number) {\r\n        let snapshot = this.getSnapshotsManager().move(delta);\r\n\r\n        if (snapshot != null) {\r\n            try {\r\n                this.isRestoring = true;\r\n                this.editor.setContent(snapshot);\r\n            } finally {\r\n                this.isRestoring = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private onKeyDown(evt: KeyboardEvent): void {\r\n        // Handle backspace/delete when there is a selection to take a snapshot\r\n        // since we want the state prior to deletion restorable\r\n        if (evt.which == KEY_BACKSPACE || evt.which == KEY_DELETE) {\r\n            let selectionRange = this.editor.getSelectionRange();\r\n\r\n            // Add snapshot when\r\n            // 1. Something has been selected (not collapsed), or\r\n            // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or\r\n            // 3. Ctrl/Meta key is pressed so that a whole word will be deleted\r\n            if (\r\n                selectionRange &&\r\n                (!selectionRange.collapsed ||\r\n                    this.lastKeyPress != evt.which ||\r\n                    evt.ctrlKey ||\r\n                    evt.metaKey)\r\n            ) {\r\n                this.addUndoSnapshot();\r\n            }\r\n\r\n            // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time\r\n            this.hasNewContent = true;\r\n            this.lastKeyPress = evt.which;\r\n        } else if (evt.which >= KEY_PAGEUP && evt.which <= KEY_DOWN) {\r\n            // PageUp, PageDown, Home, End, Left, Right, Up, Down\r\n            if (this.hasNewContent) {\r\n                this.addUndoSnapshot();\r\n            }\r\n            this.lastKeyPress = 0;\r\n        }\r\n    }\r\n\r\n    private onKeyPress(evt: KeyboardEvent): void {\r\n        if (evt.metaKey) {\r\n            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.\r\n            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.\r\n            return;\r\n        }\r\n\r\n        let range = this.editor.getSelectionRange();\r\n        if (\r\n            (range && !range.collapsed) ||\r\n            (evt.which == KEY_SPACE && this.lastKeyPress != KEY_SPACE) ||\r\n            evt.which == KEY_ENTER\r\n        ) {\r\n            this.addUndoSnapshot();\r\n            if (evt.which == KEY_ENTER) {\r\n                // Treat ENTER as new content so if there is no input after ENTER and undo,\r\n                // we restore the snapshot before ENTER\r\n                this.hasNewContent = true;\r\n            }\r\n        } else {\r\n            this.clearRedoForInput();\r\n        }\r\n\r\n        this.lastKeyPress = evt.which;\r\n    }\r\n\r\n    private clearRedoForInput() {\r\n        this.getSnapshotsManager().clearRedo();\r\n        this.lastKeyPress = 0;\r\n        this.hasNewContent = true;\r\n    }\r\n}\r\n","import isModifierKey from './isModifierKey';\r\n\r\n/**\r\n * Returns true when the event was fired from a key that produces a character value, otherwise false\r\n * This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),\r\n * event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.\r\n * So if we missed some case here it is still acceptable.\r\n * @param event The keyboard event object\r\n */\r\nexport default function isCharacterValue(event: KeyboardEvent): boolean {\r\n    return !isModifierKey(event) && event.key && event.key.length == 1;\r\n}\r\n","const CTRL_CHARCODE = 'Control';\r\nconst ALT_CHARCODE = 'Alt';\r\nconst META_CHARCODE = 'Meta';\r\n\r\n/**\r\n * Returns true when the event was fired from a modifier key, otherwise false\r\n * @param event The keyboard event object\r\n */\r\nexport default function isModifierKey(event: KeyboardEvent): boolean {\r\n    const isCtrlKey = event.ctrlKey || event.key === CTRL_CHARCODE;\r\n    const isAltKey = event.altKey || event.key === ALT_CHARCODE;\r\n    const isMetaKey = event.metaKey || event.key === META_CHARCODE;\r\n\r\n    return isCtrlKey || isAltKey || isMetaKey;\r\n}\r\n","import { DefaultFormat } from 'roosterjs-editor-types';\r\nimport { getComputedStyles } from 'roosterjs-editor-dom';\r\n\r\nconst DARK_MODE_DEFAULT_FORMAT = {\r\n    backgroundColors: {\r\n        darkModeColor: 'rgb(51,51,51)',\r\n        lightModeColor: 'rgb(255,255,255)',\r\n    },\r\n    textColors: {\r\n        darkModeColor: 'rgb(255,255,255)',\r\n        lightModeColor: 'rgb(0,0,0)',\r\n    }\r\n}\r\n\r\nexport function calculateDefaultFormat(\r\n    node: Node,\r\n    baseFormat: DefaultFormat,\r\n    inDarkMode: boolean\r\n): DefaultFormat {\r\n    if (inDarkMode) {\r\n        if (!baseFormat.backgroundColors) {\r\n            baseFormat.backgroundColors = DARK_MODE_DEFAULT_FORMAT.backgroundColors;\r\n        }\r\n        if (!baseFormat.textColors) {\r\n            baseFormat.textColors = DARK_MODE_DEFAULT_FORMAT.textColors;\r\n        }\r\n    }\r\n\r\n    if (baseFormat && Object.keys(baseFormat).length === 0) {\r\n        return {};\r\n    }\r\n\r\n    baseFormat = baseFormat || <DefaultFormat>{};\r\n    let {\r\n        fontFamily,\r\n        fontSize,\r\n        textColor,\r\n        textColors,\r\n        backgroundColor,\r\n        backgroundColors,\r\n        bold,\r\n        italic,\r\n        underline,\r\n    } = baseFormat;\r\n    let currentStyles =\r\n        fontFamily && fontSize && (textColor || textColors) ? null : getComputedStyles(node);\r\n    return {\r\n        fontFamily: fontFamily || currentStyles[0],\r\n        fontSize: fontSize || currentStyles[1],\r\n        get textColor() {\r\n            return textColors\r\n                ? inDarkMode\r\n                    ? textColors.darkModeColor\r\n                    : textColors.lightModeColor\r\n                : textColor || currentStyles[2];\r\n        },\r\n        textColors: textColors,\r\n        get backgroundColor() {\r\n            return backgroundColors\r\n                ? inDarkMode\r\n                    ? backgroundColors.darkModeColor\r\n                    : backgroundColors.lightModeColor\r\n                : backgroundColor || '';\r\n        },\r\n        backgroundColors: backgroundColors,\r\n        bold: bold,\r\n        italic: italic,\r\n        underline: underline,\r\n    };\r\n}","import EditorCore, { HasFocus } from '../interfaces/EditorCore';\r\nimport { contains } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Check if the editor has focus now\r\n * @param core The EditorCore object\r\n * @returns True if the editor has focus, otherwise false\r\n */\r\nexport const hasFocus: HasFocus = (core: EditorCore) => {\r\n    let activeElement = core.document.activeElement;\r\n    return (\r\n        activeElement && contains(core.contentDiv, activeElement, true /*treatSameNodeAsContain*/)\r\n    );\r\n};\r\n","import { ChangeSource, PositionType, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    Browser,\r\n    Position,\r\n    wrap,\r\n    unwrap,\r\n    fromHtml,\r\n    getTagOfNode,\r\n    splitBalancedNodeRange,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst ZERO_WIDTH_SPACE = '&#8203;';\r\nconst UNWRAPPABLE_NODES = 'LI,THEAD,TBODY,TR,TD,TH'.split(',');\r\nconst DEFAULT_STYLER = (_: HTMLElement) => {};\r\n\r\n/**\r\n * Toggle a tag at selection, if selection already contains elements of such tag,\r\n * the elements will be untagge and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param tag The tag name\r\n * @param styler (Optional) The styler for setting the style for the blockquote element\r\n * @param wrapFunction (Optional) The wrap function\r\n * @param unwrapFunction (Optional) The unwrap function\r\n */\r\nexport default function toggleTagCore<T extends keyof HTMLElementTagNameMap>(\r\n    editor: Editor,\r\n    tag: T,\r\n    styler?: (element: HTMLElement) => void,\r\n    wrapFunction: (nodes: Node[]) => HTMLElement = nodes => wrap(nodes, tag),\r\n    unwrapFunction: (node: Node) => Node = unwrap\r\n): void {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        let result: HTMLElement;\r\n        let range = editor.getSelectionRange();\r\n        if (\r\n            range &&\r\n            editor.queryElements(tag, QueryScope.OnSelection, unwrapFunction).length == 0\r\n        ) {\r\n            let startNode = Position.getStart(range).normalize().node;\r\n            let startBlock = editor.getBlockElementAtNode(startNode);\r\n            let endNode = Position.getEnd(range).normalize().node;\r\n            let endBlock = editor.getBlockElementAtNode(endNode);\r\n            let nodes =\r\n                startBlock && endBlock\r\n                    ? editor.collapseNodes(\r\n                          startBlock.getStartNode(),\r\n                          endBlock.getEndNode(),\r\n                          true /*canSplitParent*/\r\n                      )\r\n                    : [];\r\n\r\n            if (nodes.length == 0) {\r\n                // Selection is collapsed and blockElement is null, we need to create an empty div.\r\n                // In case of IE and Edge, we insert ZWS to put cursor in the div, otherwise insert BR node.\r\n                nodes = fromHtml(\r\n                    `<DIV>${Browser.isIEOrEdge ? ZERO_WIDTH_SPACE : '<BR>'}</DIV>`,\r\n                    editor.getDocument()\r\n                );\r\n                editor.insertNode(nodes[0]);\r\n                editor.select(nodes[0], PositionType.Begin);\r\n            } else if (nodes.length == 1) {\r\n                let tag = getTagOfNode(nodes[0]);\r\n                if (tag == 'BR') {\r\n                    nodes = [wrap(nodes[0])];\r\n                } else if (tag == 'LI' || tag == 'TD') {\r\n                    nodes = [].slice.call(nodes[0].childNodes) as Node[];\r\n                }\r\n            } else {\r\n                while (\r\n                    nodes[0] &&\r\n                    editor.contains(nodes[0].parentNode) &&\r\n                    nodes.some(node => UNWRAPPABLE_NODES.indexOf(getTagOfNode(node)) >= 0)\r\n                ) {\r\n                    nodes = [splitBalancedNodeRange(nodes)];\r\n                }\r\n            }\r\n\r\n            result = wrapFunction(nodes);\r\n            (styler || DEFAULT_STYLER)(result);\r\n        }\r\n\r\n        if (!editor.select(start, end) && result) {\r\n            editor.select(result);\r\n        }\r\n\r\n        return result;\r\n    }, ChangeSource.Format);\r\n}\r\n","import { StringMap } from '../types/maps';\r\n\r\n// Inheritable CSS properties\r\n// Ref: https://www.w3.org/TR/CSS21/propidx.html\r\nconst INHERITABLE_PROPERTIES = (\r\n    'border-spacing,caption-side,color,' +\r\n    'cursor,direction,empty-cells,font-family,font-size,font-style,font-variant,font-weight,' +\r\n    'font,letter-spacing,line-height,list-style-image,list-style-position,list-style-type,' +\r\n    'list-style,orphans,quotes,text-align,text-indent,text-transform,visibility,white-space,' +\r\n    'widows,word-spacing'\r\n).split(',');\r\n\r\n/**\r\n * Get inheritable CSS style values from the given element\r\n * @param element The element to get style from\r\n */\r\nexport default function getInheritableStyles(element: HTMLElement): StringMap {\r\n    let win = element && element.ownerDocument && element.ownerDocument.defaultView;\r\n    let styles = win && win.getComputedStyle(element);\r\n    let result: StringMap = {};\r\n    INHERITABLE_PROPERTIES.forEach(\r\n        name => (result[name] = (styles && styles.getPropertyValue(name)) || '')\r\n    );\r\n    return result;\r\n}\r\n","const START_FRAGMENT = '<!--StartFragment-->';\r\nconst END_FRAGMENT = '<!--EndFragment-->';\r\n\r\n/**\r\n * Build DOM tree from the given HTML string\r\n * @param html Source HTML string\r\n * @param preserveFragmentOnly If there is fragment markup (&lt;!--StartFragment--&gt; and &lt;!--EndFragment--&gt;),\r\n * only preserve content between these markups\r\n * @param fragmentHandler An optional callback to do customized fragment handling\r\n */\r\nexport default function htmlToDom(\r\n    html: string,\r\n    preserveFragmentOnly: boolean,\r\n    fragmentHandler?: (doc: HTMLDocument, sourceHtml: string) => void\r\n): HTMLDocument {\r\n    let parser = new DOMParser();\r\n    let doc = parser.parseFromString(html || '', 'text/html');\r\n\r\n    if (doc && doc.body && doc.body.firstChild) {\r\n        // 1. Filter out html code outside of Fragment tags if need\r\n        if (preserveFragmentOnly) {\r\n            (fragmentHandler || defaultFragmentTrimmer)(doc, html);\r\n        }\r\n\r\n        return doc;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction defaultFragmentTrimmer(doc: HTMLDocument, sourceHtml: string) {\r\n    let [html] = splitWithFragment(sourceHtml);\r\n    doc.body.innerHTML = html;\r\n}\r\n\r\n/**\r\n * Split the HTML string using its fragment info\r\n * @param html Source html string\r\n * @returns [String within fragment, String before fragment, String after fragment]\r\n */\r\nexport function splitWithFragment(html: string): [string, string, string] {\r\n    let startIndex = html.indexOf(START_FRAGMENT);\r\n    let endIndex = html.lastIndexOf(END_FRAGMENT);\r\n    if (startIndex >= 0 && endIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {\r\n        let before = html.substr(0, startIndex);\r\n        let after = html.substr(endIndex + END_FRAGMENT.length);\r\n        html = html.substring(startIndex + START_FRAGMENT.length, endIndex);\r\n        return [html, before, after];\r\n    } else {\r\n        return [html, null, null];\r\n    }\r\n}\r\n","import { Map } from '../types/maps';\r\n\r\nfunction nativeClone<T>(source: Map<T>, existingObj?: Map<T>): Map<T> {\r\n    return Object.assign(existingObj || {}, source);\r\n}\r\n\r\nfunction customClone<T>(source: Map<T>, existingObj?: Map<T>): Map<T> {\r\n    let result: Map<T> = existingObj || {};\r\n    if (source) {\r\n        for (let key of Object.keys(source)) {\r\n            result[key] = source[key];\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nexport const cloneObject = Object.assign ? nativeClone : customClone;\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/** NodeId attribute */\r\nconst NODE_ID_ATTRIBUTE_NAME = 'NodeId';\r\n\r\n/** Custom data for dom elements */\r\nexport default interface CustomData {\r\n    /** The dict storing custom data, key is element Id, value is dictionary */\r\n    dict: { [key: string]: { [key: string]: number } };\r\n\r\n    /** Next node Id to use */\r\n    nextNodeId: number;\r\n}\r\n\r\n/** create an empty CustomData */\r\nexport function createCustomData(): CustomData {\r\n    return {\r\n        dict: {},\r\n        nextNodeId: 1,\r\n    };\r\n}\r\n\r\n/**\r\n * Sets the specified object data\r\n */\r\nexport function setObject(customData: CustomData, element: Node, key: string, value: any) {\r\n    // Get the id for the element\r\n    if (element.nodeType == NodeType.Element) {\r\n        let id = getAndSetNodeId(customData, element as HTMLElement);\r\n        if (id != '') {\r\n            // Get the values for the element\r\n            if (!customData.dict[id]) {\r\n                // First time dictionary creation\r\n                customData.dict[id] = {};\r\n            }\r\n            customData.dict[id][key] = value;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Reads the specified object data\r\n */\r\nexport function getObject(customData: CustomData, element: Node, key: string): any {\r\n    if (element.nodeType == NodeType.Element) {\r\n        let id = getAndSetNodeId(customData, element as HTMLElement);\r\n        if (id != '') {\r\n            return customData.dict[id] && customData.dict[id][key];\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/** Get the unique id for the specified node... */\r\nfunction getAndSetNodeId(customData: CustomData, element: HTMLElement): string {\r\n    let id = element.getAttribute(NODE_ID_ATTRIBUTE_NAME);\r\n    if (!id) {\r\n        id = customData.nextNodeId.toString();\r\n        customData.nextNodeId++;\r\n        element.setAttribute(NODE_ID_ATTRIBUTE_NAME, id);\r\n    }\r\n    return id;\r\n}\r\n","import ListMetadata from './ListMetadata';\r\n\r\n/** Holds the ids for the lists already seen for a specified level */\r\nexport default interface LevelLists {\r\n    /**\r\n     * The metadata for the lists seen at  this level\r\n     * key: word list id, value: list metadata\r\n     */\r\n    listsMetadata: { [key: string]: ListMetadata };\r\n\r\n    /** Unique id of the list currently at this level */\r\n    currentUniqueListId: number;\r\n}\r\n\r\n/** create an empty LevelLists */\r\nexport function createLevelLists(): LevelLists {\r\n    return {\r\n        listsMetadata: {},\r\n        currentUniqueListId: -1,\r\n    };\r\n}\r\n","export { default as EditorWithGui } from './EditorGui/EditorWithGui';\r\n","export default class DOM {\r\n    static text(value: string): Node {\r\n        return document.createTextNode(value);\r\n    }\r\n\r\n    static div(clazz?: string, children?: Node[]): HTMLDivElement {\r\n        let div = document.createElement('div');\r\n\r\n        if (clazz) {\r\n            div.className = clazz;\r\n        }\r\n\r\n        if (children) {\r\n            children.forEach(e => {\r\n                div.appendChild(e);\r\n            });\r\n        }\r\n\r\n        return div;\r\n    }\r\n}\r\n","export { default as createEditor } from './createEditor';\r\nexport { default as createEditorWithGui } from './createEditorGui';\r\nexport * from 'roosterjs-editor-types';\r\nexport * from 'roosterjs-editor-dom';\r\nexport * from 'roosterjs-editor-core';\r\nexport * from 'roosterjs-editor-api';\r\nexport * from 'roosterjs-editor-plugins';\r\nexport * from 'roosterjs-plugin-image-resize';\r\nexport * from 'roosterjs-html-sanitizer';\r\nexport * from 'roosterjs-plugin-picker';\r\nexport * from 'roosterjs-editor-gui';\r\n","import { ContentEdit, HyperLink, Paste } from 'roosterjs-editor-plugins';\r\nimport { Editor, EditorOptions, EditorPlugin } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Create an editor instance with most common options\r\n * @param contentDiv The html div element needed for creating the editor\r\n * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are\r\n * DefalutShortcut, HyperLink, Paste, and ContentEdit, user don't need to add those.\r\n * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.\r\n * @returns The editor instance\r\n */\r\nexport default function createEditor(\r\n    contentDiv: HTMLDivElement,\r\n    additionalPlugins?: EditorPlugin[],\r\n    initialContent?: string\r\n): Editor {\r\n    let plugins: EditorPlugin[] = [new HyperLink(), new Paste(), new ContentEdit()];\r\n\r\n    if (additionalPlugins) {\r\n        plugins = plugins.concat(additionalPlugins);\r\n    }\r\n\r\n    let options: EditorOptions = {\r\n        plugins: plugins,\r\n        initialContent: initialContent,\r\n        defaultFormat: {\r\n            fontFamily: 'Calibri,Arial,Helvetica,sans-serif',\r\n            fontSize: '11pt',\r\n            textColor: '#000000',\r\n        },\r\n    };\r\n    return new Editor(contentDiv, options);\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport { PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * An editor plugin that show a tooltip for existing link\r\n */\r\nexport default class HyperLink implements EditorPlugin {\r\n    private editor: Editor;\r\n    private disposer: () => void;\r\n\r\n    /**\r\n     * Create a new instance of HyperLink class\r\n     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.\r\n     * Default value is to return the href itself. If null, there will be no tooltip text.\r\n     * @param target (Optional) Target window name for hyperlink. If null, will use \"_blank\"\r\n     * @param onLinkClick (Optional) Open link callback (return false to use default behavior)\r\n     */\r\n    constructor(\r\n        private getTooltipCallback: (href: string, a: HTMLAnchorElement) => string = href => href,\r\n        private target?: string,\r\n        private onLinkClick?: (anchor: HTMLAnchorElement, mouseEvent: MouseEvent) => boolean | void\r\n    ) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Hyperlink';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin\r\n     * @param editor The editor instance\r\n     */\r\n    public initialize(editor: Editor): void {\r\n        this.editor = editor;\r\n        this.disposer =\r\n            this.getTooltipCallback &&\r\n            editor.addDomEventHandler({ mouseover: this.onMouse, mouseout: this.onMouse });\r\n    }\r\n\r\n    protected onMouse = (e: MouseEvent) => {\r\n        const a = this.editor.getElementAtCursor('a[href]', <Node>e.target) as HTMLAnchorElement;\r\n        const href = this.tryGetHref(a);\r\n\r\n        if (href) {\r\n            this.editor.setEditorDomAttribute(\r\n                'title',\r\n                e.type == 'mouseover' ? this.getTooltipCallback(href, a) : null\r\n            );\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose(): void {\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    public onPluginEvent(event: PluginEvent): void {\r\n        if (event.eventType == PluginEventType.MouseUp) {\r\n            const anchor = this.editor.getElementAtCursor('A', <Node>(\r\n                event.rawEvent.srcElement\r\n            )) as HTMLAnchorElement;\r\n\r\n            if (anchor) {\r\n                if (this.onLinkClick && this.onLinkClick(anchor, event.rawEvent) !== false) {\r\n                    return;\r\n                }\r\n\r\n                let href: string;\r\n                if (\r\n                    !Browser.isFirefox &&\r\n                    (href = this.tryGetHref(anchor)) &&\r\n                    (Browser.isMac ? event.rawEvent.metaKey : event.rawEvent.ctrlKey) &&\r\n                    event.rawEvent.button === 0\r\n                ) {\r\n                    try {\r\n                        const target = this.target || '_blank';\r\n                        const window = this.editor.getDocument().defaultView;\r\n                        window.open(href, target);\r\n                    } catch {}\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Try get href from an anchor element\r\n     * The reason this is put in a try-catch is that\r\n     * it has been seen that accessing href may throw an exception, in particular on IE/Edge\r\n     */\r\n    private tryGetHref(anchor: HTMLAnchorElement): string {\r\n        try {\r\n            return anchor ? anchor.href : null;\r\n        } catch {}\r\n    }\r\n}\r\n","import contains from '../utils/contains';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\nimport { getFirstBlockElement } from '../blockElements/getFirstLastBlockElement';\r\nimport { getFirstInlineElement } from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * provides scoper for traversing the entire editor body starting from the beginning\r\n */\r\nexport default class BodyScoper implements TraversingScoper {\r\n    private startNode: Node;\r\n\r\n    /**\r\n     * Construct a new instance of BodyScoper class\r\n     * @param rootNode Root node of the body\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    constructor(public rootNode: Node, startNode?: Node) {\r\n        this.startNode = contains(rootNode, startNode) ? startNode : null;\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.startNode\r\n            ? getBlockElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstBlockElement(this.rootNode);\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        return this.startNode\r\n            ? getInlineElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstInlineElement(this.rootNode);\r\n    }\r\n\r\n    /**\r\n     * Since the scope is global, all blocks under the root node are in scope\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return contains(this.rootNode, blockElement.getStartNode());\r\n    }\r\n\r\n    /**\r\n     * Since we're at body scope, inline elements never need to be trimmed\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return inlineElement;\r\n    }\r\n}\r\n","import EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport NodeBlockElement from '../blockElements/NodeBlockElement';\r\nimport Position from '../selection/Position';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, ContentPosition, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport {\r\n    getFirstInlineElement,\r\n    getLastInlineElement,\r\n} from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * This provides traversing content in a selection start block\r\n * This is commonly used for those cursor context sensitive plugin,\r\n * they want to know text being typed at cursor\r\n * This provides a scope for parsing from cursor position up to begin of the selection block\r\n */\r\nexport default class SelectionBlockScoper implements TraversingScoper {\r\n    private block: BlockElement;\r\n    private position: NodePosition;\r\n\r\n    /**\r\n     * Create a new instance of SelectionBlockScoper class\r\n     * @param rootNode The root node of the whole scope\r\n     * @param position Position of the selection start\r\n     * @param startFrom Where to start, can be Begin, End, SelectionStart\r\n     */\r\n    constructor(\r\n        public rootNode: Node,\r\n        position: NodePosition | Range,\r\n        private startFrom: ContentPosition\r\n    ) {\r\n        position = position instanceof Range ? Position.getStart(position) : position;\r\n        this.position = position.normalize();\r\n        this.block = getBlockElementAtNode(this.rootNode, this.position.node);\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.block;\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     * The start inline refers to inline before the selection start\r\n     *  The reason why we choose the one before rather after is, when cursor is at the end of a paragragh,\r\n     * the one after likely will point to inline in next paragragh which may be null if the cursor is at bottom of editor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (this.block) {\r\n            switch (this.startFrom) {\r\n                case ContentPosition.Begin:\r\n                case ContentPosition.End:\r\n                    return getFirstLastInlineElementFromBlockElement(\r\n                        this.block,\r\n                        this.startFrom == ContentPosition.Begin\r\n                    );\r\n                case ContentPosition.SelectionStart:\r\n                    // Get the inline before selection start point, and ensure it falls in the selection block\r\n                    let startInline = getInlineElementAfter(this.rootNode, this.position);\r\n                    return startInline && this.block.contains(startInline.getContainerNode())\r\n                        ? startInline\r\n                        : new EmptyInlineElement(this.position, this.block);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if the given block element is in current scope\r\n     * @param blockElement The block element to check\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return this.block && blockElement ? this.block.equals(blockElement) : false;\r\n    }\r\n\r\n    /**\r\n     * Trim the incoming inline element, and return an inline element\r\n     * This just tests and return the inline element if it is in block\r\n     * This is a block scoper, which is not like selection scoper where it may cut an inline element in half\r\n     * A block scoper does not cut an inline in half\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return this.block && inlineElement && this.block.contains(inlineElement.getContainerNode())\r\n            ? inlineElement\r\n            : null;\r\n    }\r\n}\r\n\r\n/**\r\n * Get first/last InlineElement of the given BlockElement\r\n * @param block The BlockElement to get InlineElement from\r\n * @param isFirst True to get first InlineElement, false to get last InlineElement\r\n */\r\nfunction getFirstLastInlineElementFromBlockElement(\r\n    block: BlockElement,\r\n    isFirst: boolean\r\n): InlineElement {\r\n    if (block instanceof NodeBlockElement) {\r\n        let blockNode = block.getStartNode();\r\n        return isFirst ? getFirstInlineElement(blockNode) : getLastInlineElement(blockNode);\r\n    } else {\r\n        return getInlineElementAtNode(block, isFirst ? block.getStartNode() : block.getEndNode());\r\n    }\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport Position from '../selection/Position';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\n\r\n/**\r\n * This is selection scoper that provide a start inline as the start of the selection\r\n * and checks if a block falls in the selection (isBlockInScope)\r\n * last trimInlineElement to trim any inline element to return a partial that falls in the selection\r\n */\r\nexport default class SelectionScoper implements TraversingScoper {\r\n    private start: NodePosition;\r\n    private end: NodePosition;\r\n    private startBlock: BlockElement;\r\n    private startInline: InlineElement;\r\n\r\n    /**\r\n     * Create a new instance of SelectionScoper class\r\n     * @param rootNode The root node of the content\r\n     * @param range The selection range to scope to\r\n     */\r\n    constructor(public rootNode: Node, range: Range) {\r\n        this.start = Position.getStart(range).normalize();\r\n        this.end = Position.getEnd(range).normalize();\r\n    }\r\n\r\n    /**\r\n     * Provide a start block as the first block after the cursor\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        if (!this.startBlock) {\r\n            this.startBlock = getBlockElementAtNode(this.rootNode, this.start.node);\r\n        }\r\n\r\n        return this.startBlock;\r\n    }\r\n\r\n    /**\r\n     * Provide a start inline as the first inline after the cursor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (!this.startInline) {\r\n            this.startInline = this.trimInlineElement(\r\n                getInlineElementAfter(this.rootNode, this.start)\r\n            );\r\n        }\r\n\r\n        return this.startInline;\r\n    }\r\n\r\n    /**\r\n     * Checks if a block completely falls in the selection\r\n     * @param block The BlockElement to check\r\n     */\r\n    public isBlockInScope(block: BlockElement): boolean {\r\n        if (!block) {\r\n            return false;\r\n        }\r\n        let inScope = false;\r\n        let selStartBlock = this.getStartBlockElement();\r\n        if (this.start.equalTo(this.end)) {\r\n            inScope = selStartBlock && selStartBlock.equals(block);\r\n        } else {\r\n            let selEndBlock = getBlockElementAtNode(this.rootNode, this.end.node);\r\n\r\n            // There are three cases that are considered as \"block in scope\"\r\n            // 1) The start of selection falls on the block\r\n            // 2) The end of selection falls on the block\r\n            // 3) the block falls in-between selection start and end\r\n            inScope =\r\n                selStartBlock &&\r\n                selEndBlock &&\r\n                (block.equals(selStartBlock) ||\r\n                    block.equals(selEndBlock) ||\r\n                    (block.isAfter(selStartBlock) && selEndBlock.isAfter(block)));\r\n        }\r\n\r\n        return inScope;\r\n    }\r\n\r\n    /**\r\n     * Trim an incoming inline. If it falls completely outside selection, return null\r\n     * otherwise return a partial that represents the portion that falls in the selection\r\n     * @param inline The InlineElement to check\r\n     */\r\n    public trimInlineElement(inline: InlineElement): InlineElement {\r\n        if (!inline || this.start.equalTo(this.end)) {\r\n            return null;\r\n        }\r\n\r\n        // Temp code. Will be changed to using InlineElement.getStart/EndPosition() soon\r\n        let start = inline.getStartPosition();\r\n        let end = inline.getEndPosition();\r\n\r\n        if (start.isAfter(this.end) || this.start.isAfter(end)) {\r\n            return null;\r\n        }\r\n\r\n        let startPartial = false;\r\n        let endPartial = false;\r\n\r\n        if (this.start.isAfter(start)) {\r\n            start = this.start;\r\n            startPartial = true;\r\n        }\r\n\r\n        if (end.isAfter(this.end)) {\r\n            end = this.end;\r\n            endPartial = true;\r\n        }\r\n\r\n        return start.isAfter(end) || start.equalTo(end)\r\n            ? null\r\n            : startPartial || endPartial\r\n            ? new PartialInlineElement(inline, startPartial && start, endPartial && end)\r\n            : inline;\r\n    }\r\n}\r\n","import ContentTraverser from './ContentTraverser';\r\nimport createRange from '../selection/createRange';\r\nimport { InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n// White space matching regex. It matches following chars:\r\n// \\s: white space\r\n// \\u00A0: no-breaking white space\r\n// \\u200B: zero width space\r\n// \\u3000: full width space (which can come from JPN IME)\r\nconst WHITESPACE_REGEX = /[\\s\\u00A0\\u200B\\u3000]+([^\\s\\u00A0\\u200B\\u3000]*)$/i;\r\n\r\n/**\r\n * The class that helps search content around a position\r\n */\r\nexport default class PositionContentSearcher {\r\n    // The cached text before position that has been read so far\r\n    private text = '';\r\n\r\n    // The cached word before position\r\n    private word: string;\r\n\r\n    // The inline element before position\r\n    private inlineBefore: InlineElement;\r\n\r\n    // The inline element after position\r\n    private inlineAfter: InlineElement;\r\n\r\n    // The content traverser used to traverse backwards\r\n    private traverser: ContentTraverser;\r\n\r\n    // Backward parsing has completed\r\n    private traversingComplete: boolean;\r\n\r\n    // All inline elements before position that have been read so far\r\n    private inlineElements: InlineElement[] = [];\r\n\r\n    // First non-text inline before position\r\n    private nearestNonTextInlineElement: InlineElement;\r\n\r\n    /**\r\n     * Create a new CursorData instance\r\n     * @param rootNode Root node of the whole scope\r\n     * @param position Start position\r\n     */\r\n    constructor(private rootNode: Node, private position: NodePosition) {}\r\n\r\n    /**\r\n     * Get the word before position. The word is determined by scanning backwards till the first white space, the portion\r\n     * between position and the white space is the word before position\r\n     * @returns The word before position\r\n     */\r\n    public getWordBefore(): string {\r\n        if (!this.word) {\r\n            this.traverse(() => this.word);\r\n        }\r\n\r\n        return this.word;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element before position\r\n     * @returns The inlineElement before position\r\n     */\r\n    public getInlineElementBefore(): InlineElement {\r\n        if (!this.inlineBefore) {\r\n            this.traverse(null);\r\n        }\r\n\r\n        return this.inlineBefore;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element after position\r\n     * @returns The inline element after position\r\n     */\r\n    public getInlineElementAfter(): InlineElement {\r\n        if (!this.inlineAfter) {\r\n            this.inlineAfter = ContentTraverser.createBlockTraverser(\r\n                this.rootNode,\r\n                this.position\r\n            ).currentInlineElement;\r\n        }\r\n\r\n        return this.inlineAfter;\r\n    }\r\n\r\n    /**\r\n     * Get X number of chars before position\r\n     * The actual returned chars may be less than what is requested.\r\n     * @param length The length of string user want to get, the string always ends at the position,\r\n     * so this length determins the start position of the string\r\n     * @returns The actual string we get as a sub string, or the whole string before position when\r\n     * there is not enough chars in the string\r\n     */\r\n    public getSubStringBefore(length: number): string {\r\n        if (this.text.length < length) {\r\n            this.traverse(() => this.text.length >= length);\r\n        }\r\n\r\n        return this.text.substr(Math.max(0, this.text.length - length));\r\n    }\r\n\r\n    /**\r\n     * Try to get a range matches the given text before the position\r\n     * @param text The text to match against\r\n     * @param exactMatch Whether it is an exact match\r\n     * @returns The range for the matched text, null if unable to find a match\r\n     */\r\n    public getRangeFromText(text: string, exactMatch: boolean): Range {\r\n        if (!text) {\r\n            return null;\r\n        }\r\n\r\n        let startPosition: NodePosition;\r\n        let endPosition: NodePosition;\r\n        let textIndex = text.length - 1;\r\n\r\n        this.forEachTextInlineElement(textInline => {\r\n            let nodeContent = textInline.getTextContent() || '';\r\n            let nodeIndex = nodeContent.length - 1;\r\n            for (; nodeIndex >= 0 && textIndex >= 0; nodeIndex--) {\r\n                if (text.charCodeAt(textIndex) == nodeContent.charCodeAt(nodeIndex)) {\r\n                    textIndex--;\r\n\r\n                    // on first time when end is matched, set the end of range\r\n                    if (!endPosition) {\r\n                        endPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                    }\r\n                } else if (exactMatch || endPosition) {\r\n                    // Mismatch found when exact match or end already match, so return since matching failed\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // when textIndex == -1, we have a successful complete match\r\n            if (textIndex == -1) {\r\n                startPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return startPosition && endPosition && createRange(startPosition, endPosition);\r\n    }\r\n\r\n    /**\r\n     * Get text section before position till stop condition is met.\r\n     * This offers consumers to retrieve text section by section\r\n     * The section essentially is just an inline element which has Container element\r\n     * so that the consumer can remember it for anchoring popup or verification purpose\r\n     * when position moves out of context etc.\r\n     * @param stopFunc The callback stop function\r\n     */\r\n    public forEachTextInlineElement(callback: (textInlineElement: InlineElement) => any) {\r\n        // We cache all text sections read so far\r\n        // Every time when you ask for textSection, we start with the cached first\r\n        // and resort to further reading once we exhausted with the cache\r\n        if (!this.inlineElements.some(callback)) {\r\n            this.traverse(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get first non textual inline element before position\r\n     * @returns First non textutal inline element before position or null if no such element exists\r\n     */\r\n    public getNearestNonTextInlineElement(): InlineElement {\r\n        if (!this.nearestNonTextInlineElement) {\r\n            this.traverse(() => this.nearestNonTextInlineElement);\r\n        }\r\n\r\n        return this.nearestNonTextInlineElement;\r\n    }\r\n\r\n    /**\r\n     * Continue traversing backward till stop condition is met or begin of block is reached\r\n     */\r\n    private traverse(callback: (inlineElement: InlineElement) => any) {\r\n        this.traverser =\r\n            this.traverser || ContentTraverser.createBlockTraverser(this.rootNode, this.position);\r\n\r\n        if (!this.traverser || this.traversingComplete) {\r\n            return;\r\n        }\r\n\r\n        let previousInline = this.traverser.getPreviousInlineElement();\r\n        while (!this.traversingComplete) {\r\n            this.inlineBefore = this.inlineBefore || previousInline;\r\n\r\n            if (previousInline && previousInline.isTextualInlineElement()) {\r\n                let textContent = previousInline.getTextContent();\r\n\r\n                // build the word before position if it is not built yet\r\n                if (!this.word) {\r\n                    // Match on the white space, the portion after space is on the index of 1 of the matched result\r\n                    // (index at 0 is whole match result, index at 1 is the word)\r\n                    let matches = WHITESPACE_REGEX.exec(textContent);\r\n                    if (matches && matches.length == 2) {\r\n                        this.word = matches[1] + this.text;\r\n                    }\r\n                }\r\n\r\n                this.text = textContent + this.text;\r\n                this.inlineElements.push(previousInline);\r\n\r\n                // Check if stop condition is met\r\n                if (callback && callback(previousInline)) {\r\n                    break;\r\n                }\r\n            } else {\r\n                this.nearestNonTextInlineElement = previousInline;\r\n                this.traversingComplete = true;\r\n                if (!this.word) {\r\n                    // if parsing is done, whatever we get so far in this.cachedText should also be in this.cachedWordBeforeCursor\r\n                    this.word = this.text;\r\n                }\r\n\r\n                // When a non-textual inline element, or null is seen, we consider parsing complete\r\n                // TODO: we may need to change this if there is a future need to parse beyond text, i.e.\r\n                // we have aaa @someone bbb<position>, and we want to read the text before @someone\r\n                break;\r\n            }\r\n\r\n            previousInline = this.traverser.getPreviousInlineElement();\r\n        }\r\n    }\r\n}\r\n","import { DefaultFormat } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Apply format to an HTML element\r\n * @param element The HTML element to apply format to\r\n * @param format The format to apply\r\n */\r\nexport default function applyFormat(element: HTMLElement, format: DefaultFormat, isDarkMode?: boolean) {\r\n    if (format) {\r\n        let elementStyle = element.style;\r\n        let { fontFamily, fontSize, textColor, textColors, backgroundColor, backgroundColors, bold, italic, underline } = format;\r\n\r\n        if (fontFamily) {\r\n            elementStyle.fontFamily = fontFamily;\r\n        }\r\n        if (fontSize) {\r\n            elementStyle.fontSize = fontSize;\r\n        }\r\n        if (textColor || textColors) {\r\n            if (textColors && isDarkMode) {\r\n                element.dataset.ogsc = textColors.lightModeColor;\r\n            }\r\n            elementStyle.color = textColor;\r\n        }\r\n        if (backgroundColor || backgroundColors) {\r\n            if (backgroundColors && isDarkMode) {\r\n                element.dataset.ogsb = backgroundColors.lightModeColor;\r\n            }\r\n            elementStyle.backgroundColor = backgroundColor;\r\n        }\r\n        if (bold) {\r\n            elementStyle.fontWeight = 'bold';\r\n        }\r\n        if (italic) {\r\n            elementStyle.fontStyle = 'italic';\r\n        }\r\n        if (underline) {\r\n            elementStyle.textDecoration = 'underline';\r\n        }\r\n    }\r\n}\r\n","import { Browser } from './Browser';\r\nimport { ClipboardItems } from 'roosterjs-editor-types';\r\n\r\n// HTML header to indicate where is the HTML content started from.\r\n// Sample header:\r\n// Version:0.9\r\n// StartHTML:71\r\n// EndHTML:170\r\n// StartFragment:140\r\n// EndFragment:160\r\n// StartSelection:140\r\n// EndSelection:160\r\nconst CLIPBOARD_HTML_HEADER_REGEX = /^Version:[0-9\\.]+\\s+StartHTML:\\s*([0-9]+)\\s+EndHTML:\\s*([0-9]+)\\s+/i;\r\n\r\ninterface WindowForIE extends Window {\r\n    clipboardData: DataTransfer;\r\n}\r\n\r\n/**\r\n * Extract a Clipboard event\r\n * @param event The paste event\r\n * @param callback Callback function when data is ready\r\n * @param fallbackHtmlRetriever If direct HTML retriving is not support (e.g. Internet Explorer), as a fallback,\r\n * using this helper function to retrieve HTML content\r\n * @returns An object with the following properties:\r\n *  types: Available types from the clipboard event\r\n *  text: Plain text from the clipboard event\r\n *  image: Image file from the clipboard event\r\n *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.\r\n *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is\r\n *   not supported by browser.\r\n */\r\nexport default function extractClipboardEvent(\r\n    event: ClipboardEvent,\r\n    callback: (items: ClipboardItems) => void\r\n) {\r\n    let dataTransfer =\r\n        event.clipboardData ||\r\n        (<WindowForIE>(<Node>event.target).ownerDocument.defaultView).clipboardData;\r\n    let result: ClipboardItems = {\r\n        types: dataTransfer.types ? [].slice.call(dataTransfer.types) : [],\r\n        text: dataTransfer.getData('text'),\r\n        image: getImage(dataTransfer),\r\n        html: undefined,\r\n    };\r\n\r\n    if (event.clipboardData && event.clipboardData.items) {\r\n        event.preventDefault();\r\n        let items = event.clipboardData.items;\r\n        for (let i = 0; i < items.length; i++) {\r\n            let item = items[i];\r\n            if (item.type && item.type.indexOf('text/html') == 0) {\r\n                item.getAsString(html => {\r\n                    result.html = Browser.isEdge ? workaroundForEdge(html) : html;\r\n                    callback(result);\r\n                });\r\n                return;\r\n            }\r\n        }\r\n\r\n        // No HTML content found, set html to null\r\n        result.html = null;\r\n    }\r\n\r\n    callback(result);\r\n}\r\n\r\nfunction getImage(dataTransfer: DataTransfer): File {\r\n    // Chrome, Firefox, Edge support dataTransfer.items\r\n    let fileCount = dataTransfer.items ? dataTransfer.items.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let item = dataTransfer.items[i];\r\n        if (item.type && item.type.indexOf('image/') == 0) {\r\n            return item.getAsFile();\r\n        }\r\n    }\r\n    // IE, Safari support dataTransfer.files\r\n    fileCount = dataTransfer.files ? dataTransfer.files.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let file = dataTransfer.files.item(i);\r\n        if (file.type && file.type.indexOf('image/') == 0) {\r\n            return file;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Edge sometimes doesn't remove the headers, which cause we paste more things then expected.\r\n * So we need to remove it in our code\r\n * @param html The HTML string got from clipboard\r\n */\r\nfunction workaroundForEdge(html: string) {\r\n    let headerValues = CLIPBOARD_HTML_HEADER_REGEX.exec(html);\r\n\r\n    if (headerValues && headerValues.length == 3) {\r\n        let start = parseInt(headerValues[1]);\r\n        let end = parseInt(headerValues[2]);\r\n        if (start > 0 && end > start) {\r\n            html = html.substring(start, end);\r\n        }\r\n    }\r\n\r\n    return html;\r\n}\r\n","import { DocumentCommand, PendableFormatState } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Names of Pendable formats\r\n */\r\nexport type PendableFormatNames = keyof PendableFormatState;\r\n\r\n/**\r\n * A map from pendable format name to document command\r\n */\r\nexport const PendableFormatCommandMap: { [key in PendableFormatNames]: DocumentCommand } = {\r\n    /**\r\n     * Bold\r\n     */\r\n    isBold: DocumentCommand.Bold,\r\n\r\n    /**\r\n     * Italic\r\n     */\r\n    isItalic: DocumentCommand.Italic,\r\n\r\n    /**\r\n     * Underline\r\n     */\r\n    isUnderline: DocumentCommand.Underline,\r\n\r\n    /**\r\n     * StrikeThrough\r\n     */\r\n    isStrikeThrough: DocumentCommand.StrikeThrough,\r\n\r\n    /**\r\n     * Subscript\r\n     */\r\n    isSubscript: DocumentCommand.Subscript,\r\n\r\n    /**\r\n     * Superscript\r\n     */\r\n    isSuperscript: DocumentCommand.Superscript,\r\n};\r\n\r\n/**\r\n * Get Pendable Format State at cursor.\r\n * @param document The HTML Document to get format state from\r\n * @returns A PendableFormatState object which contains the values of pendable format states\r\n */\r\nexport default function getPendableFormatState(document: Document): PendableFormatState {\r\n    let keys = Object.keys(PendableFormatCommandMap) as PendableFormatNames[];\r\n\r\n    return keys.reduce(\r\n        (state, key) => {\r\n            state[key] = document.queryCommandState(PendableFormatCommandMap[key]);\r\n            return state;\r\n        },\r\n        <PendableFormatState>{}\r\n    );\r\n}\r\n","import { LinkData } from 'roosterjs-editor-types';\r\n\r\ninterface LinkMatchRule {\r\n    match: RegExp;\r\n    except?: RegExp;\r\n    normalizeUrl?: (url: string) => string;\r\n}\r\n\r\n// http exclude matching regex\r\n// invalid URL example (in paricular on IE and Edge):\r\n// - http://www.bing.com%00, %00 before ? (question mark) is considered invalid. IE/Edge throws invalid argument exception\r\n// - http://www.bing.com%1, %1 is invalid\r\n// - http://www.bing.com%g, %g is invalid (IE and Edge expects a two hex value after a %)\r\n// - http://www.bing.com%, % as ending is invalid (IE and Edge expects a two hex value after a %)\r\n// All above % cases if they're after ? (question mark) is then considered valid again\r\n// Similar for @, it needs to be after / (forward slash), or ? (question mark). Otherwise IE/Edge will throw security exception\r\n// - http://www.bing.com@name, @name before ? (question mark) is considered invalid\r\n// - http://www.bing.com/@name, is valid sine it is after / (forward slash)\r\n// - http://www.bing.com?@name, is also valid sinve it is after ? (question mark)\r\n// The regex below is essentially a break down of:\r\n// ^[^?]+%[^0-9a-f]+ => to exclude URL like www.bing.com%%\r\n// ^[^?]+%[0-9a-f][^0-9a-f]+ => to exclude URL like www.bing.com%1\r\n// ^[^?]+%00 => to exclude URL like www.bing.com%00\r\n// ^[^?]+%$ => to exclude URL like www.bing.com%\r\n// ^https?:\\/\\/[^?\\/]+@ => to exclude URL like http://www.bing.com@name\r\n// ^www\\.[^?\\/]+@ => to exclude URL like www.bing.com@name\r\n// , => to exclude url like www.bing,,com\r\nconst httpExcludeRegEx = /^[^?]+%[^0-9a-f]+|^[^?]+%[0-9a-f][^0-9a-f]+|^[^?]+%00|^[^?]+%$|^https?:\\/\\/[^?\\/]+@|^www\\.[^?\\/]+@/i;\r\n\r\n// via https://tools.ietf.org/html/rfc1035 Page 7\r\nconst labelRegEx = '[a-z0-9](?:[a-z0-9-]*[a-z0-9])?'; // We're using case insensitive regexes below so don't bother including A-Z\r\nconst domainNameRegEx = `(?:${labelRegEx}\\\\.)*${labelRegEx}`;\r\nconst domainPortRegEx = `${domainNameRegEx}(?:\\\\:[0-9]+)?`;\r\nconst domainPortWithUrlRegEx = `${domainPortRegEx}(?:[\\\\/\\\\?]\\\\S*)?`;\r\n\r\nconst linkMatchRules: { [schema: string]: LinkMatchRule } = {\r\n    http: {\r\n        match: new RegExp(\r\n            `^(?:microsoft-edge:)?http:\\\\/\\\\/${domainPortWithUrlRegEx}|www\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        except: httpExcludeRegEx,\r\n        normalizeUrl: url =>\r\n            new RegExp('^(?:microsoft-edge:)?http:\\\\/\\\\/', 'i').test(url) ? url : 'http://' + url,\r\n    },\r\n    https: {\r\n        match: new RegExp(`^(?:microsoft-edge:)?https:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i'),\r\n        except: httpExcludeRegEx,\r\n    },\r\n    mailto: { match: new RegExp('^mailto:\\\\S+@\\\\S+\\\\.\\\\S+', 'i') },\r\n    notes: { match: new RegExp('^notes:\\\\/\\\\/\\\\S+', 'i') },\r\n    file: { match: new RegExp('^file:\\\\/\\\\/\\\\/?\\\\S+', 'i') },\r\n    unc: { match: new RegExp('^\\\\\\\\\\\\\\\\\\\\S+', 'i') },\r\n    ftp: {\r\n        match: new RegExp(\r\n            `^ftp:\\\\/\\\\/${domainPortWithUrlRegEx}|ftp\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        normalizeUrl: url => (new RegExp('^ftp:\\\\/\\\\/', 'i').test(url) ? url : 'ftp://' + url),\r\n    },\r\n    news: { match: new RegExp(`^news:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    telnet: { match: new RegExp(`^telnet:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    gopher: { match: new RegExp(`^gopher:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i') },\r\n    wais: { match: new RegExp(`^wais:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n};\r\n\r\n/**\r\n * Try to match a given string with link match rules, return matched link\r\n * @param url Input url to match\r\n * @param option Link match option, exact or partial. If it is exact match, we need\r\n * to check the length of matched link and url\r\n * @param rules Optional link match rules, if not passed, only the default link match\r\n * rules will be applied\r\n * @returns The matched link data, or null if no match found.\r\n * The link data includes an original url and a normalized url\r\n */\r\nexport default function matchLink(url: string): LinkData {\r\n    if (url) {\r\n        for (let schema of Object.keys(linkMatchRules)) {\r\n            let rule = linkMatchRules[schema];\r\n            let matches = url.match(rule.match);\r\n            if (matches && matches[0] == url && (!rule.except || !rule.except.test(url))) {\r\n                return {\r\n                    scheme: schema,\r\n                    originalUrl: url,\r\n                    normalizedUrl: rule.normalizeUrl ? rule.normalizeUrl(url) : url,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import changeElementTag from './changeElementTag';\r\nimport contains from './contains';\r\nimport createRange from '../selection/createRange';\r\nimport findClosestElementAncestor from './findClosestElementAncestor';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getTagOfNode from './getTagOfNode';\r\nimport isNodeEmpty from './isNodeEmpty';\r\nimport isPositionAtBeginningOf from '../selection/isPositionAtBeginningOf';\r\nimport isVoidHtmlElement from './isVoidHtmlElement';\r\nimport Position from '../selection/Position';\r\nimport queryElements from './queryElements';\r\nimport splitTextNode from './splitTextNode';\r\nimport unwrap from './unwrap';\r\nimport VTable from '../table/VTable';\r\nimport wrap from './wrap';\r\nimport { NodePosition, NodeType, PositionType, QueryScope } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from './splitParentNode';\r\n\r\nconst adjustSteps: ((\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n) => NodePosition)[] = [handleHyperLink, handleStructuredNode, handleParagraph, handleVoidElement];\r\n\r\n/**\r\n * Adjust the given position and return a better position (if any) or the given position\r\n * which will be the best one for inserting the given node.\r\n * @param root Root node of the scope\r\n * @param nodeToInsert The node about to be inserted\r\n * @param position The original position to insert the node\r\n */\r\nexport default function adjustNodeInsertPosition(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    adjustSteps.forEach(handler => {\r\n        position = handler(root, nodeToInsert, position);\r\n    });\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleHyperLink(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    let blockElement = getBlockElementAtNode(root, position.node);\r\n\r\n    if (blockElement) {\r\n        // Find the first <A> tag within current block which covers current selection\r\n        // If there are more than one nested, let's handle the first one only since that is not a common scenario.\r\n        let anchor = queryElements(\r\n            root,\r\n            'a[href]',\r\n            null /*forEachCallback*/,\r\n            QueryScope.OnSelection,\r\n            createRange(position)\r\n        ).filter(a => blockElement.contains(a))[0];\r\n\r\n        // If this is about to insert node to an empty A tag, clear the A tag and reset position\r\n        if (anchor && isNodeEmpty(anchor)) {\r\n            position = new Position(anchor, PositionType.Before);\r\n            safeRemove(anchor);\r\n            anchor = null;\r\n        }\r\n\r\n        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag\r\n        // otherwise we will have nested A tags which is a wrong HTML structure\r\n        if (\r\n            anchor &&\r\n            (<ParentNode>(<any>nodeToInsert)).querySelector &&\r\n            (<ParentNode>(<any>nodeToInsert)).querySelector('a[href]')\r\n        ) {\r\n            let normalizedPosition = position.normalize();\r\n            let parentNode = normalizedPosition.node.parentNode;\r\n            let nextNode =\r\n                normalizedPosition.node.nodeType == NodeType.Text\r\n                    ? splitTextNode(\r\n                          <Text>normalizedPosition.node,\r\n                          normalizedPosition.offset,\r\n                          false /*returnFirstPart*/\r\n                      )\r\n                    : normalizedPosition.isAtEnd\r\n                    ? normalizedPosition.node.nextSibling\r\n                    : normalizedPosition.node;\r\n            let splitter: Node = root.ownerDocument.createTextNode('');\r\n            parentNode.insertBefore(splitter, nextNode);\r\n\r\n            while (contains(anchor, splitter)) {\r\n                splitter = splitBalancedNodeRange(splitter);\r\n            }\r\n\r\n            position = new Position(splitter, PositionType.Before);\r\n            safeRemove(splitter);\r\n        }\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleStructuredNode(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    let rootNodeToInsert = nodeToInsert;\r\n\r\n    if (rootNodeToInsert.nodeType == NodeType.DocumentFragment) {\r\n        let rootNodes = (<Node[]>[].slice.call(rootNodeToInsert.childNodes)).filter(\r\n            n => getTagOfNode(n) != 'BR'\r\n        );\r\n        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;\r\n    }\r\n\r\n    let tag = getTagOfNode(rootNodeToInsert);\r\n    let hasBrNextToRoot = tag && getTagOfNode(rootNodeToInsert.nextSibling) == 'BR';\r\n    let listItem = findClosestElementAncestor(position.node, root, 'LI');\r\n    let listNode = listItem && findClosestElementAncestor(listItem, root, 'OL,UL');\r\n    let tdNode = findClosestElementAncestor(position.node, root, 'TD,TH');\r\n    let trNode = tdNode && findClosestElementAncestor(tdNode, root, 'TR');\r\n\r\n    if (tag == 'LI') {\r\n        tag = listNode ? getTagOfNode(listNode) : 'UL';\r\n        rootNodeToInsert = wrap(rootNodeToInsert, tag);\r\n    }\r\n\r\n    if ((tag == 'OL' || tag == 'UL') && getTagOfNode(rootNodeToInsert.firstChild) == 'LI') {\r\n        let shouldInsertListAsText = !rootNodeToInsert.firstChild.nextSibling && !hasBrNextToRoot;\r\n\r\n        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {\r\n            safeRemove(rootNodeToInsert.nextSibling);\r\n        }\r\n\r\n        if (shouldInsertListAsText) {\r\n            unwrap(rootNodeToInsert.firstChild);\r\n            unwrap(rootNodeToInsert);\r\n        } else if (getTagOfNode(listNode) == tag) {\r\n            unwrap(rootNodeToInsert);\r\n            position = new Position(\r\n                listItem,\r\n                isPositionAtBeginningOf(position, listItem)\r\n                    ? PositionType.Before\r\n                    : PositionType.After\r\n            );\r\n        }\r\n    } else if (tag == 'TABLE' && trNode) {\r\n        // When inserting a table into a table, if these tables have the same column count, and\r\n        // current position is at beginning of a row, then merge these two tables\r\n        let newTable = new VTable(<HTMLTableElement>rootNodeToInsert);\r\n        let currentTable = new VTable(<HTMLTableCellElement>tdNode);\r\n        if (\r\n            currentTable.col == 0 &&\r\n            tdNode == currentTable.getCell(currentTable.row, 0).td &&\r\n            newTable.cells[0] &&\r\n            newTable.cells[0].length == currentTable.cells[0].length &&\r\n            isPositionAtBeginningOf(position, tdNode)\r\n        ) {\r\n            if (\r\n                getTagOfNode(rootNodeToInsert.firstChild) == 'TBODY' &&\r\n                !rootNodeToInsert.firstChild.nextSibling\r\n            ) {\r\n                unwrap(rootNodeToInsert.firstChild);\r\n            }\r\n            unwrap(rootNodeToInsert);\r\n            position = new Position(trNode, PositionType.After);\r\n        }\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleParagraph(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    if (getTagOfNode(position.node) == 'P') {\r\n        // Insert into a P tag may cause issues when the inserted content contains any block element.\r\n        // Change P tag to DIV to make sure it works well\r\n        let pos = position.normalize();\r\n        let div = changeElementTag(<HTMLElement>position.node, 'div');\r\n        if (pos.node != div) {\r\n            position = pos;\r\n        }\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleVoidElement(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    if (isVoidHtmlElement(position.node)) {\r\n        position = new Position(\r\n            position.node,\r\n            position.isAtEnd ? PositionType.After : PositionType.Before\r\n        );\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction safeRemove(node: Node) {\r\n    if (node && node.parentNode) {\r\n        node.parentNode.removeChild(node);\r\n    }\r\n}\r\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\r\n\r\n/**\r\n * get block element's text content.\r\n * @param rootNode Root node that the get the textContent of.\r\n * @returns text content of given text content.\r\n */\r\nexport default function getTextContent(rootNode: Node): string {\r\n    const traverser = ContentTraverser.createBodyTraverser(rootNode);\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let textContent: string[] = [];\r\n\r\n    while (block) {\r\n        textContent.push(block.getTextContent());\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    return textContent.join('\\n');\r\n}\r\n","import createRange from './createRange';\r\nimport { NodePosition, NodeType, Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get bounding rect of this position\r\n * @param position The positioin to get rect from\r\n */\r\nexport default function getPositionRect(position: NodePosition): Rect {\r\n    if (!position) {\r\n        return null;\r\n    }\r\n\r\n    let range = createRange(position);\r\n\r\n    // 1) try to get rect using range.getBoundingClientRect()\r\n    let rect = range.getBoundingClientRect && normalizeRect(range.getBoundingClientRect());\r\n\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 2) try to get rect using range.getClientRects\r\n    position = position.normalize();\r\n    const rects = range.getClientRects && range.getClientRects();\r\n    rect = rects && rects.length == 1 && normalizeRect(rects[0]);\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 3) if node is text node, try inserting a SPAN and get the rect of SPAN for others\r\n    if (position.node.nodeType == NodeType.Text) {\r\n        let span = document.createElement('SPAN');\r\n        span.innerHTML = '\\u200b';\r\n        range = createRange(position);\r\n        range.insertNode(span);\r\n        rect = span.getBoundingClientRect && normalizeRect(span.getBoundingClientRect());\r\n        span.parentNode.removeChild(span);\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    // 4) try getBoundingClientRect on element\r\n    let element = position.element;\r\n    if (element && element.getBoundingClientRect) {\r\n        rect = normalizeRect(element.getBoundingClientRect());\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction normalizeRect(clientRect: ClientRect): Rect {\r\n    // A ClientRect of all 0 is possible. i.e. chrome returns a ClientRect of 0 when the cursor is on an empty p\r\n    // We validate that and only return a rect when the passed in ClientRect is valid\r\n    let { left, right, top, bottom } = clientRect || <ClientRect>{};\r\n    return left + right + top + bottom > 0\r\n        ? {\r\n              left: Math.round(left),\r\n              right: Math.round(right),\r\n              top: Math.round(top),\r\n              bottom: Math.round(bottom),\r\n          }\r\n        : null;\r\n}\r\n","import contains from '../utils/contains';\r\nimport Position from './Position';\r\nimport { NodePosition, NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get path of the given selection range related to the given rootNode\r\n * @param rootNode The root node where the path start from\r\n * @param range The range of selection\r\n */\r\nexport default function getSelectionPath(rootNode: HTMLElement, range: Range): SelectionPath {\r\n    if (!range) {\r\n        return null;\r\n    }\r\n\r\n    let selectionPath: SelectionPath = {\r\n        start: getPositionPath(Position.getStart(range), rootNode),\r\n        end: getPositionPath(Position.getEnd(range), rootNode),\r\n    };\r\n\r\n    return selectionPath;\r\n}\r\n\r\n/**\r\n * Get the path of the node relative to rootNode.\r\n * The path of the node is an array of integer indecies into the childNodes of the given node.\r\n *\r\n * The node path will be what the node path will be on a _normalized_ dom\r\n * (e.g. empty text nodes will be ignored and adjacent text nodes will be concatenated)\r\n *\r\n * @param rootNode the node the path will be relative to\r\n * @param position the position to get indexes from. Follows the same semantics\r\n * as selectionRange (if node is of type Text, it is an offset into the text of that node.\r\n * If node is of type Element, it is the index of a child in that Element node.)\r\n */\r\nfunction getPositionPath(position: NodePosition, rootNode: HTMLElement): number[] {\r\n    if (!position || !rootNode) {\r\n        return [];\r\n    }\r\n\r\n    let { node, offset } = position;\r\n    let result: number[] = [];\r\n    let parent: Node;\r\n\r\n    if (!contains(rootNode, node, true)) {\r\n        return [];\r\n    }\r\n\r\n    if (node.nodeType == NodeType.Text) {\r\n        parent = node.parentNode;\r\n        while (node.previousSibling && node.previousSibling.nodeType == NodeType.Text) {\r\n            offset += node.previousSibling.nodeValue.length;\r\n            node = node.previousSibling;\r\n        }\r\n        result.unshift(offset);\r\n    } else {\r\n        parent = node;\r\n        node = node.childNodes[offset];\r\n    }\r\n\r\n    do {\r\n        offset = 0;\r\n        let isPreviousText = false;\r\n\r\n        for (let c: Node = parent.firstChild; c && c != node; c = c.nextSibling) {\r\n            if (c.nodeType == NodeType.Text) {\r\n                if (c.nodeValue.length == 0 || isPreviousText) {\r\n                    continue;\r\n                }\r\n\r\n                isPreviousText = true;\r\n            } else {\r\n                isPreviousText = false;\r\n            }\r\n\r\n            offset++;\r\n        }\r\n\r\n        result.unshift(offset);\r\n        node = parent;\r\n        parent = parent.parentNode;\r\n    } while (node && node != rootNode);\r\n\r\n    return result;\r\n}\r\n","import clearProceedingSnapshots from './clearProceedingSnapshots';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Add a new snapshot to the given snapshots data structure\r\n * @param snapshots The snapshots data structure to add new snapshot into\r\n * @param snapshot The snapshot to add\r\n */\r\nexport default function addSnapshot(snapshots: Snapshots, snapshot: string) {\r\n    if (snapshots.currentIndex < 0 || snapshot != snapshots.snapshots[snapshots.currentIndex]) {\r\n        clearProceedingSnapshots(snapshots);\r\n        snapshots.snapshots.push(snapshot);\r\n        snapshots.currentIndex++;\r\n        snapshots.totalSize += snapshot.length;\r\n\r\n        let removeCount = 0;\r\n        while (\r\n            removeCount < snapshots.snapshots.length &&\r\n            snapshots.totalSize > snapshots.maxSize\r\n        ) {\r\n            snapshots.totalSize -= snapshots.snapshots[removeCount].length;\r\n            removeCount++;\r\n        }\r\n\r\n        if (removeCount > 0) {\r\n            snapshots.snapshots.splice(0, removeCount);\r\n            snapshots.currentIndex -= removeCount;\r\n        }\r\n    }\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Move current snapshot with the given step if can move this step. Otherwise no action and return null\r\n * @param snapshots The snapshots data structure to move\r\n * @param step The step to move\r\n * @returns If can move with the given step, returns the snapshot after move, otherwise null\r\n */\r\nexport default function moveCurrentSnapsnot(snapshots: Snapshots, step: number): string {\r\n    if (canMoveCurrentSnapshot(snapshots, step)) {\r\n        snapshots.currentIndex += step;\r\n        return snapshots.snapshots[snapshots.currentIndex];\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create initial snapshots\r\n * @param maxSize max size of all snapshots\r\n */\r\nexport default function createSnapshots(maxSize: number): Snapshots {\r\n    return {\r\n        snapshots: [],\r\n        totalSize: 0,\r\n        currentIndex: -1,\r\n        maxSize,\r\n    };\r\n}\r\n","import ContentEditFeatures, { getDefaultContentEditFeatures } from './ContentEditFeatures';\r\nimport { AutoLink, UnlinkWhenBackspaceAfterLink } from './features/autoLinkFeatures';\r\nimport { DefaultShortcut } from './features/shortcutFeatures';\r\nimport { Editor, EditorPlugin, GenericContentEditFeature } from 'roosterjs-editor-core';\r\nimport { InsertLineBeforeStructuredNodeFeature } from './features/insertLineBeforeStructuredNodeFeature';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\nimport { TabInTable, UpDownInTable } from './features/tableFeatures';\r\n\r\nimport {\r\n    AutoBullet,\r\n    IndentWhenTab,\r\n    OutdentWhenShiftTab,\r\n    MergeInNewLine,\r\n    OutdentWhenBackOn1stEmptyLine,\r\n    OutdentWhenEnterOnEmptyLine,\r\n    getSmartOrderedList,\r\n} from './features/listFeatures';\r\nimport {\r\n    UnquoteWhenBackOnEmpty1stLine,\r\n    UnquoteWhenEnterOnEmptyLine,\r\n} from './features/quoteFeatures';\r\n\r\n/**\r\n * An editor plugin to handle content edit event.\r\n * The following cases are included:\r\n * 1. Auto increase/decrease indentation on Tab, Shift+tab\r\n * 2. Enter, Backspace on empty list item\r\n * 3. Enter, Backspace on empty blockquote line\r\n * 4. Auto bullet/numbering\r\n * 5. Auto link\r\n * 6. Tab in table\r\n * 7. Up/Down in table\r\n * 8. Manage list style\r\n */\r\nexport default class ContentEdit implements EditorPlugin {\r\n    private editor: Editor;\r\n\r\n    /**\r\n     * Create instance of ContentEdit plugin\r\n     * @param features An optional feature set to determine which features the plugin should provide\r\n     */\r\n    constructor(private featureSet?: ContentEditFeatures) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'ContentEdit';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin\r\n     * @param editor The editor instance\r\n     */\r\n    public initialize(editor: Editor): void {\r\n        this.editor = editor;\r\n        this.getFilteredFeatures().forEach(feature => this.editor.addContentEditFeature(feature));\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose(): void {\r\n        this.editor = null;\r\n    }\r\n\r\n    private getFilteredFeatures(): GenericContentEditFeature<PluginEvent>[] {\r\n        let featureSet = this.featureSet || getDefaultContentEditFeatures();\r\n        let allFeatures: {\r\n            [key in keyof Partial<ContentEditFeatures>]: GenericContentEditFeature<PluginEvent>\r\n        } = {\r\n            indentWhenTab: IndentWhenTab,\r\n            outdentWhenShiftTab: OutdentWhenShiftTab,\r\n            outdentWhenBackspaceOnEmptyFirstLine: OutdentWhenBackOn1stEmptyLine,\r\n            outdentWhenEnterOnEmptyLine: OutdentWhenEnterOnEmptyLine,\r\n            mergeInNewLineWhenBackspaceOnFirstChar: MergeInNewLine,\r\n            unquoteWhenBackspaceOnEmptyFirstLine: UnquoteWhenBackOnEmpty1stLine,\r\n            unquoteWhenEnterOnEmptyLine: UnquoteWhenEnterOnEmptyLine,\r\n            tabInTable: TabInTable,\r\n            upDownInTable: UpDownInTable,\r\n            insertLineBeforeStructuredNodeFeature: InsertLineBeforeStructuredNodeFeature,\r\n            autoBullet: AutoBullet,\r\n            autoLink: AutoLink,\r\n            unlinkWhenBackspaceAfterLink: UnlinkWhenBackspaceAfterLink,\r\n            defaultShortcut: DefaultShortcut,\r\n            smartOrderedList: getSmartOrderedList(featureSet.smartOrderedListStyles),\r\n        };\r\n        let keys = Object.keys(allFeatures) as (keyof ContentEditFeatures)[];\r\n        return keys.filter(key => featureSet[key]).map(key => allFeatures[key]);\r\n    }\r\n}\r\n","import { LinkInlineElement, matchLink } from 'roosterjs-editor-dom';\r\nimport { removeLink, replaceWithNode } from 'roosterjs-editor-api';\r\nimport {\r\n    ChangeSource,\r\n    LinkData,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginKeyboardEvent,\r\n    ClipboardData,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    Editor,\r\n    cacheGetEventData,\r\n    cacheGetContentSearcher,\r\n    clearContentSearcherCache,\r\n    GenericContentEditFeature,\r\n    Keys,\r\n} from 'roosterjs-editor-core';\r\n\r\n/**\r\n * When user type, they may end a link with a puncatuation, i.e. www.bing.com;\r\n * we need to trim off the trailing puncatuation before turning it to link match\r\n */\r\nconst TRAILING_PUNCTUATION_REGEX = /[.+=\\s:;\"',>]+$/i;\r\nconst MINIMUM_LENGTH = 5;\r\n\r\n/**\r\n * AutoLink edit feature, provides the ability to automatically convert text user typed or pasted\r\n * in hyperlink format into a real hyperlink\r\n */\r\nexport const AutoLink: GenericContentEditFeature<PluginEvent> = {\r\n    keys: [Keys.ENTER, Keys.SPACE, Keys.CONTENTCHANGED],\r\n    shouldHandleEvent: cacheGetLinkData,\r\n    handleEvent: autoLink,\r\n};\r\n\r\n/**\r\n * UnlinkWhenBackspaceAfterLink edit feature, provides the ability to convert a hyperlink back into text\r\n * if user presses BACKSPACE right after a hyperlink\r\n */\r\nexport const UnlinkWhenBackspaceAfterLink: GenericContentEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: hasLinkBeforeCursor,\r\n    handleEvent: (event, editor) => {\r\n        event.rawEvent.preventDefault();\r\n        removeLink(editor);\r\n    },\r\n};\r\n\r\nfunction cacheGetLinkData(event: PluginEvent, editor: Editor): LinkData {\r\n    return event.eventType == PluginEventType.KeyDown ||\r\n        (event.eventType == PluginEventType.ContentChanged && event.source == ChangeSource.Paste)\r\n        ? cacheGetEventData(event, 'LINK_DATA', () => {\r\n              // First try to match link from the whole paste string from the plain text in clipboard.\r\n              // This helps when we paste a link next to some existing character, and the text we got\r\n              // from clipboard will only contain what we pasted, any existing characters will not\r\n              // be included.\r\n              let clipboardData =\r\n                  event.eventType == PluginEventType.ContentChanged &&\r\n                  event.source == ChangeSource.Paste &&\r\n                  (event.data as ClipboardData);\r\n              let link = matchLink((clipboardData.text || '').trim());\r\n              let searcher = cacheGetContentSearcher(event, editor);\r\n\r\n              // In case the matched link is already inside a <A> tag, we do a range search.\r\n              // getRangeFromText will return null if the given text is already in a LinkInlineElement\r\n              if (link && searcher.getRangeFromText(link.originalUrl, false /*exactMatch*/)) {\r\n                  return link;\r\n              }\r\n\r\n              let word = searcher && searcher.getWordBefore();\r\n              if (word && word.length > MINIMUM_LENGTH) {\r\n                  // Check for trailing punctuation\r\n                  let trailingPunctuations = word.match(TRAILING_PUNCTUATION_REGEX);\r\n                  let trailingPunctuation = (trailingPunctuations || [])[0] || '';\r\n                  let candidate = word.substring(0, word.length - trailingPunctuation.length);\r\n\r\n                  // Do special handling for ')', '}', ']'\r\n                  ['()', '{}', '[]'].forEach(str => {\r\n                      if (\r\n                          candidate[candidate.length - 1] == str[1] &&\r\n                          candidate.indexOf(str[0]) < 0\r\n                      ) {\r\n                          candidate = candidate.substr(0, candidate.length - 1);\r\n                      }\r\n                  });\r\n\r\n                  // Match and replace in editor\r\n                  return matchLink(candidate);\r\n              }\r\n              return null;\r\n          })\r\n        : null;\r\n}\r\n\r\nfunction hasLinkBeforeCursor(event: PluginKeyboardEvent, editor: Editor): boolean {\r\n    let contentSearcher = cacheGetContentSearcher(event, editor);\r\n    let inline = contentSearcher.getInlineElementBefore();\r\n    return inline instanceof LinkInlineElement;\r\n}\r\n\r\nfunction autoLink(event: PluginEvent, editor: Editor) {\r\n    let anchor = editor.getDocument().createElement('a');\r\n    let linkData = cacheGetLinkData(event, editor);\r\n\r\n    // Need to get searcher before we enter the async callback since the callback can happen when cursor is moved to next line\r\n    // and at that time a new searcher won't be able to find the link text to replace\r\n    let searcher = editor.getContentSearcherOfCursor();\r\n    anchor.textContent = linkData.originalUrl;\r\n    anchor.href = linkData.normalizedUrl;\r\n\r\n    editor.runAsync(() => {\r\n        editor.performAutoComplete(() => {\r\n            replaceWithNode(editor, linkData.originalUrl, anchor, false /* exactMatch */, searcher);\r\n\r\n            // The content at cursor has changed. Should also clear the cursor data cache\r\n            clearContentSearcherCache(event);\r\n            return anchor;\r\n        }, ChangeSource.AutoLink);\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FontSizeChange } from 'roosterjs-editor-types';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Default font size sequence, in pt. Suggest editor UI use this sequence as your font size list,\r\n * So that when increase/decrease font size, the font size can match the sequence of your font size picker\r\n */\r\nexport const FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];\r\nconst MIN_FONT_SIZE = 1;\r\nconst MAX_FONT_SIZE = 1000;\r\n\r\n/**\r\n * Increase or decrease font size in selection\r\n * @param editor The editor instance\r\n * @param change Whether increase or decrease font size\r\n * @param fontSizes A sorted font size array, in pt. Default value is FONT_SIZES\r\n */\r\nexport default function changeFontSize(\r\n    editor: Editor,\r\n    change: FontSizeChange,\r\n    fontSizes: number[] = FONT_SIZES\r\n) {\r\n    let changeBase: 1 | -1 = change == FontSizeChange.Increase ? 1 : -1;\r\n    applyInlineStyle(editor, element => {\r\n        let pt = parseFloat(getComputedStyle(element, 'font-size'));\r\n        element.style.fontSize = getNewFontSize(pt, changeBase, fontSizes) + 'pt';\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n\r\nexport function getNewFontSize(pt: number, changeBase: 1 | -1, fontSizes: number[]): number {\r\n    pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n    let last = fontSizes[fontSizes.length - 1];\r\n    if (pt <= fontSizes[0]) {\r\n        pt = Math.max(pt + changeBase, MIN_FONT_SIZE);\r\n    } else if (pt > last || (pt == last && changeBase == 1)) {\r\n        pt = pt / 10;\r\n        pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n        pt = Math.min(Math.max((pt + changeBase) * 10, last), MAX_FONT_SIZE);\r\n    } else if (changeBase == 1) {\r\n        for (let i = 0; i < fontSizes.length; i++) {\r\n            if (pt < fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = fontSizes.length - 1; i >= 0; i--) {\r\n            if (pt > fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return pt;\r\n}\r\n","import collapseSelectedBlocks from '../utils/collapseSelectedBlocks';\r\nimport { ChangeSource, NodeType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    getTagOfNode,\r\n    isBlockElement,\r\n    unwrap,\r\n    wrap,\r\n    splitBalancedNodeRange,\r\n} from 'roosterjs-editor-dom';\r\n\r\nexport const TAGS_TO_UNWRAP = 'B,I,U,STRONG,EM,SUB,SUP,STRIKE,FONT,CENTER,H1,H2,H3,H4,H5,H6,UL,OL,LI,SPAN,P,BLOCKQUOTE,CODE,S,PRE'.split(\r\n    ','\r\n);\r\nexport const TAGS_TO_STOP_UNWRAP = ['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'];\r\nexport const ATTRIBUTES_TO_PRESERVE = ['href'];\r\n\r\n/**\r\n * Clear all formats of selected blocks.\r\n * When selection is collapsed, only clear format of current block.\r\n * @param editor The editor instance\r\n * @param tagsToUnwrap Optional. A string array contains HTML tags in upper case which we will unwrap when clear format\r\n * @param tagsToStopUnwrap Optional. A string array contains HTML tags in upper case which we will stop unwrap if these tags are hit\r\n */\r\nexport default function clearBlockFormat(\r\n    editor: Editor,\r\n    tagsToUnwrap: string[] = TAGS_TO_UNWRAP,\r\n    tagsToStopUnwrap: string[] = TAGS_TO_STOP_UNWRAP,\r\n    attributesToPreserve: string[] = ATTRIBUTES_TO_PRESERVE\r\n) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        let groups: {\r\n            first?: HTMLElement;\r\n            last?: HTMLElement;\r\n            td?: HTMLElement;\r\n        }[] = [{}];\r\n        let stopUnwrapSelector = tagsToStopUnwrap.join(',');\r\n\r\n        // 1. Collapse the selected blocks and get first and last element\r\n        collapseSelectedBlocks(editor, element => {\r\n            let group = groups[groups.length - 1];\r\n            let td = editor.getElementAtCursor(stopUnwrapSelector, element);\r\n            if (td != group.td && group.first) {\r\n                groups.push((group = {}));\r\n            }\r\n\r\n            group.td = td;\r\n            group.first = group.first || element;\r\n            group.last = element;\r\n        });\r\n\r\n        groups\r\n            .filter(group => group.first)\r\n            .forEach(group => {\r\n                // 2. Collapse with first and last element to make them under same parent\r\n                let nodes = editor.collapseNodes(group.first, group.last, true /*canSplitParent*/);\r\n\r\n                // 3. Continue collapse until we can't collapse any more (hit root node, or a table)\r\n                if (canCollapse(tagsToStopUnwrap, nodes[0])) {\r\n                    while (\r\n                        editor.contains(nodes[0].parentNode) &&\r\n                        canCollapse(tagsToStopUnwrap, nodes[0].parentNode as HTMLElement)\r\n                    ) {\r\n                        nodes = [splitBalancedNodeRange(nodes)];\r\n                    }\r\n                }\r\n\r\n                // 4. Clear formats of the nodes\r\n                nodes.forEach(node =>\r\n                    clearNodeFormat(\r\n                        node as HTMLElement,\r\n                        tagsToUnwrap,\r\n                        tagsToStopUnwrap,\r\n                        attributesToPreserve\r\n                    )\r\n                );\r\n\r\n                // 5. Clear CSS of container TD if exist\r\n                if (group.td) {\r\n                    let styles = group.td.getAttribute('style') || '';\r\n                    let styleArray = styles.split(';');\r\n                    styleArray = styleArray.filter(\r\n                        style =>\r\n                            style\r\n                                .trim()\r\n                                .toLowerCase()\r\n                                .indexOf('border') == 0\r\n                    );\r\n                    styles = styleArray.join(';');\r\n                    if (styles) {\r\n                        group.td.setAttribute('style', styles);\r\n                    } else {\r\n                        group.td.removeAttribute('style');\r\n                    }\r\n                }\r\n            });\r\n\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n\r\nfunction clearNodeFormat(\r\n    node: Node,\r\n    tagsToUnwrap: string[],\r\n    tagsToStopUnwrap: string[],\r\n    attributesToPreserve: string[]\r\n): boolean {\r\n    if (node.nodeType != NodeType.Element || getTagOfNode(node) == 'BR') {\r\n        return false;\r\n    }\r\n\r\n    // 1. Recursively clear format of all its child nodes\r\n    let allChildrenAreBlock = ([].slice.call(node.childNodes) as Node[])\r\n        .map(n => clearNodeFormat(n, tagsToUnwrap, tagsToStopUnwrap, attributesToPreserve))\r\n        .reduce((previousValue, value) => previousValue && value, true);\r\n\r\n    if (!canCollapse(tagsToStopUnwrap, node)) {\r\n        return false;\r\n    }\r\n\r\n    let returnBlockElement = isBlockElement(node);\r\n\r\n    // 2. If we should unwrap this tag, put it into an array and unwrap it later\r\n    if (tagsToUnwrap.indexOf(getTagOfNode(node)) >= 0 || allChildrenAreBlock) {\r\n        if (returnBlockElement && !allChildrenAreBlock) {\r\n            wrap(node);\r\n        }\r\n        unwrap(node);\r\n    } else {\r\n        // 3. Otherwise, remove all attributes\r\n        clearAttribute(node as HTMLElement, attributesToPreserve);\r\n    }\r\n\r\n    return returnBlockElement;\r\n}\r\n\r\nfunction clearAttribute(element: HTMLElement, attributesToPreserve: string[]) {\r\n    for (let attr of [].slice.call(element.attributes) as Attr[]) {\r\n        if (\r\n            attributesToPreserve.indexOf(attr.name.toLowerCase()) < 0 &&\r\n            attr.name.indexOf('data-') != 0\r\n        ) {\r\n            element.removeAttribute(attr.name);\r\n        }\r\n    }\r\n}\r\n\r\nfunction canCollapse(tagsToStopUnwrap: string[], node: Node) {\r\n    return tagsToStopUnwrap.indexOf(getTagOfNode(node)) < 0;\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport setBackgroundColor from './setBackgroundColor';\r\nimport setFontName from './setFontName';\r\nimport setFontSize from './setFontSize';\r\nimport setTextColor from './setTextColor';\r\nimport toggleBold from './toggleBold';\r\nimport toggleItalic from './toggleItalic';\r\nimport toggleUnderline from './toggleUnderline';\r\nimport { ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\nconst STYLES_TO_REMOVE = ['font', 'text-decoration', 'color', 'background'];\r\n\r\n/**\r\n * Clear the format in current selection, after cleaning, the format will be\r\n * changed to default format. The format that get cleaned include B/I/U/font name/\r\n * font size/text color/background color/align left/align right/align center/superscript/subscript\r\n * @param editor The editor instance\r\n */\r\nexport default function clearFormat(editor: Editor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, DocumentCommand.RemoveFormat);\r\n\r\n        editor.queryElements('[class]', QueryScope.OnSelection, node =>\r\n            node.removeAttribute('class')\r\n        );\r\n\r\n        const defaultFormat = editor.getDefaultFormat();\r\n        const isDefaultFormatEmpty = Object.keys(defaultFormat).length === 0;\r\n        editor.queryElements('[style]', QueryScope.InSelection, node => {\r\n            STYLES_TO_REMOVE.forEach(style => node.style.removeProperty(style));\r\n\r\n            // when default format is empty, keep the HTML minimum by removing style attribute if there's no style\r\n            // (note: because default format is empty, we're not adding style back in)\r\n            if (isDefaultFormatEmpty && node.getAttribute('style') === '') {\r\n                node.removeAttribute('style');\r\n            }\r\n        });\r\n\r\n        if (!isDefaultFormatEmpty) {\r\n            if (defaultFormat.fontFamily) {\r\n                setFontName(editor, defaultFormat.fontFamily);\r\n            }\r\n            if (defaultFormat.fontSize) {\r\n                setFontSize(editor, defaultFormat.fontSize);\r\n            }\r\n            if (defaultFormat.textColor) {\r\n                if (defaultFormat.textColors) {\r\n                    setTextColor(editor, defaultFormat.textColors);\r\n                } else {\r\n                    setTextColor(editor, defaultFormat.textColor);\r\n                }\r\n            }\r\n            if (defaultFormat.backgroundColor) {\r\n                if (defaultFormat.backgroundColors) {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColors);\r\n                } else {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColor);\r\n                }\r\n            }\r\n            if (defaultFormat.bold) {\r\n                toggleBold(editor);\r\n            }\r\n            if (defaultFormat.italic) {\r\n                toggleItalic(editor);\r\n            }\r\n            if (defaultFormat.underline) {\r\n                toggleUnderline(editor);\r\n            }\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { matchLink } from 'roosterjs-editor-dom';\r\n\r\n// Regex matching Uri scheme\r\nconst URI_REGEX = /^[a-zA-Z]+:/i;\r\n// Regex matching begin of email address\r\nconst MAILTO_REGEX = /^[\\w.%+-]+@/i;\r\n// Regex matching begin of ftp, i.e. ftp.microsoft.com\r\nconst FTP_REGEX = /^ftp\\./i;\r\nconst TEMP_TITLE = 'istemptitle';\r\n\r\nfunction applyLinkPrefix(url: string): string {\r\n    if (!url) {\r\n        return url;\r\n    }\r\n\r\n    // Add link prefix per rule:\r\n    // (a) if the url always starts with a URI scheme, leave it as it is\r\n    // (b) if the url is an email address, xxx@... add mailto: prefix\r\n    // (c) if the url starts with ftp., add ftp:// prefix\r\n    // (d) rest, add http:// prefix\r\n    let prefix = '';\r\n    if (url.search(URI_REGEX) < 0) {\r\n        if (url.search(MAILTO_REGEX) == 0) {\r\n            prefix = 'mailto:';\r\n        } else if (url.search(FTP_REGEX) == 0) {\r\n            prefix = 'ftp://';\r\n        } else {\r\n            // fallback to http://\r\n            prefix = 'http://';\r\n        }\r\n    }\r\n\r\n    return prefix + url;\r\n}\r\n\r\n/**\r\n * Insert a hyperlink at cursor.\r\n * When there is a selection, hyperlink will be applied to the selection,\r\n * otherwise a hyperlink will be inserted to the cursor position.\r\n * @param editor Editor object\r\n * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.\r\n * When protocol is not specified, a best matched protocol will be predicted.\r\n * @param altText Optional alt text of the link, will be shown when hover on the link\r\n * @param displayText Optional display text for the link.\r\n * If specified, the display text of link will be replaced with this text.\r\n * If not specified and there wasn't a link, the link url will be used as display text.\r\n */\r\nexport default function createLink(\r\n    editor: Editor,\r\n    link: string,\r\n    altText?: string,\r\n    displayText?: string\r\n) {\r\n    editor.focus();\r\n    let url = link ? link.trim() : '';\r\n    if (url) {\r\n        let linkData = matchLink(url);\r\n        // matchLink can match most links, but not all, i.e. if you pass link a link as \"abc\", it won't match\r\n        // we know in that case, users will want to insert a link like http://abc\r\n        // so we have separate logic in applyLinkPrefix to add link prefix depending on the format of the link\r\n        // i.e. if the link starts with something like abc@xxx, we will add mailto: prefix\r\n        // if the link starts with ftp.xxx, we will add ftp:// link. For more, see applyLinkPrefix\r\n        let normalizedUrl = linkData ? linkData.normalizedUrl : applyLinkPrefix(url);\r\n        let originalUrl = linkData ? linkData.originalUrl : url;\r\n\r\n        editor.addUndoSnapshot(() => {\r\n            let range = editor.getSelectionRange();\r\n            let anchor: HTMLAnchorElement = null;\r\n            if (range && range.collapsed) {\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n\r\n                // If there is already a link, just change its href\r\n                if (anchor) {\r\n                    anchor.href = normalizedUrl;\r\n                    // Change text content if it is specified\r\n                    updateAnchorDisplayText(anchor, displayText);\r\n                } else {\r\n                    anchor = editor.getDocument().createElement('A') as HTMLAnchorElement;\r\n                    anchor.textContent = displayText || originalUrl;\r\n                    anchor.href = normalizedUrl;\r\n                    editor.insertNode(anchor);\r\n                }\r\n            } else {\r\n                // the selection is not collapsed, use browser execCommand\r\n                editor.getDocument().execCommand(DocumentCommand.CreateLink, false, normalizedUrl);\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n                updateAnchorDisplayText(anchor, displayText);\r\n            }\r\n            if (altText && anchor) {\r\n                // Hack: Ideally this should be done by HyperLink plugin.\r\n                // We make a hack here since we don't have an event to notify HyperLink plugin\r\n                // before we apply the link.\r\n                anchor.removeAttribute(TEMP_TITLE);\r\n                anchor.title = altText;\r\n            }\r\n            return anchor;\r\n        }, ChangeSource.CreateLink);\r\n    }\r\n}\r\n\r\nfunction getAnchorNodeAtCursor(editor: Editor): HTMLAnchorElement {\r\n    return editor.queryElements('a[href]', QueryScope.OnSelection)[0] as HTMLAnchorElement;\r\n}\r\n\r\nfunction updateAnchorDisplayText(anchor: HTMLAnchorElement, displayText: string) {\r\n    if (displayText && anchor.textContent != displayText) {\r\n        anchor.textContent = displayText;\r\n    }\r\n}\r\n","import { cacheGetElementAtCursor, Editor } from 'roosterjs-editor-core';\r\nimport { getComputedStyles, getTagOfNode, Position } from 'roosterjs-editor-dom';\r\nimport { getPendableFormatState } from 'roosterjs-editor-dom';\r\nimport {\r\n    ElementBasedFormatState,\r\n    FormatState,\r\n    PluginEvent,\r\n    QueryScope,\r\n    StyleBasedFormatState,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get element based Format State at cursor\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns An ElementBasedFormatState object\r\n */\r\nexport function getElementBasedFormatState(\r\n    editor: Editor,\r\n    event?: PluginEvent\r\n): ElementBasedFormatState {\r\n    let listTag = getTagOfNode(cacheGetElementAtCursor(editor, event, 'OL,UL'));\r\n    let headerTag = getTagOfNode(cacheGetElementAtCursor(editor, event, 'H1,H2,H3,H4,H5,H6'));\r\n\r\n    let xel = cacheGetElementAtCursor(\r\n        editor,\r\n        event,\r\n        'DIV,OL,UL,LI,H1,H2,H3,H4,H5,H6,P,BLOCKQUOTE'\r\n    ) as HTMLElement;\r\n\r\n    let alignStyle = 'left';\r\n    if (null !== xel) {\r\n        do {\r\n            if (xel.style.textAlign != '') {\r\n                alignStyle = xel.style.textAlign;\r\n                break;\r\n            }\r\n            xel = xel.parentElement;\r\n        } while (!editor.isContentDiv(xel));\r\n    }\r\n\r\n    return {\r\n        isBullet: listTag == 'UL',\r\n        isNumbering: listTag == 'OL',\r\n        headerLevel: (headerTag && parseInt(headerTag[1])) || 0,\r\n\r\n        canUnlink: !!editor.queryElements('a[href]', QueryScope.OnSelection)[0],\r\n        canAddImageAltText: !!editor.queryElements('img', QueryScope.OnSelection)[0],\r\n        isBlockQuote: !!editor.queryElements('blockquote', QueryScope.OnSelection)[0],\r\n\r\n        alignLeft: alignStyle == 'left',\r\n        alignCenter: alignStyle == 'center',\r\n        alignRight: alignStyle == 'right',\r\n        alignJustify: alignStyle == 'justify',\r\n    };\r\n}\r\n\r\n/**\r\n * Get style based Format State at cursor\r\n * @param editor The editor instance\r\n * @returns A StyleBasedFormatState object\r\n */\r\nexport function getStyleBasedFormatState(editor: Editor): StyleBasedFormatState {\r\n    let range = editor.getSelectionRange();\r\n    let node = range && Position.getStart(range).normalize().node;\r\n    let styles = node ? getComputedStyles(node) : [];\r\n    return {\r\n        fontName: styles[0],\r\n        fontSize: styles[1],\r\n        textColor: styles[2],\r\n        backgroundColor: styles[3],\r\n    };\r\n}\r\n\r\n/**\r\n * Get format state at cursor\r\n * A format state is a collection of all format related states, e.g.,\r\n * bold, italic, underline, font name, font size, etc.\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns The format state at cursor\r\n */\r\nexport default function getFormatState(editor: Editor, event?: PluginEvent): FormatState {\r\n    return {\r\n        ...getPendableFormatState(editor.getDocument()),\r\n        ...getElementBasedFormatState(editor, event),\r\n        ...getStyleBasedFormatState(editor),\r\n        canUndo: editor.canUndo(),\r\n        canRedo: editor.canRedo(),\r\n    };\r\n}\r\n","import adjustBrowserBehavior from './adjustBrowserBehavior';\r\nimport createEditorCore from './createEditorCore';\r\nimport EditorCore from '../interfaces/EditorCore';\r\nimport EditorOptions from '../interfaces/EditorOptions';\r\nimport getColorNormalizedContent from '../darkMode/getColorNormalizedContent';\r\nimport mapPluginEvents from './mapPluginEvents';\r\nimport { calculateDefaultFormat } from '../coreAPI/calculateDefaultFormat';\r\nimport { convertContentToDarkMode } from '../darkMode/convertContentToDarkMode';\r\nimport { GenericContentEditFeature } from '../interfaces/ContentEditFeature';\r\nimport {\r\n    BlockElement,\r\n    ChangeSource,\r\n    ContentPosition,\r\n    DarkModeOptions,\r\n    DefaultFormat,\r\n    InlineElement,\r\n    InsertOption,\r\n    NodePosition,\r\n    NodeType,\r\n    PluginEvent,\r\n    PluginEventData,\r\n    PluginEventFromType,\r\n    PluginEventType,\r\n    PositionType,\r\n    QueryScope,\r\n    SelectionPath,\r\n    Rect,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodes,\r\n    contains,\r\n    ContentTraverser,\r\n    createRange,\r\n    findClosestElementAncestor,\r\n    fromHtml,\r\n    getBlockElementAtNode,\r\n    getTextContent,\r\n    getInlineElementAtNode,\r\n    getPositionRect,\r\n    getRangeFromSelectionPath,\r\n    getSelectionPath,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    Position,\r\n    PositionContentSearcher,\r\n    queryElements,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * RoosterJs core editor class\r\n */\r\nexport default class Editor {\r\n    private core: EditorCore;\r\n    private eventDisposers: (() => void)[];\r\n    private contenteditableChanged: boolean;\r\n\r\n    //#region Lifecycle\r\n\r\n    /**\r\n     * Creates an instance of Editor\r\n     * @param contentDiv The DIV HTML element which will be the container element of editor\r\n     * @param options An optional options object to customize the editor\r\n     */\r\n    constructor(contentDiv: HTMLDivElement, options: EditorOptions = {}) {\r\n        // 1. Make sure all parameters are valid\r\n        if (getTagOfNode(contentDiv) != 'DIV') {\r\n            throw new Error('contentDiv must be an HTML DIV element');\r\n        }\r\n\r\n        // 2. Store options values to local variables\r\n        this.core = createEditorCore(contentDiv, options);\r\n\r\n        // 3. Initialize plugins\r\n        this.core.plugins.forEach(plugin => plugin.initialize(this));\r\n\r\n        // 4. Ensure initial content and its format\r\n        this.setContent(\r\n            options.initialContent || contentDiv.innerHTML || '',\r\n            false /*triggerContentChangedEvent*/\r\n        );\r\n\r\n        // 5. Create event handler to bind DOM events\r\n        this.eventDisposers = mapPluginEvents(this.core);\r\n\r\n        // 6. Add additional content edit features to the editor if specified\r\n        if (options.additionalEditFeatures) {\r\n            options.additionalEditFeatures.forEach(feature => this.addContentEditFeature(feature));\r\n        }\r\n\r\n        // 7. Make the container editable and set its selection styles\r\n        if (!options.omitContentEditableAttributeChanges && !contentDiv.isContentEditable) {\r\n            contentDiv.setAttribute('contenteditable', 'true');\r\n            let styles = contentDiv.style;\r\n            styles.userSelect = styles.msUserSelect = styles.webkitUserSelect = 'text';\r\n            this.contenteditableChanged = true;\r\n        }\r\n\r\n        // 8. Do proper change for browsers to disable some browser-specified behaviors.\r\n        adjustBrowserBehavior();\r\n\r\n        // 9. Let plugins know that we are ready\r\n        this.triggerPluginEvent(PluginEventType.EditorReady, {}, true /*broadcast*/);\r\n\r\n        // 10. Before give editor to user, make sure there is at least one DIV element to accept typing\r\n        this.core.corePlugins.typeInContainer.ensureTypeInElement(\r\n            new Position(contentDiv, PositionType.Begin)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Is given div contentDiv\r\n     * @param div\r\n     */\r\n    public isContentDiv(div: HTMLElement): boolean {\r\n        return this.core.contentDiv == div;\r\n    }\r\n\r\n    /**\r\n     * Dispose this editor, dispose all plugins and custom data\r\n     */\r\n    public dispose(): void {\r\n        this.triggerPluginEvent(PluginEventType.BeforeDispose, {}, true /*broadcast*/);\r\n\r\n        this.core.plugins.forEach(plugin => plugin.dispose());\r\n        this.eventDisposers.forEach(disposer => disposer());\r\n        this.eventDisposers = null;\r\n\r\n        for (let key of Object.keys(this.core.customData)) {\r\n            let data = this.core.customData[key];\r\n            if (data && data.disposer) {\r\n                data.disposer(data.value);\r\n            }\r\n            delete this.core.customData[key];\r\n        }\r\n\r\n        if (this.contenteditableChanged) {\r\n            let styles = this.core.contentDiv.style;\r\n            styles.userSelect = styles.msUserSelect = styles.webkitUserSelect = '';\r\n            this.core.contentDiv.removeAttribute('contenteditable');\r\n        }\r\n\r\n        this.core = null;\r\n    }\r\n\r\n    /**\r\n     * Get whether this editor is disposed\r\n     * @returns True if editor is disposed, otherwise false\r\n     */\r\n    public isDisposed(): boolean {\r\n        return !this.core;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Node API\r\n\r\n    /**\r\n     * Insert node into editor\r\n     * @param node The node to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     * @returns true if node is inserted. Otherwise false\r\n     */\r\n    public insertNode(node: Node, option?: InsertOption): boolean {\r\n        // DocumentFragment type nodes become empty after they're inserted.\r\n        // Therefore, we get the list of nodes to transform prior to their insertion.\r\n        const darkModeOptions = this.getDarkModeOptions();\r\n        const darkModeTransform = this.isDarkMode()\r\n            ? convertContentToDarkMode(\r\n                  node,\r\n                  darkModeOptions && darkModeOptions.onExternalContentTransform\r\n                      ? darkModeOptions.onExternalContentTransform\r\n                      : undefined\r\n              )\r\n            : null;\r\n\r\n        const result = node ? this.core.api.insertNode(this.core, node, option) : false;\r\n\r\n        if (result && darkModeTransform) {\r\n            darkModeTransform();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Delete a node from editor content\r\n     * @param node The node to delete\r\n     * @returns true if node is deleted. Otherwise false\r\n     */\r\n    public deleteNode(node: Node): boolean {\r\n        // Only remove the node when it falls within editor\r\n        if (node && this.contains(node)) {\r\n            node.parentNode.removeChild(node);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Replace a node in editor content with another node\r\n     * @param existingNode The existing node to be replaced\r\n     * @param new node to replace to\r\n     * @returns true if node is replaced. Otherwise false\r\n     */\r\n    public replaceNode(existingNode: Node, toNode: Node): boolean {\r\n        // Only replace the node when it falls within editor\r\n        if (existingNode && toNode && this.contains(existingNode)) {\r\n            existingNode.parentNode.replaceChild(toNode, existingNode);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get InlineElement at given node\r\n     * @param node The node to create InlineElement\r\n     * @returns The InlineElement result\r\n     */\r\n    public getInlineElementAtNode(node: Node): InlineElement {\r\n        return getInlineElementAtNode(this.core.contentDiv, node);\r\n    }\r\n\r\n    /**\r\n     * Get BlockElement at given node\r\n     * @param node The node to create InlineElement\r\n     * @returns The BlockElement result\r\n     */\r\n    public getBlockElementAtNode(node: Node): BlockElement {\r\n        return getBlockElementAtNode(this.core.contentDiv, node);\r\n    }\r\n\r\n    /**\r\n     * Check if the node falls in the editor content\r\n     * @param node The node to check\r\n     * @returns True if the given node is in editor content, otherwise false\r\n     */\r\n    public contains(node: Node): boolean;\r\n\r\n    /**\r\n     * Check if the range falls in the editor content\r\n     * @param range The range to check\r\n     * @returns True if the given range is in editor content, otherwise false\r\n     */\r\n    public contains(range: Range): boolean;\r\n\r\n    public contains(arg: Node | Range): boolean {\r\n        return contains(this.core.contentDiv, <Node>arg);\r\n    }\r\n\r\n    /**\r\n     * Query HTML elements in editor by tag name\r\n     * @param tag Tag name of the element to query\r\n     * @param forEachCallback An optional callback to be invoked on each element in query result\r\n     * @returns HTML Element array of the query result\r\n     */\r\n    public queryElements<T extends keyof HTMLElementTagNameMap>(\r\n        tag: T,\r\n        forEachCallback?: (node: HTMLElementTagNameMap[T]) => any\r\n    ): HTMLElementTagNameMap[T][];\r\n\r\n    /**\r\n     * Query HTML elements in editor by a selector string\r\n     * @param selector Selector string to query\r\n     * @param forEachCallback An optional callback to be invoked on each node in query result\r\n     * @returns HTML Element array of the query result\r\n     */\r\n    public queryElements<T extends HTMLElement = HTMLElement>(\r\n        selector: string,\r\n        forEachCallback?: (node: T) => any\r\n    ): T[];\r\n\r\n    /**\r\n     * Query HTML elements with the given scope by tag name\r\n     * @param tag Tag name of the element to query\r\n     * @param scope The scope of the query, default value is QueryScope.Body\r\n     * @param forEachCallback An optional callback to be invoked on each element in query result\r\n     * @returns HTML Element list of the query result\r\n     */\r\n    public queryElements<T extends keyof HTMLElementTagNameMap>(\r\n        tag: T,\r\n        scope: QueryScope,\r\n        forEachCallback?: (node: HTMLElementTagNameMap[T]) => any\r\n    ): HTMLElementTagNameMap[T][];\r\n\r\n    /**\r\n     * Query HTML elements with the given scope by a selector string\r\n     * @param selector Selector string to query\r\n     * @param scope The scope of the query, default value is QueryScope.Body\r\n     * @param forEachCallback An optional callback to be invoked on each element in query result\r\n     * @returns HTML Element array of the query result\r\n     */\r\n    public queryElements<T extends HTMLElement = HTMLElement>(\r\n        selector: string,\r\n        scope: QueryScope,\r\n        forEachCallback?: (node: T) => any\r\n    ): T[];\r\n\r\n    public queryElements(\r\n        selector: string,\r\n        scopeOrCallback: QueryScope | ((node: Node) => any) = QueryScope.Body,\r\n        callback?: (node: Node) => any\r\n    ) {\r\n        let scope = scopeOrCallback instanceof Function ? QueryScope.Body : scopeOrCallback;\r\n        callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;\r\n\r\n        let range = scope == QueryScope.Body ? null : this.getSelectionRange();\r\n        return queryElements(this.core.contentDiv, selector, callback, scope, range);\r\n    }\r\n\r\n    /**\r\n     * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n     * split parent nodes if necessary\r\n     * @param start The start node\r\n     * @param end The end node\r\n     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n     * and the returned nodes will be all nodes from start trhough end after splitting\r\n     * False to disallow split parent\r\n     * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n     * otherwise just return start and end\r\n     */\r\n    public collapseNodes(start: Node, end: Node, canSplitParent: boolean): Node[] {\r\n        return collapseNodes(this.core.contentDiv, start, end, canSplitParent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Content API\r\n\r\n    /**\r\n     * Check whether the editor contains any visible content\r\n     * @param trim Whether trime the content string before check. Default is false\r\n     * @returns True if there's no visible content, otherwise false\r\n     */\r\n    public isEmpty(trim?: boolean): boolean {\r\n        return isNodeEmpty(this.core.contentDiv, trim);\r\n    }\r\n\r\n    /**\r\n     * Get current editor content as HTML string\r\n     * @param triggerExtractContentEvent Whether trigger ExtractContent event to all plugins\r\n     * before return. Use this parameter to remove any temporary content added by plugins.\r\n     * @param includeSelectionMarker Set to true if need include selection marker inside the content.\r\n     * When restore this content, editor will set the selection to the position marked by these markers\r\n     * @returns HTML string representing current editor content\r\n     */\r\n    public getContent(\r\n        triggerExtractContentEvent: boolean = true,\r\n        includeSelectionMarker: boolean = false\r\n    ): string {\r\n        let contentDiv = this.core.contentDiv;\r\n        let content = contentDiv.innerHTML;\r\n        let selectionPath: SelectionPath;\r\n\r\n        if (\r\n            includeSelectionMarker &&\r\n            (selectionPath = getSelectionPath(contentDiv, this.getSelectionRange()))\r\n        ) {\r\n            content += `<!--${JSON.stringify(selectionPath)}-->`;\r\n        }\r\n\r\n        if (triggerExtractContentEvent) {\r\n            content = this.triggerPluginEvent(\r\n                PluginEventType.ExtractContent,\r\n                { content },\r\n                true /*broadcast*/\r\n            ).content;\r\n        }\r\n\r\n        if (this.core.inDarkMode) {\r\n            content = getColorNormalizedContent(content);\r\n        }\r\n\r\n        return content;\r\n    }\r\n\r\n    /**\r\n     * Get plain text content inside editor\r\n     * @returns The text content inside editor\r\n     */\r\n    public getTextContent(): string {\r\n        return getTextContent(this.core.contentDiv);\r\n    }\r\n\r\n    /**\r\n     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\r\n     * @param content HTML content to set in\r\n     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\r\n     */\r\n    public setContent(content: string, triggerContentChangedEvent: boolean = true) {\r\n        let contentDiv = this.core.contentDiv;\r\n        let contentChanged = false;\r\n        if (contentDiv.innerHTML != content) {\r\n            contentDiv.innerHTML = content || '';\r\n            contentChanged = true;\r\n\r\n            let pathComment = contentDiv.lastChild;\r\n\r\n            if (pathComment && pathComment.nodeType == NodeType.Comment) {\r\n                try {\r\n                    let path = JSON.parse(pathComment.nodeValue) as SelectionPath;\r\n                    this.deleteNode(pathComment);\r\n                    let range = getRangeFromSelectionPath(contentDiv, path);\r\n                    this.select(range);\r\n                } catch {}\r\n            }\r\n        }\r\n\r\n        // Convert content even if it hasn't changed.\r\n        if (this.core.inDarkMode) {\r\n            const darkModeOptions = this.getDarkModeOptions();\r\n            const convertFunction = convertContentToDarkMode(\r\n                contentDiv,\r\n                darkModeOptions && darkModeOptions.onExternalContentTransform\r\n                    ? darkModeOptions.onExternalContentTransform\r\n                    : undefined,\r\n                true /* skipRootElement */\r\n            );\r\n            if (convertFunction) {\r\n                convertFunction();\r\n                contentChanged = true;\r\n            }\r\n        }\r\n\r\n        if (triggerContentChangedEvent && contentChanged) {\r\n            this.triggerContentChangedEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Insert HTML content into editor\r\n     * @param HTML content to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     */\r\n    public insertContent(content: string, option?: InsertOption) {\r\n        if (content) {\r\n            let allNodes = fromHtml(content, this.core.document);\r\n            // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with\r\n            // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped\r\n            // separately to show up on its own line\r\n            if (option && option.insertOnNewLine && allNodes.length > 0) {\r\n                allNodes = [wrap(allNodes)];\r\n            }\r\n            for (let i = 0; i < allNodes.length; i++) {\r\n                this.insertNode(allNodes[i], option);\r\n            }\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Focus and Selection\r\n\r\n    /**\r\n     * Get current selection range from Editor.\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @returns current selection range, or null if editor never got focus before\r\n     */\r\n    public getSelectionRange(): Range {\r\n        return this.core.api.getSelectionRange(this.core, true /*tryGetFromCache*/);\r\n    }\r\n\r\n    /**\r\n     * Check if focus is in editor now\r\n     * @returns true if focus is in editor, otherwise false\r\n     */\r\n    public hasFocus(): boolean {\r\n        return this.core.api.hasFocus(this.core);\r\n    }\r\n\r\n    /**\r\n     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.\r\n     */\r\n    public focus() {\r\n        this.core.api.focus(this.core);\r\n    }\r\n\r\n    /**\r\n     * Select content by range\r\n     * @param range The range to select\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(range: Range): boolean;\r\n\r\n    /**\r\n     * Select content by Position and collapse to this position\r\n     * @param position The position to select\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(position: NodePosition): boolean;\r\n\r\n    /**\r\n     * Select content by a start and end position\r\n     * @param start The start position to select\r\n     * @param end The end position to select, if this is the same with start, the selection will be collapsed\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(start: NodePosition, end: NodePosition): boolean;\r\n\r\n    /**\r\n     * Select content by node\r\n     * @param node The node to select\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(node: Node): boolean;\r\n\r\n    /**\r\n     * Select content by node and offset, and collapse to this position\r\n     * @param node The node to select\r\n     * @param offset The offset of node to select, can be a number or value of PositionType\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(node: Node, offset: number | PositionType): boolean;\r\n\r\n    /**\r\n     * Select content by start and end nodes and offsets\r\n     * @param startNode The node to select start from\r\n     * @param startOffset The offset to select start from\r\n     * @param endNode The node to select end to\r\n     * @param endOffset The offset to select end to\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(\r\n        startNode: Node,\r\n        startOffset: number | PositionType,\r\n        endNode: Node,\r\n        endOffset: number | PositionType\r\n    ): boolean;\r\n\r\n    public select(arg1: any, arg2?: any, arg3?: any, arg4?: any): boolean {\r\n        let range = arg1 instanceof Range ? arg1 : createRange(arg1, arg2, arg3, arg4);\r\n        return this.contains(range) && this.core.api.selectRange(this.core, range);\r\n    }\r\n\r\n    /**\r\n     * Get current selection\r\n     * @return current selection object\r\n     */\r\n    public getSelection(): Selection {\r\n        return this.core.document.defaultView.getSelection();\r\n    }\r\n\r\n    /**\r\n     * Save the current selection in editor so that when focus again, the selection can be restored\r\n     */\r\n    public saveSelectionRange() {\r\n        this.core.cachedSelectionRange = this.core.api.getSelectionRange(\r\n            this.core,\r\n            false /*tryGetFromCache*/\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Restore the saved selection range and clear it\r\n     */\r\n    public restoreSavedRange() {\r\n        this.select(this.core.cachedSelectionRange);\r\n        this.core.cachedSelectionRange = null;\r\n    }\r\n\r\n    /**\r\n     * Get current focused position. Return null if editor doesn't have focus at this time.\r\n     */\r\n    public getFocusedPosition(): NodePosition {\r\n        let sel = this.getSelection();\r\n        if (this.contains(sel && sel.focusNode)) {\r\n            return new Position(sel.focusNode, sel.focusOffset);\r\n        }\r\n\r\n        let range = this.getSelectionRange();\r\n        if (range) {\r\n            return Position.getStart(range);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get a rect representing the location of the cursor.\r\n     * @returns a Rect object representing cursor location\r\n     */\r\n    public getCursorRect(): Rect {\r\n        let position = this.getFocusedPosition();\r\n        return position && getPositionRect(position);\r\n    }\r\n\r\n    /**\r\n     * Get an HTML element from current cursor position.\r\n     * When expectedTags is not specified, return value is the current node (if it is HTML element)\r\n     * or its parent node (if current node is a Text node).\r\n     * When expectedTags is specified, return value is the first anscestor of current node which has\r\n     * one of the expected tags.\r\n     * If no element found within editor by the given tag, return null.\r\n     * @param selector Optional, an HTML selector to find HTML element with.\r\n     * @param startFrom Start search from this node. If not specified, start from current focused position\r\n     */\r\n    public getElementAtCursor(selector?: string, startFrom?: Node): HTMLElement {\r\n        if (!startFrom) {\r\n            let position = this.getFocusedPosition();\r\n            startFrom = position && position.node;\r\n        }\r\n        return startFrom && findClosestElementAncestor(startFrom, this.core.contentDiv, selector);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region EVENT API\r\n\r\n    /**\r\n     * Add a custom DOM event handler to handle events not handled by roosterjs.\r\n     * Caller need to take the responsibility to dispose the handler properly\r\n     * @param eventName DOM event name to handle\r\n     * @param handler Handler callback\r\n     * @returns A dispose function. Call the function to dispose this event handler\r\n     */\r\n    public addDomEventHandler(eventName: string, handler: (event: UIEvent) => void): () => void;\r\n\r\n    /**\r\n     * Add a bunch of custom DOM event handler to handle events not handled by roosterjs.\r\n     * Caller need to take the responsibility to dispose the handler properly\r\n     * @param handlerMap A event name => event handler map\r\n     * @returns A dispose function. Call the function to dispose all event handlers added by this function\r\n     */\r\n    public addDomEventHandler(handlerMap: {\r\n        [eventName: string]: (event: UIEvent) => void;\r\n    }): () => void;\r\n\r\n    public addDomEventHandler(\r\n        nameOrMap:\r\n            | string\r\n            | {\r\n                  [eventName: string]: (event: UIEvent) => void;\r\n              },\r\n        handler?: (event: UIEvent) => void\r\n    ): () => void {\r\n        if (nameOrMap instanceof Object) {\r\n            let handlers = Object.keys(nameOrMap)\r\n                .map(\r\n                    eventName =>\r\n                        nameOrMap[eventName] &&\r\n                        this.core.api.attachDomEvent(\r\n                            this.core,\r\n                            eventName,\r\n                            null /*pluginEventType*/,\r\n                            nameOrMap[eventName]\r\n                        )\r\n                )\r\n                .filter(x => x);\r\n            return () => handlers.forEach(handler => handler());\r\n        } else {\r\n            return this.core.api.attachDomEvent(\r\n                this.core,\r\n                nameOrMap,\r\n                null /*pluginEventType*/,\r\n                handler\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger an event to be dispatched to all plugins\r\n     * @param eventType Type of the event\r\n     * @param data data of the event with given type, this is the rest part of PluginEvent with the given type\r\n     * @param broadcast indicates if the event needs to be dispatched to all plugins\r\n     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that\r\n     * @returns the event object which is really passed into plugins. Some plugin may modify the event object so\r\n     * the result of this function provides a chance to read the modified result\r\n     */\r\n    public triggerPluginEvent<T extends PluginEventType>(\r\n        eventType: T,\r\n        data: PluginEventData<T>,\r\n        broadcast?: boolean\r\n    ): PluginEventFromType<T> {\r\n        let event = ({\r\n            eventType,\r\n            ...data,\r\n        } as any) as PluginEventFromType<T>;\r\n        this.core.api.triggerEvent(this.core, event, broadcast);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use triggerPluginEvent instead\r\n     */\r\n    public triggerEvent(pluginEvent: PluginEvent, broadcast: boolean = true) {\r\n        this.core.api.triggerEvent(this.core, pluginEvent, broadcast);\r\n    }\r\n\r\n    /**\r\n     * Trigger a ContentChangedEvent\r\n     * @param source Source of this event, by default is 'SetContent'\r\n     * @param data additional data for this event\r\n     */\r\n    public triggerContentChangedEvent(\r\n        source: ChangeSource | string = ChangeSource.SetContent,\r\n        data?: any\r\n    ) {\r\n        this.triggerPluginEvent(PluginEventType.ContentChanged, {\r\n            source,\r\n            data,\r\n        });\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Undo API\r\n\r\n    /**\r\n     * Undo last edit operation\r\n     */\r\n    public undo() {\r\n        this.focus();\r\n        this.core.corePlugins.undo.undo();\r\n    }\r\n\r\n    /**\r\n     * Redo next edit operation\r\n     */\r\n    public redo() {\r\n        this.focus();\r\n        this.core.corePlugins.undo.redo();\r\n    }\r\n\r\n    /**\r\n     * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger\r\n     * ContentChangedEvent with given change source.\r\n     * If this function is called nested, undo snapshot will only be added in the outside one\r\n     * @param callback The callback function to perform formatting, returns a data object which will be used as\r\n     * the data field in ContentChangedEvent if changeSource is not null.\r\n     * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,\r\n     * a ContentChangedEvent will be fired with change source equal to this value\r\n     */\r\n    public addUndoSnapshot(\r\n        callback?: (start: NodePosition, end: NodePosition, snapshotBeforeCallback: string) => any,\r\n        changeSource?: ChangeSource | string\r\n    ) {\r\n        this.core.api.editWithUndo(this.core, callback, changeSource);\r\n    }\r\n\r\n    /**\r\n     * Perform an auto complete action in the callback, save a snapsnot of content before the action,\r\n     * and trigger ContentChangedEvent with the change source if specified\r\n     * @param callback The auto complete callback, return value will be used as data field of ContentChangedEvent\r\n     * @param changeSource Chagne source of ContentChangedEvent. If not passed, no ContentChangedEvent will be  triggered\r\n     */\r\n    public performAutoComplete(callback: () => any, changeSource?: ChangeSource | string) {\r\n        this.core.corePlugins.edit.performAutoComplete(callback, changeSource);\r\n    }\r\n\r\n    /**\r\n     * Whether there is an available undo snapshot\r\n     */\r\n    public canUndo(): boolean {\r\n        return this.core.corePlugins.undo.canUndo();\r\n    }\r\n\r\n    /**\r\n     * Whether there is an available redo snapshot\r\n     */\r\n    public canRedo(): boolean {\r\n        return this.core.corePlugins.undo.canRedo();\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Misc\r\n\r\n    /**\r\n     * Get document which contains this editor\r\n     * @returns The HTML document which contains this editor\r\n     */\r\n    public getDocument(): Document {\r\n        return this.core.document;\r\n    }\r\n\r\n    /**\r\n     * Get the scroll container of the editor\r\n     */\r\n    public getScrollContainer(): HTMLElement {\r\n        return this.core.scrollContainer;\r\n    }\r\n\r\n    /**\r\n     * Get custom data related to this editor\r\n     * @param key Key of the custom data\r\n     * @param getter Getter function. If custom data for the given key doesn't exist,\r\n     * call this function to get one and store it if it is specified. Otherwise return undefined\r\n     * @param disposer An optional disposer function to dispose this custom data when\r\n     * dispose editor.\r\n     */\r\n    public getCustomData<T>(key: string, getter?: () => T, disposer?: (value: T) => void): T {\r\n        return this.core.api.getCustomData(this.core, key, getter, disposer);\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in IME input sequence\r\n     * @returns True if editor is in IME input sequence, otherwise false\r\n     */\r\n    public isInIME(): boolean {\r\n        return this.core.corePlugins.domEvent.isInIME();\r\n    }\r\n\r\n    /**\r\n     * Get default format of this editor\r\n     * @returns Default format object of this editor\r\n     */\r\n    public getDefaultFormat(): DefaultFormat {\r\n        return this.core.defaultFormat;\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for the whole editor\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    public getBodyTraverser(startNode?: Node): ContentTraverser {\r\n        return ContentTraverser.createBodyTraverser(this.core.contentDiv, startNode);\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current selection\r\n     */\r\n    public getSelectionTraverser(): ContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range &&\r\n            ContentTraverser.createSelectionTraverser(\r\n                this.core.contentDiv,\r\n                this.getSelectionRange()\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current block element start from specified position\r\n     * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart\r\n     */\r\n    public getBlockTraverser(\r\n        startFrom: ContentPosition = ContentPosition.SelectionStart\r\n    ): ContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range && ContentTraverser.createBlockTraverser(this.core.contentDiv, range, startFrom)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a text traverser of current selection\r\n     */\r\n    public getContentSearcherOfCursor(): PositionContentSearcher {\r\n        let range = this.getSelectionRange();\r\n        return range && new PositionContentSearcher(this.core.contentDiv, Position.getStart(range));\r\n    }\r\n\r\n    /**\r\n     * Run a callback function asynchronously\r\n     * @param callback The callback function to run\r\n     */\r\n    public runAsync(callback: () => void) {\r\n        let win = this.core.contentDiv.ownerDocument.defaultView || window;\r\n        win.requestAnimationFrame(() => {\r\n            if (!this.isDisposed() && callback) {\r\n                callback();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     * @param value Value of the attribute\r\n     */\r\n    public setEditorDomAttribute(name: string, value: string) {\r\n        if (value === null) {\r\n            this.core.contentDiv.removeAttribute(name);\r\n        } else {\r\n            this.core.contentDiv.setAttribute(name, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a Content Edit feature. This is mostly called from ContentEdit plugin\r\n     * @param feature The feature to add\r\n     */\r\n    public addContentEditFeature(feature: GenericContentEditFeature<PluginEvent>) {\r\n        this.core.corePlugins.edit.addFeature(feature);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Dark mode APIs\r\n\r\n    /**\r\n     * Set the dark mode state and transforms the content to match the new state.\r\n     * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.\r\n     */\r\n    public setDarkModeState(nextDarkMode?: boolean) {\r\n        if (this.isDarkMode() == nextDarkMode) {\r\n            return;\r\n        }\r\n\r\n        const currentContent = this.getContent(\r\n            undefined /* triggerContentChangedEvent */,\r\n            true /* getSelectionMarker */\r\n        );\r\n\r\n        this.core.inDarkMode = nextDarkMode;\r\n        this.core.defaultFormat = calculateDefaultFormat(\r\n            this.core.contentDiv,\r\n            this.core.defaultFormat,\r\n            this.core.inDarkMode\r\n        );\r\n\r\n        this.setContent(currentContent);\r\n        this.triggerPluginEvent(PluginEventType.DarkModeChanged, {\r\n            changedToDarkMode: nextDarkMode,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if the editor is in dark mode\r\n     * @returns True if the editor is in dark mode, otherwise false\r\n     */\r\n    public isDarkMode(): boolean {\r\n        return this.core.inDarkMode;\r\n    }\r\n\r\n    /**\r\n     * Returns the dark mode options set on the editor\r\n     * @returns A DarkModeOptions object\r\n     */\r\n    public getDarkModeOptions(): DarkModeOptions {\r\n        return this.core.darkModeOptions;\r\n    }\r\n\r\n    //#endregion\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\n\r\nconst COMMANDS: {\r\n    [command: string]: any;\r\n} = Browser.isFirefox\r\n    ? {\r\n          /**\r\n           * Disable these object resizing for firefox since other browsers don't have these behaviors\r\n           */\r\n          [DocumentCommand.EnableObjectResizing]: false,\r\n          [DocumentCommand.EnableInlineTableEditing]: false,\r\n      }\r\n    : Browser.isIE\r\n    ? {\r\n          /**\r\n           * Change the default paragraph separater to DIV. This is mainly for IE since its default setting is P\r\n           */\r\n          [DocumentCommand.DefaultParagraphSeparator]: 'div',\r\n\r\n          /**\r\n           * Disable auto link feature in IE since we have our own implementation\r\n           */\r\n          [DocumentCommand.AutoUrlDetect]: false,\r\n      }\r\n    : {};\r\n\r\n/**\r\n * Execute document command to adjust browser default behavior\r\n */\r\nexport default function adjustBrowserBehavior() {\r\n    Object.keys(COMMANDS).forEach(command => {\r\n        // Catch any possible exception since this should not block the initialization of editor\r\n        try {\r\n            document.execCommand(command, false, COMMANDS[command]);\r\n        } catch {}\r\n    });\r\n}\r\n","import CopyPlugin from '../corePlugins/CopyPlugin';\r\nimport DOMEventPlugin from '../corePlugins/DOMEventPlugin';\r\nimport EditorCore, { CoreApiMap, CorePlugins } from '../interfaces/EditorCore';\r\nimport EditorOptions from '../interfaces/EditorOptions';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport EditPlugin from '../corePlugins/EditPlugin';\r\nimport FirefoxTypeAfterLink from '../corePlugins/FirefoxTypeAfterLink';\r\nimport MouseUpPlugin from '../corePlugins/MouseUpPlugin';\r\nimport TypeInContainerPlugin from '../corePlugins/TypeInContainerPlugin';\r\nimport Undo from '../undo/Undo';\r\nimport { attachDomEvent } from '../coreAPI/attachDomEvent';\r\nimport { Browser } from 'roosterjs-editor-dom';\r\nimport { calculateDefaultFormat } from '../coreAPI/calculateDefaultFormat';\r\nimport { CustomDataMap } from '../interfaces/CustomData';\r\nimport { editWithUndo } from '../coreAPI/editWithUndo';\r\nimport { focus } from '../coreAPI/focus';\r\nimport { getCustomData } from '../coreAPI/getCustomData';\r\nimport { getSelectionRange } from '../coreAPI/getSelectionRange';\r\nimport { hasFocus } from '../coreAPI/hasFocus';\r\nimport { insertNode } from '../coreAPI/insertNode';\r\nimport { select, selectRange } from '../coreAPI/selectRange';\r\nimport { triggerEvent } from '../coreAPI/triggerEvent';\r\n\r\n/**\r\n * Create core object for editor\r\n * @param contentDiv The DIV element used for editor\r\n * @param options Options to create an editor\r\n */\r\nexport default function createEditorCore(\r\n    contentDiv: HTMLDivElement,\r\n    options: EditorOptions\r\n): EditorCore {\r\n    let corePlugins: CorePlugins = {\r\n        undo: options.undo || new Undo(),\r\n        edit: new EditPlugin(),\r\n        typeInContainer: new TypeInContainerPlugin(),\r\n        mouseUp: new MouseUpPlugin(),\r\n        domEvent: new DOMEventPlugin(options.disableRestoreSelectionOnFocus),\r\n        firefoxTypeAfterLink: Browser.isFirefox && new FirefoxTypeAfterLink(),\r\n        copyPlugin: !Browser.isIE && new CopyPlugin(),\r\n    };\r\n    let allPlugins = buildPluginList(corePlugins, options.plugins);\r\n    let eventHandlerPlugins = allPlugins.filter(\r\n        plugin => plugin.onPluginEvent || plugin.willHandleEventExclusively\r\n    );\r\n    return {\r\n        contentDiv,\r\n        scrollContainer: options.scrollContainer || contentDiv,\r\n        document: contentDiv.ownerDocument,\r\n        defaultFormat: calculateDefaultFormat(\r\n            contentDiv,\r\n            options.defaultFormat,\r\n            options.inDarkMode\r\n        ),\r\n        corePlugins,\r\n        currentUndoSnapshot: null,\r\n        customData: createCustomData(options.customData || {}),\r\n        cachedSelectionRange: null,\r\n        plugins: allPlugins,\r\n        eventHandlerPlugins: eventHandlerPlugins,\r\n        api: createCoreApiMap(options.coreApiOverride),\r\n        defaultApi: createCoreApiMap(),\r\n        inDarkMode: options.inDarkMode,\r\n        darkModeOptions: options.darkModeOptions,\r\n    };\r\n}\r\n\r\nfunction buildPluginList(corePlugins: CorePlugins, plugins: EditorPlugin[]): EditorPlugin[] {\r\n    return [\r\n        corePlugins.typeInContainer,\r\n        corePlugins.edit,\r\n        corePlugins.mouseUp,\r\n        ...(plugins || []),\r\n        corePlugins.firefoxTypeAfterLink,\r\n        corePlugins.undo,\r\n        corePlugins.domEvent,\r\n        corePlugins.copyPlugin,\r\n    ].filter(plugin => !!plugin);\r\n}\r\n\r\nfunction createCoreApiMap(map?: Partial<CoreApiMap>): CoreApiMap {\r\n    map = map || {};\r\n    return {\r\n        attachDomEvent: map.attachDomEvent || attachDomEvent,\r\n        editWithUndo: map.editWithUndo || editWithUndo,\r\n        focus: map.focus || focus,\r\n        getCustomData: map.getCustomData || getCustomData,\r\n        getSelectionRange: map.getSelectionRange || getSelectionRange,\r\n        hasFocus: map.hasFocus || hasFocus,\r\n        insertNode: map.insertNode || insertNode,\r\n        select: map.select || select,\r\n        selectRange: map.selectRange || selectRange,\r\n        triggerEvent: map.triggerEvent || triggerEvent,\r\n    };\r\n}\r\n\r\nfunction createCustomData(initValue: { [key: string]: any }): CustomDataMap {\r\n    return Object.keys(initValue).reduce(\r\n        (result, key) => {\r\n            result[key] = {\r\n                value: initValue[key],\r\n            };\r\n            return result;\r\n        },\r\n        <CustomDataMap>{}\r\n    );\r\n}\r\n","import UndoSnapshotsService from '../interfaces/UndoSnapshotsService';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\nimport {\r\n    addSnapshot,\r\n    canMoveCurrentSnapshot,\r\n    moveCurrentSnapsnot,\r\n    clearProceedingSnapshots,\r\n    createSnapshots,\r\n} from 'roosterjs-editor-dom';\r\n\r\n// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped\r\n// to keep size under limit. This is kept at 10MB\r\nconst MAXSIZELIMIT = 1e7;\r\n\r\n/**\r\n * A class to help manage undo snapshots\r\n */\r\nexport default class UndoSnapshots implements UndoSnapshotsService {\r\n    private snapshots: Snapshots;\r\n\r\n    constructor(public readonly maxSize: number = MAXSIZELIMIT) {\r\n        this.snapshots = createSnapshots(maxSize);\r\n    }\r\n\r\n    /**\r\n     * Check whether can move current undo snapshot with the given step\r\n     * @param step The step to check, can be positive, negative or 0\r\n     * @returns True if can move current snapshot with the given step, otherwise false\r\n     */\r\n    public canMove(delta: number): boolean {\r\n        return canMoveCurrentSnapshot(this.snapshots, delta);\r\n    }\r\n\r\n    /**\r\n     * Move current snapshot with the given step if can move this step. Otherwise no action and return null\r\n     * @param step The step to move\r\n     * @returns If can move with the given step, returns the snapshot after move, otherwise null\r\n     */\r\n    public move(delta: number): string {\r\n        return moveCurrentSnapsnot(this.snapshots, delta);\r\n    }\r\n\r\n    /**\r\n     * Add a new undo snapshot\r\n     * @param snapshot The snapshot to add\r\n     */\r\n    public addSnapshot(snapshot: string) {\r\n        addSnapshot(this.snapshots, snapshot);\r\n    }\r\n\r\n    /**\r\n     * Clear all undo snapshots after the current one\r\n     */\r\n    public clearRedo() {\r\n        clearProceedingSnapshots(this.snapshots);\r\n    }\r\n}\r\n","import EditorCore, { AttachDomEvent } from '../interfaces/EditorCore';\r\nimport isCharacterValue from '../eventApi/isCharacterValue';\r\nimport { PluginDomEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Attach a DOM event to the editor content DIV\r\n * @param core The EditorCore object\r\n * @param eventName The DOM event name\r\n * @param pluginEventType Optional event type. When specified, editor will trigger a plugin event with this name when the DOM event is triggered\r\n * @param beforeDispatch Optional callback function to be invoked when the DOM event is triggered before trigger plugin event\r\n */\r\nexport const attachDomEvent: AttachDomEvent = (\r\n    core: EditorCore,\r\n    eventName: string,\r\n    pluginEventType?: PluginEventType,\r\n    beforeDispatch?: (event: UIEvent) => void\r\n) => {\r\n    let onEvent = (event: UIEvent) => {\r\n        // Stop propagation of a printable keyboard event (a keyboard event which is caused by printable char input).\r\n        // This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),\r\n        // event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.\r\n        // So if we missed some case here it is still acceptable.\r\n        if (\r\n            (isKeyboardEvent(event) && isCharacterValue(event)) ||\r\n            pluginEventType == PluginEventType.Input\r\n        ) {\r\n            event.stopPropagation();\r\n        }\r\n\r\n        if (beforeDispatch) {\r\n            beforeDispatch(event);\r\n        }\r\n        if (pluginEventType != null) {\r\n            core.api.triggerEvent(\r\n                core,\r\n                <PluginDomEvent>{\r\n                    eventType: pluginEventType,\r\n                    rawEvent: event,\r\n                },\r\n                false /*broadcast*/\r\n            );\r\n        }\r\n    };\r\n    core.contentDiv.addEventListener(eventName, onEvent);\r\n    return () => {\r\n        core.contentDiv.removeEventListener(eventName, onEvent);\r\n    };\r\n};\r\n\r\nfunction isKeyboardEvent(e: UIEvent): e is KeyboardEvent {\r\n    return e.type == 'keydown' || e.type == 'keypress' || e.type == 'keyup';\r\n}\r\n","import EditorCore, { EditWithUndo } from '../interfaces/EditorCore';\r\nimport { Position } from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    ContentChangedEvent,\r\n    NodePosition,\r\n    PluginEventType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Call an editing callback with adding undo snapshots around, and trigger a ContentChanged event if change source is specified.\r\n * Undo snapshot will not be added if this call is nested inside another editWithUndo() call.\r\n * @param core The EditorCore object\r\n * @param callback The editing callback, accepting current selection start and end position, returns an optional object used as the data field of ContentChangedEvent.\r\n * @param changeSource The ChangeSource string of ContentChangedEvent. @default ChangeSource.Format. Set to null to avoid triggering ContentChangedEvent\r\n */\r\nexport const editWithUndo: EditWithUndo = (\r\n    core: EditorCore,\r\n    callback: (start: NodePosition, end: NodePosition, snapshotBeforeCallback: string) => any,\r\n    changeSource: ChangeSource | string\r\n) => {\r\n    let isNested = core.currentUndoSnapshot !== null;\r\n    let data: any;\r\n\r\n    if (!isNested) {\r\n        core.currentUndoSnapshot = core.corePlugins.undo.addUndoSnapshot();\r\n    }\r\n\r\n    try {\r\n        if (callback) {\r\n            let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\r\n            data = callback(\r\n                range && Position.getStart(range).normalize(),\r\n                range && Position.getEnd(range).normalize(),\r\n                core.currentUndoSnapshot\r\n            );\r\n\r\n            if (!isNested) {\r\n                core.corePlugins.undo.addUndoSnapshot();\r\n            }\r\n        }\r\n    } finally {\r\n        if (!isNested) {\r\n            core.currentUndoSnapshot = null;\r\n        }\r\n    }\r\n\r\n    if (callback && changeSource) {\r\n        let event: ContentChangedEvent = {\r\n            eventType: PluginEventType.ContentChanged,\r\n            source: changeSource,\r\n            data: data,\r\n        };\r\n        core.api.triggerEvent(core, event, true /*broadcast*/);\r\n    }\r\n};\r\n","import EditorCore, { Focus } from '../interfaces/EditorCore';\r\nimport { createRange, getFirstLeafNode } from 'roosterjs-editor-dom';\r\nimport { PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Focus to editor. If there is a cached selection range, use it as current selection\r\n * @param core The EditorCore object\r\n */\r\nexport const focus: Focus = (core: EditorCore) => {\r\n    if (!core.api.hasFocus(core) || !core.api.getSelectionRange(core, false /*tryGetFromCache*/)) {\r\n        // Focus (document.activeElement indicates) and selection are mostly in sync, but could be out of sync in some extreme cases.\r\n        // i.e. if you programmatically change window selection to point to a non-focusable DOM element (i.e. tabindex=-1 etc.).\r\n        // On Chrome/Firefox, it does not change document.activeElement. On Edge/IE, it change document.activeElement to be body\r\n        // Although on Chrome/Firefox, document.activeElement points to editor, you cannot really type which we don't want (no cursor).\r\n        // So here we always do a live selection pull on DOM and make it point in Editor. The pitfall is, the cursor could be reset\r\n        // to very begin to of editor since we don't really have last saved selection (created on blur which does not fire in this case).\r\n        // It should be better than the case you cannot type\r\n        if (\r\n            !core.cachedSelectionRange ||\r\n            !core.api.selectRange(core, core.cachedSelectionRange, true /*skipSameRange*/)\r\n        ) {\r\n            let node = getFirstLeafNode(core.contentDiv) || core.contentDiv;\r\n            core.api.selectRange(\r\n                core,\r\n                createRange(node, PositionType.Begin),\r\n                true /*skipSameRange*/\r\n            );\r\n        }\r\n    }\r\n\r\n    // remember to clear cachedSelectionRange\r\n    core.cachedSelectionRange = null;\r\n\r\n    // This is more a fallback to ensure editor gets focus if it didn't manage to move focus to editor\r\n    if (!core.api.hasFocus(core)) {\r\n        core.contentDiv.focus();\r\n    }\r\n};\r\n","import EditorCore, { GetCustomData } from '../interfaces/EditorCore';\r\n\r\n/**\r\n * Get custom data related with this editor\r\n * @param core The EditorCore object\r\n * @param key Key of the custom data\r\n * @param getter Getter function. If custom data for the given key doesn't exist,\r\n * call this function to get one and store it if it is specified. Otherwise return undefined\r\n * @param disposer An optional disposer function to dispose this custom data when\r\n * dispose editor.\r\n */\r\nexport const getCustomData: GetCustomData = <T>(\r\n    core: EditorCore,\r\n    key: string,\r\n    getter: () => T,\r\n    disposer?: (value: T) => void\r\n): T => {\r\n    return (core.customData[key] = core.customData[key] || {\r\n        value: getter ? getter() : undefined,\r\n        disposer,\r\n    }).value as T;\r\n};\r\n","import EditorCore, { GetSelectionRange } from '../interfaces/EditorCore';\r\nimport { contains } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Get current or cached selection range\r\n * @param core The EditorCore object\r\n * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now\r\n * @returns A Range object of the selection range\r\n */\r\nexport const getSelectionRange: GetSelectionRange = (\r\n    core: EditorCore,\r\n    tryGetFromCache: boolean\r\n) => {\r\n    let result: Range = null;\r\n\r\n    if (!tryGetFromCache || core.api.hasFocus(core)) {\r\n        let selection = core.document.defaultView.getSelection();\r\n        if (selection && selection.rangeCount > 0) {\r\n            let range = selection.getRangeAt(0);\r\n            if (contains(core.contentDiv, range)) {\r\n                result = range;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!result && tryGetFromCache) {\r\n        result = core.cachedSelectionRange;\r\n    }\r\n\r\n    return result;\r\n};\r\n","import EditorCore, { InsertNode } from '../interfaces/EditorCore';\r\nimport {\r\n    ContentPosition,\r\n    InsertOption,\r\n    NodeType,\r\n    PositionType,\r\n    BlockElement,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    Position,\r\n    getBlockElementAtNode,\r\n    getFirstLastBlockElement,\r\n    isBlockElement,\r\n    isVoidHtmlElement,\r\n    wrap,\r\n    adjustNodeInsertPosition,\r\n    createRange,\r\n} from 'roosterjs-editor-dom';\r\n\r\nfunction getInitialRange(\r\n    core: EditorCore,\r\n    option: InsertOption\r\n): { range: Range; rangeToRestore: Range } {\r\n    // Selection start replaces based on the current selection.\r\n    // Range inserts based on a provided range.\r\n    // Both have the potential to use the current selection to restore cursor position\r\n    // So in both cases we need to store the selection state.\r\n    let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\r\n    let rangeToRestore = null;\r\n    if (option.position == ContentPosition.Range) {\r\n        rangeToRestore = range;\r\n        range = option.range;\r\n    } else if (range) {\r\n        rangeToRestore = range.cloneRange();\r\n    }\r\n\r\n    return { range, rangeToRestore };\r\n}\r\n\r\n/**\r\n * Insert a DOM node into editor content\r\n * @param core The EditorCore object. No op if null.\r\n * @param option An insert option object to specify how to insert the node\r\n */\r\nexport const insertNode: InsertNode = (core: EditorCore, node: Node, option: InsertOption) => {\r\n    option = option || {\r\n        position: ContentPosition.SelectionStart,\r\n        insertOnNewLine: false,\r\n        updateCursor: true,\r\n        replaceSelection: true,\r\n    };\r\n    let contentDiv = core.contentDiv;\r\n\r\n    if (option.updateCursor) {\r\n        core.api.focus(core);\r\n    }\r\n\r\n    switch (option.position) {\r\n        case ContentPosition.Begin:\r\n        case ContentPosition.End:\r\n            let isBegin = option.position == ContentPosition.Begin;\r\n            let block = getFirstLastBlockElement(contentDiv, isBegin);\r\n            let insertedNode: Node;\r\n            if (block) {\r\n                let refNode = isBegin ? block.getStartNode() : block.getEndNode();\r\n                if (\r\n                    option.insertOnNewLine ||\r\n                    refNode.nodeType == NodeType.Text ||\r\n                    isVoidHtmlElement(refNode)\r\n                ) {\r\n                    // For insert on new line, or refNode is text or void html element (HR, BR etc.)\r\n                    // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the\r\n                    // first and last node. Insert before 'hello' or after 'world', but still inside DIV\r\n                    insertedNode = refNode.parentNode.insertBefore(\r\n                        node,\r\n                        isBegin ? refNode : refNode.nextSibling\r\n                    );\r\n                } else {\r\n                    // if the refNode can have child, use appendChild (which is like to insert as first/last child)\r\n                    // i.e. <div>hello</div>, the content will be inserted before/after hello\r\n                    insertedNode = refNode.insertBefore(node, isBegin ? refNode.firstChild : null);\r\n                }\r\n            } else {\r\n                // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv\r\n                insertedNode = contentDiv.appendChild(node);\r\n            }\r\n\r\n            // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\r\n            // add a DIV wrapping\r\n            if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {\r\n                wrap(insertedNode);\r\n            }\r\n\r\n            break;\r\n        case ContentPosition.Range:\r\n        case ContentPosition.SelectionStart:\r\n            let { range, rangeToRestore } = getInitialRange(core, option);\r\n\r\n            if (!range) {\r\n                return;\r\n            }\r\n\r\n            // if to replace the selection and the selection is not collapsed, remove the the content at selection first\r\n            if (option.replaceSelection && !range.collapsed) {\r\n                range.deleteContents();\r\n            }\r\n\r\n            let pos = Position.getStart(range);\r\n            let blockElement: BlockElement;\r\n\r\n            if (\r\n                option.insertOnNewLine &&\r\n                (blockElement = getBlockElementAtNode(contentDiv, pos.normalize().node))\r\n            ) {\r\n                pos = new Position(blockElement.getEndNode(), PositionType.After);\r\n            } else {\r\n                pos = adjustNodeInsertPosition(contentDiv, node, pos);\r\n            }\r\n\r\n            let nodeForCursor = node.nodeType == NodeType.DocumentFragment ? node.lastChild : node;\r\n            range = createRange(pos);\r\n            range.insertNode(node);\r\n            if (option.updateCursor && nodeForCursor) {\r\n                rangeToRestore = createRange(\r\n                    new Position(nodeForCursor, PositionType.After).normalize()\r\n                );\r\n            }\r\n            core.api.selectRange(core, rangeToRestore);\r\n\r\n            break;\r\n        case ContentPosition.Outside:\r\n            core.contentDiv.parentNode.insertBefore(node, contentDiv.nextSibling);\r\n            break;\r\n    }\r\n\r\n    return true;\r\n};\r\n","import EditorCore, { Select, SelectRange } from '../interfaces/EditorCore';\r\nimport { Browser, contains, createRange } from 'roosterjs-editor-dom';\r\nimport { hasFocus } from './hasFocus';\r\n\r\n/**\r\n * Change the editor selection to the given range\r\n * @param core The EditorCore object\r\n * @param range The range to select\r\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection\r\n * in editor, otherwise it will always remove current selection ranage and set to the given one.\r\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\r\n */\r\nexport const selectRange: SelectRange = (\r\n    core: EditorCore,\r\n    range: Range,\r\n    skipSameRange?: boolean\r\n) => {\r\n    let selection: Selection;\r\n    let needAddRange = true;\r\n\r\n    if (\r\n        !contains(core.contentDiv, range) ||\r\n        !(selection = core.document.defaultView.getSelection())\r\n    ) {\r\n        return false;\r\n    }\r\n\r\n    if (selection.rangeCount > 0) {\r\n        // Workaround IE exception 800a025e\r\n        try {\r\n            let currentRange: Range;\r\n            // Do not remove/add range if current selection is the same with target range\r\n            // Without this check, execCommand() may fail in Edge since we changed the selection\r\n            if (\r\n                (skipSameRange || Browser.isEdge) &&\r\n                (currentRange = selection.rangeCount == 1 ? selection.getRangeAt(0) : null) &&\r\n                currentRange.startContainer == range.startContainer &&\r\n                currentRange.startOffset == range.startOffset &&\r\n                currentRange.endContainer == range.endContainer &&\r\n                currentRange.endOffset == range.endOffset\r\n            ) {\r\n                needAddRange = false;\r\n            } else {\r\n                selection.removeAllRanges();\r\n            }\r\n        } catch (e) {}\r\n    }\r\n\r\n    if (needAddRange) {\r\n        selection.addRange(range);\r\n    }\r\n\r\n    if (!hasFocus(core)) {\r\n        core.cachedSelectionRange = range;\r\n    }\r\n\r\n    if (range.collapsed) {\r\n        // If selected, and current selection is collapsed,\r\n        // need to restore pending format state if exists.\r\n        core.corePlugins.domEvent.restorePendingFormatState();\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n/**\r\n * @deprecated Only for compatibility with existing code, don't use ths function, use selectRange instead\r\n */\r\nexport const select: Select = (core: EditorCore, arg1: any, arg2?: any, arg3?: any, arg4?: any) => {\r\n    let range = arg1 instanceof Range ? arg1 : createRange(arg1, arg2, arg3, arg4);\r\n    return core.api.selectRange(core, range);\r\n};\r\n","import EditorCore, { TriggerEvent } from '../interfaces/EditorCore';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Trigger a plugin event\r\n * @param core The EditorCore object\r\n * @param pluginEvent The event object to trigger\r\n * @param broadcast Set to true to skip the shouldHandleEventExclusively check\r\n */\r\nexport const triggerEvent: TriggerEvent = (\r\n    core: EditorCore,\r\n    pluginEvent: PluginEvent,\r\n    broadcast: boolean\r\n) => {\r\n    if (\r\n        broadcast ||\r\n        !core.eventHandlerPlugins.some(plugin => handledExclusively(pluginEvent, plugin))\r\n    ) {\r\n        core.eventHandlerPlugins.forEach(plugin => {\r\n            if (plugin.onPluginEvent) {\r\n                plugin.onPluginEvent(pluginEvent);\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\nfunction handledExclusively(event: PluginEvent, plugin: EditorPlugin): boolean {\r\n    if (\r\n        plugin.onPluginEvent &&\r\n        plugin.willHandleEventExclusively &&\r\n        plugin.willHandleEventExclusively(event)\r\n    ) {\r\n        plugin.onPluginEvent(event);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\nimport { EditorCore } from '..';\r\nimport { PluginEventType } from 'roosterjs-editor-types';\r\n\r\nconst EVENT_MAPPING: { [domEvent: string]: PluginEventType } = {\r\n    keypress: PluginEventType.KeyPress,\r\n    keydown: PluginEventType.KeyDown,\r\n    keyup: PluginEventType.KeyUp,\r\n    mousedown: PluginEventType.MouseDown,\r\n    [Browser.isIE ? 'textinput' : 'input']: PluginEventType.Input,\r\n};\r\n\r\n/**\r\n * Map DOM events to editor plugin events\r\n * @param core The EditorCore object\r\n */\r\nexport default function mapPluginEvents(core: EditorCore): (() => void)[] {\r\n    return Object.keys(EVENT_MAPPING).map(pluginEvent =>\r\n        core.api.attachDomEvent(core, pluginEvent, EVENT_MAPPING[pluginEvent])\r\n    );\r\n}\r\n","/**\r\n * Converter for dark mode that runs all child elements of a node through the content transform function.\r\n * @param node The node containing HTML elements to convert.\r\n * @param skipRootElement Optional parameter to skip the root element of the Node passed in, if applicable.\r\n */\r\nexport function convertContentToDarkMode(node: Node, onExternalContentTransform?: (element: Element) => void, skipRootElement?: boolean): () => void {\r\n    let childElements: HTMLElement[] = [];\r\n\r\n    // Get a list of all the decendents of a node.\r\n    // querySelectorAll doesn't return a live list when called on an HTMLElement\r\n    // So we use getElementsByTagName instead for HTMLElement types.\r\n    if (node instanceof HTMLElement) {\r\n        childElements = Array.prototype.slice.call(node.getElementsByTagName('*'));\r\n        if (!skipRootElement) {\r\n            childElements.unshift(node);\r\n        }\r\n    } else if (node instanceof DocumentFragment) {\r\n        childElements = Array.prototype.slice.call(node.querySelectorAll('*'));\r\n    }\r\n\r\n    return childElements.length > 0\r\n        ? () => {\r\n            childElements.forEach(element => {\r\n                if (onExternalContentTransform) {\r\n                    onExternalContentTransform(element);\r\n                } else {\r\n                    element.style.color = null;\r\n                    element.style.backgroundColor = null;\r\n                }\r\n            });\r\n        }\r\n        : null;\r\n}","import cacheGetEventData from './cacheGetEventData';\r\nimport Editor from '../editor/Editor';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\n\r\nconst CACHE_KEY_PREFIX = 'GET_ELEMENT_AT_CURSOR_';\r\n\r\n/**\r\n * Get an HTML element at cursor from event cache if it exists.\r\n * If an selector is specified, return the nearest ancestor of current node\r\n * which matches the selector, or null if no match found in editor.\r\n * @param editor The editor instance\r\n * @param event Event object to get cached object from\r\n * @param selector The expected selector. If null, return the element at cursor\r\n * @returns The element at cursor or the nearest ancestor with the tag name is specified\r\n */\r\nexport default function cacheGetElementAtCursor(\r\n    editor: Editor,\r\n    event: PluginEvent,\r\n    selector: string\r\n): HTMLElement {\r\n    return cacheGetEventData(event, CACHE_KEY_PREFIX + selector, () =>\r\n        editor.getElementAtCursor(selector)\r\n    );\r\n}\r\n","import { ChangeSource } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image file. There are at least 3 ways to obtain the file object:\r\n * From local file, from clipboard data, from drag-and-drop\r\n */\r\nexport default function insertImage(editor: Editor, imageFile: File) {\r\n    let reader = new FileReader();\r\n    reader.onload = (event: ProgressEvent) => {\r\n        if (!editor.isDisposed()) {\r\n            editor.addUndoSnapshot(() => {\r\n                let image = editor.getDocument().createElement('img');\r\n                image.src = (event.target as FileReader).result as string;\r\n                image.style.maxWidth = '100%';\r\n                editor.insertNode(image);\r\n            }, ChangeSource.Format);\r\n        }\r\n    };\r\n    reader.readAsDataURL(imageFile);\r\n}\r\n","import { ChangeSource, PositionType, TableFormat } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { Position, VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert table into editor at current selection\r\n * @param editor The editor instance\r\n * @param columns Number of columns in table, it also controls the default table cell width:\r\n * if columns &lt;= 4, width = 120px; if columns &lt;= 6, width = 100px; else width = 70px\r\n * @param rows Number of rows in table\r\n * @param format (Optional) The table format. If not passed, the default format will be applied:\r\n * background color: #FFF; border color: #ABABAB\r\n */\r\nexport default function insertTable(\r\n    editor: Editor,\r\n    columns: number,\r\n    rows: number,\r\n    format?: TableFormat\r\n) {\r\n    let document = editor.getDocument();\r\n    let fragment = document.createDocumentFragment();\r\n    let table = document.createElement('table') as HTMLTableElement;\r\n    fragment.appendChild(table);\r\n    table.cellSpacing = '0';\r\n    table.cellPadding = '1';\r\n    for (let i = 0; i < rows; i++) {\r\n        let tr = document.createElement('tr') as HTMLTableRowElement;\r\n        table.appendChild(tr);\r\n        for (let j = 0; j < columns; j++) {\r\n            let td = document.createElement('td') as HTMLTableCellElement;\r\n            tr.appendChild(td);\r\n            td.appendChild(document.createElement('br'));\r\n            td.style.width = getTableCellWidth(columns);\r\n        }\r\n    }\r\n\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        let vtable = new VTable(table);\r\n        vtable.applyFormat(\r\n            format || {\r\n                bgColorEven: '#FFF',\r\n                bgColorOdd: '#FFF',\r\n                topBorderColor: '#ABABAB',\r\n                bottomBorderColor: '#ABABAB',\r\n                verticalBorderColor: '#ABABAB',\r\n            }\r\n        );\r\n        vtable.writeBack();\r\n        editor.insertNode(fragment);\r\n        editor.runAsync(() => editor.select(new Position(table, PositionType.Begin).normalize()));\r\n    }, ChangeSource.Format);\r\n}\r\n\r\nfunction getTableCellWidth(columns: number): string {\r\n    if (columns <= 4) {\r\n        return '120px';\r\n    } else if (columns <= 6) {\r\n        return '100px';\r\n    } else {\r\n        return '70px';\r\n    }\r\n}\r\n","import { ChangeSource, TableOperation } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Edit table with given operation. If there is no table at cursor then no op.\r\n * @param editor The editor instance\r\n * @param operation Table operation\r\n */\r\nexport default function editTable(editor: Editor, operation: TableOperation) {\r\n    let td = editor.getElementAtCursor('TD,TH') as HTMLTableCellElement;\r\n    if (td) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(td);\r\n            vtable.edit(operation);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n\r\n            if (!editor.select(start, end)) {\r\n                editor.select(editor.contains(td) ? td : vtable.getCurrentTd());\r\n            }\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { ChangeSource, TableFormat } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Format table\r\n * @param editor The editor which contains the table to format\r\n * @param format A TableFormat object contains format information we want to apply to the table\r\n * @param table The table to format. This is optional. When not passed, the current table (if any) will be formatted\r\n */\r\nexport default function formatTable(\r\n    editor: Editor,\r\n    format: Partial<TableFormat>,\r\n    table?: HTMLTableElement\r\n) {\r\n    table = table || (editor.getElementAtCursor('TABLE') as HTMLTableElement);\r\n    if (table) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(table);\r\n            vtable.applyFormat(format);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n            editor.select(start, end);\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { ChangeSource, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { unwrap } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Remove link at selection. If no links at selection, do nothing.\r\n * If selection contains multiple links, all of the link styles will be removed.\r\n * If only part of a link is selected, the whole link style will be removed.\r\n * @param editor The editor instance\r\n */\r\nexport default function removeLink(editor: Editor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        editor.queryElements('a[href]', QueryScope.OnSelection, unwrap);\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ContentPosition } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { PositionContentSearcher } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Replace text before current selection with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param text The text for matching. We will try to match the text with the text before cursor\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n * @param searcher Optional PositionContentSearcher of current selection to help search text\r\n */\r\nexport default function replaceWithNode(\r\n    editor: Editor,\r\n    text: string,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: PositionContentSearcher\r\n): boolean;\r\n\r\n/**\r\n * Replace a given range with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param range The range to replace from\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n */\r\nexport default function replaceWithNode(\r\n    editor: Editor,\r\n    range: Range,\r\n    node: Node,\r\n    exactMatch: boolean\r\n): boolean;\r\n\r\nexport default function replaceWithNode(\r\n    editor: Editor,\r\n    textOrRange: string | Range,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: PositionContentSearcher\r\n): boolean {\r\n    // Make sure the text and node is valid\r\n    if (!textOrRange || !node) {\r\n        return false;\r\n    }\r\n\r\n    let range: Range;\r\n\r\n    if (typeof textOrRange == 'string') {\r\n        searcher = searcher || editor.getContentSearcherOfCursor();\r\n        range = searcher && searcher.getRangeFromText(textOrRange, exactMatch);\r\n    } else {\r\n        range = textOrRange;\r\n    }\r\n\r\n    if (range) {\r\n        const backupRange = editor.getSelectionRange();\r\n\r\n        // If the range to replace is right before current cursor, it is actually an exact match\r\n        if (\r\n            backupRange.collapsed &&\r\n            range.endContainer == backupRange.startContainer &&\r\n            range.endOffset == backupRange.startOffset\r\n        ) {\r\n            exactMatch = true;\r\n        }\r\n\r\n        editor.insertNode(node, {\r\n            position: ContentPosition.Range,\r\n            updateCursor: exactMatch,\r\n            replaceSelection: true,\r\n            insertOnNewLine: false,\r\n            range: range,\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { Alignment, ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set content alignment\r\n * @param editor The editor instance\r\n * @param alignment The alignment option:\r\n * Alignment.Center, Alignment.Left, Alignment.Right\r\n */\r\nexport default function setAlignment(editor: Editor, alignment: Alignment) {\r\n    let command = DocumentCommand.JustifyLeft;\r\n    let align = 'left';\r\n\r\n    if (alignment == Alignment.Center) {\r\n        command = DocumentCommand.JustifyCenter;\r\n        align = 'center';\r\n    } else if (alignment == Alignment.Right) {\r\n        command = DocumentCommand.JustifyRight;\r\n        align = 'right';\r\n    }\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, command);\r\n        editor.queryElements(\r\n            '[align]',\r\n            QueryScope.OnSelection,\r\n            node => (node.style.textAlign = align)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import collapseSelectedBlocks from '../utils/collapseSelectedBlocks';\r\nimport { ChangeSource, Direction } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Change direction for the blocks/paragraph at selection\r\n * @param editor The editor instance\r\n * @param direction The direction option:\r\n * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'\r\n */\r\nexport default function setDirection(editor: Editor, direction: Direction) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        collapseSelectedBlocks(editor, element => {\r\n            element.setAttribute('dir', direction == Direction.LeftToRight ? 'ltr' : 'rtl');\r\n            element.style.textAlign = direction == Direction.LeftToRight ? 'left' : 'right';\r\n        });\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set image alt text for all selected images at selection. If no images is contained\r\n * in selection, do nothing.\r\n * The alt attribute provides alternative information for an image if a user for some reason\r\n * cannot view it (because of slow connection, an error in the src attribute, or if the user\r\n * uses a screen reader). See https://www.w3schools.com/tags/att_img_alt.asp\r\n * @param editor The editor instance\r\n * @param altText The image alt text\r\n */\r\nexport default function setImageAltText(editor: Editor, altText: string) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        editor.queryElements('img', QueryScope.OnSelection, node =>\r\n            node.setAttribute('alt', altText)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import processList from '../utils/processList';\r\nimport { ChangeSource, DocumentCommand, Indentation, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set indentation at selection\r\n * If selection contains bullet/numbering list, increase/decrease indentation will\r\n * increase/decrease the list level by one.\r\n * @param editor The editor instance\r\n * @param indentation The indentation option:\r\n * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation\r\n */\r\nexport default function setIndentation(editor: Editor, indentation: Indentation) {\r\n    let command: DocumentCommand.Indent | DocumentCommand.Outdent =\r\n        indentation == Indentation.Increase ? DocumentCommand.Indent : DocumentCommand.Outdent;\r\n    editor.addUndoSnapshot(() => {\r\n        editor.focus();\r\n        let listNode = editor.getElementAtCursor('OL,UL');\r\n        let newNode: Node;\r\n\r\n        if (listNode) {\r\n            // There is already list node, setIndentation() will increase/decrease the list level,\r\n            // so we need to process the list when change indentation\r\n            newNode = processList(editor, command);\r\n        } else {\r\n            // No existing list node, browser will create <Blockquote> node for indentation.\r\n            // We need to set top and bottom margin to 0 to avoid unnecessary spaces\r\n            editor.getDocument().execCommand(command, false, null);\r\n            editor.queryElements('BLOCKQUOTE', QueryScope.OnSelection, node => {\r\n                newNode = newNode || node;\r\n                node.style.marginTop = '0px';\r\n                node.style.marginBottom = '0px';\r\n            });\r\n        }\r\n\r\n        return newNode;\r\n    }, ChangeSource.Format);\r\n}\r\n","import processList from '../utils/processList';\r\nimport { ChangeSource, DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle bullet at selection\r\n * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one\r\n * If selection contains number list, toggle bullet will convert the number list into bullet list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBullet(editor: Editor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(\r\n        () => processList(editor, DocumentCommand.InsertUnorderedList),\r\n        ChangeSource.Format\r\n    );\r\n}\r\n","import processList from '../utils/processList';\r\nimport { ChangeSource, DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle numbering at selection\r\n * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one\r\n * If selection contains bullet list, toggle numbering will convert the bullet list into number list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * realization of browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleNumbering(editor: Editor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(\r\n        () => processList(editor, DocumentCommand.InsertOrderedList),\r\n        ChangeSource.Format\r\n    );\r\n}\r\n","import toggleTagCore from '../utils/toggleTagCore';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\nconst BLOCKQUOTE_TAG = 'blockquote';\r\nconst DEFAULT_STYLER = (element: HTMLElement): void => {\r\n    element.style.borderLeft = '3px solid';\r\n    element.style.borderColor = '#C8C8C8';\r\n    element.style.paddingLeft = '10px';\r\n    element.style.color = '#666666';\r\n};\r\n\r\n/**\r\n * Toggle blockquote at selection, if selection already contains any blockquoted elements,\r\n * the blockquoted elements will be unblockquoted and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the blockquote element\r\n */\r\nexport default function toggleBlockQuote(editor: Editor, styler?: (element: HTMLElement) => void) {\r\n    toggleTagCore(editor, BLOCKQUOTE_TAG, styler || DEFAULT_STYLER);\r\n}\r\n","import toggleTagCore from '../utils/toggleTagCore';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getTagOfNode, unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst PRE_TAG = 'pre';\r\nconst CODE_TAG = 'code';\r\nconst CODE_NODE_TAG = 'CODE';\r\n\r\n/**\r\n * Toggle code block at selection, if selection already contains any code blocked elements,\r\n * the code block elements will be no longer be code blocked and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the code block element\r\n */\r\nexport default function toggleCodeBlock(\r\n    editor: Editor,\r\n    styler?: (element: HTMLElement) => void\r\n): void {\r\n    toggleTagCore(editor, PRE_TAG, styler, wrapFunction, unwrapFunction);\r\n}\r\n\r\nfunction wrapFunction(nodes: Node[]): HTMLElement {\r\n    let codeBlock = wrap(nodes, CODE_TAG);\r\n    return wrap(codeBlock, PRE_TAG);\r\n}\r\n\r\nfunction unwrapFunction(node: HTMLElement): Node {\r\n    if (!node) {\r\n        return null;\r\n    }\r\n\r\n    let firstChild = node.childNodes[0];\r\n    if (node.childNodes.length == 1 && getTagOfNode(firstChild) == CODE_NODE_TAG) {\r\n        unwrap(firstChild);\r\n    }\r\n\r\n    return unwrap(node);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle strikethrough at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only strikethrough text, the strikethrough style will be removed\r\n * If selection contains only normal text, strikethrough style will be added to the whole selected text\r\n * If selection contains both strikethrough and normal text, strikethrough stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleStrikethrough(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.StrikeThrough);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle subscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only subscript text, the subscript style will be removed\r\n * If selection contains only normal text, subscript style will be added to the whole selected text\r\n * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text\r\n * If selection contains any superscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSubscript(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Subscript);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle superscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only superscript text, the superscript style will be removed\r\n * If selection contains only normal text, superscript style will be added to the whole selected text\r\n * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text\r\n * If selection contains any subscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSuperscript(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Superscript);\r\n}\r\n","import { ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { findClosestElementAncestor } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Toggle header at selection\r\n * @param editor The editor instance\r\n * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to\r\n * the HTML header element &lt;H1&gt; to &lt;H6&gt;, 0 means no header\r\n * if passed in param is outside the range, will be rounded to nearest number in the range\r\n */\r\nexport default function toggleHeader(editor: Editor, level: number) {\r\n    level = Math.min(Math.max(Math.round(level), 0), 6);\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        editor.focus();\r\n\r\n        let wrapped = false;\r\n        editor.queryElements('H1,H2,H3,H4,H5,H6', QueryScope.OnSelection, header => {\r\n            if (!wrapped) {\r\n                editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, '<DIV>');\r\n                wrapped = true;\r\n            }\r\n\r\n            let div = editor.getDocument().createElement('div');\r\n            while (header.firstChild) {\r\n                div.appendChild(header.firstChild);\r\n            }\r\n            editor.replaceNode(header, div);\r\n        });\r\n\r\n        if (level > 0) {\r\n            let traverser = editor.getSelectionTraverser();\r\n            let inlineElement = traverser ? traverser.currentInlineElement : null;\r\n            while (inlineElement) {\r\n                let element = findClosestElementAncestor(inlineElement.getContainerNode());\r\n                if (element) {\r\n                    element.style.fontSize = '';\r\n                }\r\n                inlineElement = traverser.getNextInlineElement();\r\n            }\r\n            editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, `<H${level}>`);\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set content alignment\r\n * @param editor The editor instance\r\n */\r\nexport default function setJustifyFull(editor: Editor) {\r\n    let command = DocumentCommand.JustifyFull;\r\n    let align = 'justify';\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, command);\r\n        editor.queryElements(\r\n            '[align]',\r\n            QueryScope.OnSelection,\r\n            node => (node.style.textAlign = align)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\nimport { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\r\nimport { FontSizeChange, PluginEventType, PluginKeyboardEvent } from 'roosterjs-editor-types';\r\nimport {\r\n    changeFontSize,\r\n    toggleBold,\r\n    toggleItalic,\r\n    toggleUnderline,\r\n    toggleBullet,\r\n    toggleNumbering,\r\n} from 'roosterjs-editor-api';\r\n\r\ninterface ShortcutCommand {\r\n    winKey: number;\r\n    macKey: number;\r\n    action: (editor: Editor) => any;\r\n}\r\n\r\nfunction createCommand(winKey: number, macKey: number, action: (editor: Editor) => any) {\r\n    return {\r\n        winKey,\r\n        macKey,\r\n        action,\r\n    };\r\n}\r\n\r\nconst commands: ShortcutCommand[] = [\r\n    createCommand(Keys.Ctrl | Keys.B, Keys.Meta | Keys.B, toggleBold),\r\n    createCommand(Keys.Ctrl | Keys.I, Keys.Meta | Keys.I, toggleItalic),\r\n    createCommand(Keys.Ctrl | Keys.U, Keys.Meta | Keys.U, toggleUnderline),\r\n    createCommand(Keys.Ctrl | Keys.Z, Keys.Meta | Keys.Z, editor => editor.undo()),\r\n    createCommand(Keys.Ctrl | Keys.Y, Keys.Meta | Keys.Shift | Keys.Z, editor => editor.redo()),\r\n    createCommand(Keys.Ctrl | Keys.PERIOD, Keys.Meta | Keys.PERIOD, toggleBullet),\r\n    createCommand(Keys.Ctrl | Keys.FORWARDSLASH, Keys.Meta | Keys.FORWARDSLASH, toggleNumbering),\r\n    createCommand(\r\n        Keys.Ctrl | Keys.Shift | Keys.PERIOD,\r\n        Keys.Meta | Keys.Shift | Keys.PERIOD,\r\n        editor => changeFontSize(editor, FontSizeChange.Increase)\r\n    ),\r\n    createCommand(\r\n        Keys.Ctrl | Keys.Shift | Keys.COMMA,\r\n        Keys.Meta | Keys.Shift | Keys.COMMA,\r\n        editor => changeFontSize(editor, FontSizeChange.Decrease)\r\n    ),\r\n];\r\n\r\n/**\r\n * DefaultShortcut edit feature, provides shortcuts for the following features:\r\n * Ctrl/Meta+B: toggle bold style\r\n * Ctrl/Meta+I: toggle italic style\r\n * Ctrl/Meta+U: toggle underline style\r\n * Ctrl/Meta+Z: undo\r\n * Ctrl+Y/Meta+Shift+Z: redo\r\n * Ctrl/Meta+PERIOD: toggle bullet list\r\n * Ctrl/Meta+/: toggle numbering list\r\n * Ctrl/Meta+Shift+>: increase font size\r\n * Ctrl/Meta+Shift+<: decrease font size\r\n */\r\nexport const DefaultShortcut: ContentEditFeature = {\r\n    allowFunctionKeys: true,\r\n    keys: [Keys.B, Keys.I, Keys.U, Keys.Y, Keys.Z, Keys.COMMA, Keys.PERIOD, Keys.FORWARDSLASH],\r\n    shouldHandleEvent: cacheGetCommand,\r\n    handleEvent: (event, editor) => {\r\n        let command = cacheGetCommand(event);\r\n        if (command) {\r\n            command.action(editor);\r\n            event.rawEvent.preventDefault();\r\n            event.rawEvent.stopPropagation();\r\n        }\r\n    },\r\n};\r\n\r\nfunction cacheGetCommand(event: PluginKeyboardEvent) {\r\n    return cacheGetEventData(event, 'DEFAULT_SHORT_COMMAND', () => {\r\n        let e = event.rawEvent;\r\n        let key =\r\n            // Need to check ALT key to be false since in some language (e.g. Polski) uses AltGr to input some special charactors\r\n            // In that case, ctrlKey and altKey are both true in Edge, but we should not trigger any shortcut function here\r\n            event.eventType == PluginEventType.KeyDown && !e.altKey\r\n                ? e.which |\r\n                  (e.metaKey && Keys.Meta) |\r\n                  (e.shiftKey && Keys.Shift) |\r\n                  (e.ctrlKey && Keys.Ctrl)\r\n                : 0;\r\n        return key && commands.filter(cmd => (Browser.isMac ? cmd.macKey : cmd.winKey) == key)[0];\r\n    });\r\n}\r\n","import { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\r\nimport { PluginKeyboardEvent, PositionType } from 'roosterjs-editor-types';\r\nimport {\r\n    Browser,\r\n    fromHtml,\r\n    isPositionAtBeginningOf,\r\n    Position,\r\n    getTagOfNode,\r\n} from 'roosterjs-editor-dom';\r\n\r\n// Edge can sometimes lose current format when Enter to new line.\r\n// So here we add an extra SPAN for Edge to workaround this bug\r\nconst NEWLINE_HTML = Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>';\r\nconst CHILD_PARENT_TAG_MAP: { [childTag: string]: string } = {\r\n    TD: 'TABLE',\r\n    TH: 'TABLE',\r\n    LI: 'OL,UL',\r\n};\r\nconst CHILD_SELECTOR = Object.keys(CHILD_PARENT_TAG_MAP).join(',');\r\n\r\n/**\r\n * InsertLineBeforeStructuredNode edit feature, provides the ability to insert an empty line before\r\n * a structured element (bullet/numbering list, blockquote, table) if the element is at beginning of\r\n * document\r\n */\r\nexport const InsertLineBeforeStructuredNodeFeature: ContentEditFeature = {\r\n    keys: [Keys.ENTER],\r\n    shouldHandleEvent: cacheGetStructuredElement,\r\n    handleEvent: (event, editor) => {\r\n        let element = cacheGetStructuredElement(event, editor);\r\n        let div = fromHtml(NEWLINE_HTML, editor.getDocument())[0] as HTMLElement;\r\n        editor.addUndoSnapshot(() => {\r\n            element.parentNode.insertBefore(div, element);\r\n            // Select the new line when we are in table. This is the same behavior with Word\r\n            if (getTagOfNode(element) == 'TABLE') {\r\n                editor.select(new Position(div, PositionType.Begin).normalize());\r\n            }\r\n        });\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n\r\nfunction cacheGetStructuredElement(event: PluginKeyboardEvent, editor: Editor) {\r\n    return cacheGetEventData(event, 'FIRST_STRUCTURE', () => {\r\n        // Provide a chance to keep browser default behavior by pressing SHIFT\r\n        let element = event.rawEvent.shiftKey ? null : editor.getElementAtCursor(CHILD_SELECTOR);\r\n\r\n        if (element) {\r\n            let range = editor.getSelectionRange();\r\n            if (\r\n                range &&\r\n                range.collapsed &&\r\n                isPositionAtBeginningOf(Position.getStart(range), element) &&\r\n                !editor.getBodyTraverser(element).getPreviousBlockElement()\r\n            ) {\r\n                return editor.getElementAtCursor(CHILD_PARENT_TAG_MAP[getTagOfNode(element)]);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    });\r\n}\r\n","import { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\r\nimport {\r\n    contains,\r\n    getTagOfNode,\r\n    isVoidHtmlElement,\r\n    Position,\r\n    VTable\r\n    } from 'roosterjs-editor-dom';\r\nimport { NodeType, PluginEvent, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * TabInTable edit feature, provides the ability to jump between cells when user press TAB in table\r\n */\r\nexport const TabInTable: ContentEditFeature = {\r\n    keys: [Keys.TAB],\r\n    shouldHandleEvent: cacheGetTableCell,\r\n    handleEvent: (event, editor) => {\r\n        let shift = event.rawEvent.shiftKey;\r\n        let td = cacheGetTableCell(event, editor);\r\n        for (\r\n            let vtable = new VTable(td),\r\n                step = shift ? -1 : 1,\r\n                row = vtable.row,\r\n                col = vtable.col + step;\r\n            ;\r\n            col += step\r\n        ) {\r\n            if (col < 0 || col >= vtable.cells[row].length) {\r\n                row += step;\r\n                if (row < 0 || row >= vtable.cells.length) {\r\n                    editor.select(vtable.table, shift ? PositionType.Before : PositionType.After);\r\n                    break;\r\n                }\r\n                col = shift ? vtable.cells[row].length - 1 : 0;\r\n            }\r\n            let cell = vtable.getCell(row, col);\r\n            if (cell.td) {\r\n                editor.select(cell.td, PositionType.Begin);\r\n                break;\r\n            }\r\n        }\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n\r\n/**\r\n * UpDownInTable edit feature, provides the ability to jump to cell above/below when user press UP/DOWN\r\n * in table\r\n */\r\nexport const UpDownInTable: ContentEditFeature = {\r\n    keys: [Keys.UP, Keys.DOWN],\r\n    shouldHandleEvent: cacheGetTableCell,\r\n    handleEvent: (event, editor) => {\r\n        let td = cacheGetTableCell(event, editor);\r\n        let vtable = new VTable(td);\r\n        let isUp = event.rawEvent.which == Keys.UP;\r\n        let step = isUp ? -1 : 1;\r\n        let targetTd: HTMLTableCellElement = null;\r\n        let hasShiftKey = event.rawEvent.shiftKey;\r\n        let { anchorNode, anchorOffset } = editor.getSelection();\r\n\r\n        for (let row = vtable.row; row >= 0 && row < vtable.cells.length; row += step) {\r\n            let cell = vtable.getCell(row, vtable.col);\r\n            if (cell.td && cell.td != td) {\r\n                targetTd = cell.td;\r\n                break;\r\n            }\r\n        }\r\n\r\n        editor.runAsync(() => {\r\n            let newContainer = editor.getElementAtCursor();\r\n            if (\r\n                contains(vtable.table, newContainer) &&\r\n                !contains(td, newContainer, true /*treatSameNodeAsContain*/)\r\n            ) {\r\n                let newPos = targetTd\r\n                    ? new Position(targetTd, PositionType.Begin)\r\n                    : new Position(vtable.table, isUp ? PositionType.Before : PositionType.After);\r\n                if (hasShiftKey) {\r\n                    newPos =\r\n                        newPos.node.nodeType == NodeType.Element && isVoidHtmlElement(newPos.node)\r\n                            ? new Position(\r\n                                  newPos.node,\r\n                                  newPos.isAtEnd ? PositionType.After : PositionType.Before\r\n                              )\r\n                            : newPos;\r\n                    editor\r\n                        .getSelection()\r\n                        .setBaseAndExtent(anchorNode, anchorOffset, newPos.node, newPos.offset);\r\n                } else {\r\n                    editor.select(newPos);\r\n                }\r\n            }\r\n        });\r\n    },\r\n};\r\n\r\nfunction cacheGetTableCell(event: PluginEvent, editor: Editor): HTMLTableCellElement {\r\n    return cacheGetEventData(event, 'TABLECELL_FOR_TABLE_FEATURES', () => {\r\n        let pos = editor.getFocusedPosition();\r\n        let firstTd = editor.getElementAtCursor('TD,TH,LI', pos.node);\r\n        return getTagOfNode(firstTd) == 'LI' ? null : (firstTd as HTMLTableCellElement);\r\n    });\r\n}\r\n","import { setIndentation, toggleBullet, toggleNumbering } from 'roosterjs-editor-api';\r\nimport {\r\n    cacheGetContentSearcher,\r\n    cacheGetElementAtCursor,\r\n    Editor,\r\n    ContentEditFeature,\r\n    GenericContentEditFeature,\r\n    Keys,\r\n} from 'roosterjs-editor-core';\r\nimport {\r\n    ContentChangedEvent,\r\n    Indentation,\r\n    PluginKeyboardEvent,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    Browser,\r\n    Position,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    isPositionAtBeginningOf,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * IndentWhenTab edit feature, provides the ability to indent current list when user press TAB\r\n */\r\nexport const IndentWhenTab: ContentEditFeature = {\r\n    keys: [Keys.TAB],\r\n    shouldHandleEvent: (event, editor) =>\r\n        !event.rawEvent.shiftKey && cacheGetListElement(event, editor),\r\n    handleEvent: (event, editor) => {\r\n        setIndentation(editor, Indentation.Increase);\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n\r\n/**\r\n * OutdentWhenShiftTab edit feature, provides the ability to outdent current list when user press Shift+TAB\r\n */\r\nexport const OutdentWhenShiftTab: ContentEditFeature = {\r\n    keys: [Keys.TAB],\r\n    shouldHandleEvent: (event, editor) =>\r\n        event.rawEvent.shiftKey && cacheGetListElement(event, editor),\r\n    handleEvent: (event, editor) => {\r\n        setIndentation(editor, Indentation.Decrease);\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n\r\n/**\r\n * MergeInNewLine edit feature, provides the ability to merge current line into a new line when user press\r\n * BACKSPACE at beginning of a list item\r\n */\r\nexport const MergeInNewLine: ContentEditFeature = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\r\n        let range = editor.getSelectionRange();\r\n        return li && range && isPositionAtBeginningOf(Position.getStart(range), li);\r\n    },\r\n    handleEvent: (event, editor) => {\r\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\r\n        if (li.previousSibling) {\r\n            editor.runAsync(() => {\r\n                let br = editor.getDocument().createElement('BR');\r\n                editor.insertNode(br);\r\n                editor.select(br, PositionType.After);\r\n            });\r\n        } else {\r\n            toggleListAndPreventDefault(event, editor);\r\n        }\r\n    },\r\n};\r\n\r\n/**\r\n * OutdentWhenBackOn1stEmptyLine edit feature, provides the ability to outdent current item if user press\r\n * BACKSPACE at the first and empty line of a list\r\n */\r\nexport const OutdentWhenBackOn1stEmptyLine: ContentEditFeature = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\r\n        return li && isNodeEmpty(li) && !li.previousSibling;\r\n    },\r\n    handleEvent: toggleListAndPreventDefault,\r\n};\r\n\r\n/**\r\n * OutdentWhenEnterOnEmptyLine edit feature, provides the ability to outdent current item if user press\r\n * ENTER at the beginning of an empty line of a list\r\n */\r\nexport const OutdentWhenEnterOnEmptyLine: ContentEditFeature = {\r\n    keys: [Keys.ENTER],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\r\n        return !event.rawEvent.shiftKey && li && isNodeEmpty(li);\r\n    },\r\n    handleEvent: (event, editor) => {\r\n        editor.performAutoComplete(() => toggleListAndPreventDefault(event, editor));\r\n    },\r\n};\r\n\r\n/**\r\n * AutoBullet edit feature, provides the ablility to automatically convert current line into a list.\r\n * When user input \"1. \", convert into a numbering list\r\n * When user input \"- \" or \"* \", convert into a bullet list\r\n */\r\nexport const AutoBullet: ContentEditFeature = {\r\n    keys: [Keys.SPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        if (!cacheGetListElement(event, editor)) {\r\n            let searcher = cacheGetContentSearcher(event, editor);\r\n            let textBeforeCursor = searcher.getSubStringBefore(3);\r\n\r\n            // Auto list is triggered if:\r\n            // 1. Text before cursor exactly mathces '*', '-' or '1.'\r\n            // 2. There's no non-text inline entities before cursor\r\n            return (\r\n                ['*', '-', '1.'].indexOf(textBeforeCursor) >= 0 &&\r\n                !searcher.getNearestNonTextInlineElement()\r\n            );\r\n        }\r\n        return false;\r\n    },\r\n    handleEvent: (event, editor) => {\r\n        editor.runAsync(() => {\r\n            editor.performAutoComplete(() => {\r\n                let searcher = editor.getContentSearcherOfCursor();\r\n                let textBeforeCursor = searcher.getSubStringBefore(3);\r\n                let rangeToDelete = searcher.getRangeFromText(\r\n                    textBeforeCursor,\r\n                    true /*exactMatch*/\r\n                );\r\n\r\n                if (rangeToDelete) {\r\n                    rangeToDelete.deleteContents();\r\n                }\r\n\r\n                // If not explicitly insert br, Chrome/Safari/IE will operate on the previous line\r\n                let tempBr = editor.getDocument().createElement('BR');\r\n                if (Browser.isChrome || Browser.isSafari || Browser.isIE11OrGreater) {\r\n                    editor.insertNode(tempBr);\r\n                }\r\n\r\n                if (textBeforeCursor.indexOf('1.') == 0) {\r\n                    toggleNumbering(editor);\r\n                } else {\r\n                    toggleBullet(editor);\r\n                }\r\n\r\n                editor.deleteNode(tempBr);\r\n            });\r\n        });\r\n    },\r\n};\r\n\r\n/**\r\n * Get an instance of SmartOrderedList edit feature. This feature provides the ability to use different\r\n * number style for different level of numbering list.\r\n * @param styleList The list of number styles used for this feature.\r\n * See https://www.w3schools.com/cssref/pr_list-style-type.asp for more information\r\n */\r\nexport function getSmartOrderedList(\r\n    styleList: string[]\r\n): GenericContentEditFeature<ContentChangedEvent> {\r\n    return {\r\n        keys: [Keys.CONTENTCHANGED], // Triggered by ContentChangedEvent\r\n        shouldHandleEvent: (event, editor) => event.data instanceof HTMLOListElement,\r\n        handleEvent: (event, editor) => {\r\n            let ol = event.data as HTMLOListElement;\r\n            let parentOl = editor.getElementAtCursor('OL', ol.parentNode) as HTMLOListElement;\r\n            if (parentOl) {\r\n                // The style list must has at least one value. If no value is passed in, fallback to decimal\r\n                let styles = styleList && styleList.length > 0 ? styleList : ['decimal'];\r\n                ol.style.listStyle =\r\n                    styles[(styles.indexOf(parentOl.style.listStyle) + 1) % styles.length];\r\n            }\r\n        },\r\n    };\r\n}\r\n\r\nfunction toggleListAndPreventDefault(event: PluginKeyboardEvent, editor: Editor) {\r\n    let listInfo = cacheGetListElement(event, editor);\r\n    if (listInfo) {\r\n        let listElement = listInfo[0];\r\n        let tag = getTagOfNode(listElement);\r\n        if (tag == 'UL') {\r\n            toggleBullet(editor);\r\n        } else if (tag == 'OL') {\r\n            toggleNumbering(editor);\r\n        }\r\n        editor.focus();\r\n        event.rawEvent.preventDefault();\r\n    }\r\n}\r\n\r\nfunction cacheGetListElement(event: PluginKeyboardEvent, editor: Editor) {\r\n    let li = cacheGetElementAtCursor(editor, event, 'LI,TABLE');\r\n    let listElement = li && getTagOfNode(li) == 'LI' && editor.getElementAtCursor('UL,OL', li);\r\n    return listElement ? [listElement, li] : null;\r\n}\r\n","import { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\r\nimport { PluginKeyboardEvent, PositionType } from 'roosterjs-editor-types';\r\nimport {\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    splitBalancedNodeRange,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst QUOTE_TAG = 'BLOCKQUOTE';\r\nconst STRUCTURED_TAGS = [QUOTE_TAG, 'LI', 'TD', 'TH'].join(',');\r\n\r\n/**\r\n * UnquoteWhenBackOnEmpty1stLine edit feature, provides the ability to Unquote current line when\r\n * user press BACKSPACE on first and empty line of a BLOCKQUOTE\r\n */\r\nexport const UnquoteWhenBackOnEmpty1stLine: ContentEditFeature = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let childOfQuote = cacheGetQuoteChild(event, editor);\r\n        return childOfQuote && isNodeEmpty(childOfQuote) && !childOfQuote.previousSibling;\r\n    },\r\n    handleEvent: splitQuote,\r\n};\r\n\r\n/**\r\n * UnquoteWhenEnterOnEmptyLine edit feature, provides the ability to Unquote current line when\r\n * user press ENTER on an empty line of a BLOCKQUOTE\r\n */\r\nexport const UnquoteWhenEnterOnEmptyLine: ContentEditFeature = {\r\n    keys: [Keys.ENTER],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let childOfQuote = cacheGetQuoteChild(event, editor);\r\n        let shift = event.rawEvent.shiftKey;\r\n        return !shift && childOfQuote && isNodeEmpty(childOfQuote);\r\n    },\r\n    handleEvent: (event, editor) => editor.performAutoComplete(() => splitQuote(event, editor)),\r\n};\r\n\r\nfunction cacheGetQuoteChild(event: PluginKeyboardEvent, editor: Editor): Node {\r\n    return cacheGetEventData(event, 'QUOTE_CHILD', () => {\r\n        let quote = editor.getElementAtCursor(STRUCTURED_TAGS);\r\n        if (quote && getTagOfNode(quote) == QUOTE_TAG) {\r\n            let pos = editor.getFocusedPosition();\r\n            let block = pos && editor.getBlockElementAtNode(pos.normalize().node);\r\n            if (block) {\r\n                let node =\r\n                    block.getStartNode() == quote\r\n                        ? block.getStartNode()\r\n                        : block.collapseToSingleElement();\r\n                return isNodeEmpty(node) ? node : null;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    });\r\n}\r\n\r\nfunction splitQuote(event: PluginKeyboardEvent, editor: Editor) {\r\n    editor.addUndoSnapshot(() => {\r\n        let childOfQuote = cacheGetQuoteChild(event, editor);\r\n        let parent: Node;\r\n        if (getTagOfNode(childOfQuote) == QUOTE_TAG) {\r\n            childOfQuote = wrap([].slice.call(childOfQuote.childNodes));\r\n        }\r\n        parent = splitBalancedNodeRange(childOfQuote);\r\n        unwrap(parent);\r\n        editor.select(childOfQuote, PositionType.Begin);\r\n    });\r\n    event.rawEvent.preventDefault();\r\n}\r\n","import buildClipboardData from './buildClipboardData';\r\nimport fragmentHandler from './fragmentHandler';\r\nimport textToHtml from './textToHtml';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport { getFormatState } from 'roosterjs-editor-api';\r\nimport { insertImage } from 'roosterjs-editor-api';\r\nimport {\r\n    AttributeCallbackMap,\r\n    getInheritableStyles,\r\n    HtmlSanitizer,\r\n    htmlToDom,\r\n} from 'roosterjs-html-sanitizer';\r\nimport {\r\n    BeforePasteEvent,\r\n    ChangeSource,\r\n    ClipboardData,\r\n    DefaultFormat,\r\n    NodeType,\r\n    PasteOption,\r\n    PluginEventType,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    applyFormat,\r\n    fromHtml,\r\n    getFirstLeafNode,\r\n    getNextLeafSibling,\r\n    Position,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Paste plugin, handles onPaste event and paste content into editor\r\n */\r\nexport default class Paste implements EditorPlugin {\r\n    private editor: Editor;\r\n    private pasteDisposer: () => void;\r\n    private sanitizer: HtmlSanitizer;\r\n\r\n    /**\r\n     * Create an instance of Paste\r\n     * @param preserved Not used. Preserved parameter only used for compatibility with old code\r\n     * @param attributeCallbacks A set of callbacks to help handle html attribute during sanitization\r\n     */\r\n    constructor(preserved?: any, attributeCallbacks?: AttributeCallbackMap) {\r\n        this.sanitizer = new HtmlSanitizer({\r\n            attributeCallbacks,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Paste';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    public initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.pasteDisposer = editor.addDomEventHandler('paste', this.onPaste);\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose() {\r\n        this.pasteDisposer();\r\n        this.pasteDisposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    private onPaste = (event: Event) => {\r\n        buildClipboardData(<ClipboardEvent>event, this.editor, items => {\r\n            this.pasteOriginal({\r\n                snapshotBeforePaste: null,\r\n                originalFormat: this.getCurrentFormat(),\r\n                types: items.types,\r\n                image: items.image,\r\n                text: items.text,\r\n                rawHtml: items.html,\r\n                html: items.html ? this.sanitizeHtml(items.html) : textToHtml(items.text),\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Paste into editor using passed in clipboardData with original format\r\n     * @param clipboardData The clipboardData to paste\r\n     */\r\n    public pasteOriginal(clipboardData: ClipboardData) {\r\n        this.paste(clipboardData, this.detectPasteOption(clipboardData));\r\n    }\r\n\r\n    /**\r\n     * Paste plain text into editor using passed in clipboardData\r\n     * @param clipboardData The clipboardData to paste\r\n     */\r\n    public pasteText(clipboardData: ClipboardData) {\r\n        this.paste(clipboardData, PasteOption.PasteText);\r\n    }\r\n\r\n    /**\r\n     * Paste into editor using passed in clipboardData with curent format\r\n     * @param clipboardData The clipboardData to paste\r\n     */\r\n    public pasteAndMergeFormat(clipboardData: ClipboardData) {\r\n        this.paste(clipboardData, this.detectPasteOption(clipboardData), true /*mergeFormat*/);\r\n    }\r\n\r\n    private detectPasteOption(clipboardData: ClipboardData): PasteOption {\r\n        return clipboardData.text || !clipboardData.image\r\n            ? PasteOption.PasteHtml\r\n            : PasteOption.PasteImage;\r\n    }\r\n\r\n    private paste(\r\n        clipboardData: ClipboardData,\r\n        pasteOption: PasteOption,\r\n        mergeCurrentFormat?: boolean\r\n    ) {\r\n        let document = this.editor.getDocument();\r\n        let fragment = document.createDocumentFragment();\r\n\r\n        if (pasteOption == PasteOption.PasteHtml) {\r\n            let html = clipboardData.html;\r\n            let nodes = fromHtml(html, document);\r\n\r\n            for (let node of nodes) {\r\n                if (mergeCurrentFormat) {\r\n                    this.applyToElements(node, this.applyFormatting(clipboardData.originalFormat, this.editor.isDarkMode()));\r\n                }\r\n                fragment.appendChild(node);\r\n            }\r\n        }\r\n\r\n        let event = this.editor.triggerPluginEvent(\r\n            PluginEventType.BeforePaste,\r\n            {\r\n                clipboardData,\r\n                fragment,\r\n                pasteOption,\r\n            },\r\n            true /*broadcast*/\r\n        );\r\n        this.internalPaste(event);\r\n    }\r\n\r\n    private internalPaste(event: BeforePasteEvent) {\r\n        let { clipboardData, fragment, pasteOption } = event;\r\n        this.editor.focus();\r\n        this.editor.addUndoSnapshot(() => {\r\n            if (clipboardData.snapshotBeforePaste == null) {\r\n                clipboardData.snapshotBeforePaste = this.editor.getContent(\r\n                    false /*triggerExtractContentEvent*/,\r\n                    true /*markSelection*/\r\n                );\r\n            } else {\r\n                this.editor.setContent(clipboardData.snapshotBeforePaste);\r\n            }\r\n\r\n            switch (pasteOption) {\r\n                case PasteOption.PasteHtml:\r\n                    this.editor.insertNode(fragment);\r\n                    break;\r\n\r\n                case PasteOption.PasteText:\r\n                    let html = textToHtml(clipboardData.text);\r\n                    this.editor.insertContent(html);\r\n                    break;\r\n\r\n                case PasteOption.PasteImage:\r\n                    insertImage(this.editor, clipboardData.image);\r\n                    break;\r\n            }\r\n\r\n            return clipboardData;\r\n        }, ChangeSource.Paste);\r\n    }\r\n\r\n    private applyFormatting = (format: DefaultFormat, isDarkMode: boolean) => (element: HTMLElement) => {\r\n        applyFormat(element, format, isDarkMode);\r\n    }\r\n\r\n    private applyToElements(node: Node, elementTransform: (element: HTMLElement) => void) {\r\n        let leaf = getFirstLeafNode(node);\r\n        let parents: HTMLElement[] = [];\r\n        while (leaf) {\r\n            if (\r\n                leaf.nodeType == NodeType.Text &&\r\n                leaf.parentNode &&\r\n                parents.indexOf(<HTMLElement>leaf.parentNode) < 0\r\n            ) {\r\n                parents.push(<HTMLElement>leaf.parentNode);\r\n            }\r\n            leaf = getNextLeafSibling(node, leaf);\r\n        }\r\n        parents.push(<HTMLElement>node);\r\n        for (let parent of parents) {\r\n            elementTransform(parent);\r\n        }\r\n    }\r\n\r\n    private getCurrentFormat(): DefaultFormat {\r\n        let format = getFormatState(this.editor);\r\n        return format\r\n            ? {\r\n                fontFamily: format.fontName,\r\n                fontSize: format.fontSize,\r\n                textColor: format.textColor,\r\n                backgroundColor: format.backgroundColor,\r\n                bold: format.isBold,\r\n                italic: format.isItalic,\r\n                underline: format.isUnderline,\r\n            }\r\n            : {};\r\n    }\r\n\r\n    private sanitizeHtml(html: string): string {\r\n        let doc = htmlToDom(html, true /*preserveFragmentOnly*/, fragmentHandler);\r\n        if (doc && doc.body) {\r\n            this.sanitizer.convertGlobalCssToInlineCss(doc);\r\n\r\n            let range = this.editor.getSelectionRange();\r\n            let element = range && Position.getStart(range).normalize().element;\r\n            let currentStyles = getInheritableStyles(element);\r\n            this.sanitizer.sanitize(doc.body, currentStyles);\r\n            return doc.body.innerHTML;\r\n        }\r\n        return '';\r\n    }\r\n}\r\n","import { ClipboardItems, ContentPosition } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { extractClipboardEvent, fromHtml } from 'roosterjs-editor-dom';\r\n\r\nconst CONTAINER_HTML =\r\n    '<div contenteditable style=\"width: 1px; height: 1px; overflow: hidden; position: fixed; top: 0; left; 0; -webkit-user-select: text\"></div>';\r\n\r\n/**\r\n * Build ClipboardData from a paste event\r\n * @param event The paste event\r\n * @param editor The editor\r\n * @param callback Callback function when data is ready\r\n */\r\nexport default function buildClipboardData(\r\n    event: ClipboardEvent,\r\n    editor: Editor,\r\n    callback: (items: ClipboardItems) => void\r\n) {\r\n    extractClipboardEvent(event, items => {\r\n        if (items.html === undefined) {\r\n            retrieveHtmlViaTempDiv(editor, html => {\r\n                items.html = html;\r\n                callback(items);\r\n            });\r\n        } else {\r\n            callback(items);\r\n        }\r\n    });\r\n}\r\n\r\nfunction retrieveHtmlViaTempDiv(editor: Editor, callback: (html: string) => void) {\r\n    // cache original selection range in editor\r\n    let originalSelectionRange = editor.getSelectionRange();\r\n    let tempDiv = getTempDivForPaste(editor);\r\n    tempDiv.focus();\r\n\r\n    editor.runAsync(() => {\r\n        // restore original selection range in editor\r\n        editor.select(originalSelectionRange);\r\n        callback(tempDiv.innerHTML);\r\n        tempDiv.style.display = 'none';\r\n        tempDiv.innerHTML = '';\r\n    });\r\n}\r\n\r\nfunction getTempDivForPaste(editor: Editor): HTMLElement {\r\n    let tempDiv = editor.getCustomData(\r\n        'PasteDiv',\r\n        () => {\r\n            let pasteDiv = fromHtml(CONTAINER_HTML, editor.getDocument())[0] as HTMLElement;\r\n            editor.insertNode(pasteDiv, {\r\n                position: ContentPosition.Outside,\r\n                updateCursor: false,\r\n                replaceSelection: false,\r\n                insertOnNewLine: false,\r\n            });\r\n            return pasteDiv;\r\n        },\r\n        pasteDiv => {\r\n            pasteDiv.parentNode.removeChild(pasteDiv);\r\n        }\r\n    );\r\n    tempDiv.style.display = '';\r\n    return tempDiv;\r\n}\r\n","import convertPastedContentFromExcel from './excelConverter/convertPastedContentFromExcel';\r\nimport convertPastedContentFromWord from './wordConverter/convertPastedContentFromWord';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { splitWithFragment } from 'roosterjs-html-sanitizer';\r\n\r\nconst WORD_ATTRIBUTE_NAME = 'xmlns:w';\r\nconst WORD_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:word';\r\nconst EXCEL_ATTRIBUTE_NAME = 'xmlns:x';\r\nconst EXCEL_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:excel';\r\n\r\nconst LAST_TD_END_REGEX = /<\\/\\s*td\\s*>((?!<\\/\\s*tr\\s*>)[\\s\\S])*$/i;\r\nconst LAST_TR_END_REGEX = /<\\/\\s*tr\\s*>((?!<\\/\\s*table\\s*>)[\\s\\S])*$/i;\r\nconst LAST_TR_REGEX = /<tr[^>]*>[^<]*/i;\r\nconst LAST_TABLE_REGEX = /<table[^>]*>[^<]*/i;\r\n\r\nexport default function fragmentHandler(doc: HTMLDocument, source: string) {\r\n    let [html, before] = splitWithFragment(source);\r\n    let firstNode = doc && doc.body && (doc.querySelector('html') as HTMLElement);\r\n    if (getTagOfNode(firstNode) == 'HTML') {\r\n        if (firstNode.getAttribute(WORD_ATTRIBUTE_NAME) == WORD_ATTRIBUTE_VALUE) {\r\n            // Handle HTML copied from MS Word\r\n            doc.body.innerHTML = html;\r\n            convertPastedContentFromWord(doc);\r\n        } else if (firstNode.getAttribute(EXCEL_ATTRIBUTE_NAME) == EXCEL_ATTRIBUTE_VALUE) {\r\n            // Handle HTML copied from MS Excel\r\n            if (html.match(LAST_TD_END_REGEX)) {\r\n                let trMatch = before.match(LAST_TR_REGEX);\r\n                let tr = trMatch ? trMatch[0] : '<TR>';\r\n                html = tr + html + '</TR>';\r\n            }\r\n            if (html.match(LAST_TR_END_REGEX)) {\r\n                let tableMatch = before.match(LAST_TABLE_REGEX);\r\n                let table = tableMatch ? tableMatch[0] : '<TABLE>';\r\n                html = table + html + '</TABLE>';\r\n            }\r\n            doc.body.innerHTML = html;\r\n            convertPastedContentFromExcel(doc);\r\n        } else {\r\n            // Handle HTML copied from other places\r\n            doc.body.innerHTML = html;\r\n        }\r\n    }\r\n}\r\n","import { HtmlSanitizer } from 'roosterjs-html-sanitizer';\r\n\r\n/**\r\n * Convert pasted content from Excel, add borders when source doc doesn't have a border\r\n * @param doc HTML Document which contains the content from Excel\r\n */\r\nexport default function convertPastedContentFromExcel(doc: HTMLDocument) {\r\n    let sanitizer = new HtmlSanitizer({\r\n        styleCallbacks: {\r\n            border: (value, element) => value != 'none' || element.style.border != 'none',\r\n        },\r\n        additionalAllowAttributes: ['class'],\r\n    });\r\n    sanitizer.sanitize(doc.body);\r\n\r\n    let styleNode = doc.createElement('style');\r\n    doc.body.appendChild(styleNode);\r\n    styleNode.innerHTML = 'td {border: solid 1px #d4d4d4}';\r\n    sanitizer.convertGlobalCssToInlineCss(doc);\r\n}\r\n","import getInheritableStyles from '../utils/getInheritableStyles';\r\nimport HtmlSanitizerOptions from '../types/HtmlSanitizerOptions';\r\nimport htmlToDom from '../utils/htmlToDom';\r\nimport SanitizeHtmlOptions from '../types/SanitizeHtmlOptions';\r\nimport { cloneObject } from '../utils/cloneObject';\r\nimport {\r\n    StringMap,\r\n    StyleCallbackMap,\r\n    ElementCallbackMap,\r\n    AttributeCallbackMap,\r\n} from '../types/maps';\r\nimport {\r\n    getAllowedAttributes,\r\n    getAllowedTags,\r\n    getDefaultStyleValues,\r\n    getStyleCallbacks,\r\n} from '../utils/getAllowedValues';\r\n\r\n/**\r\n * HTML sanitizer class provides two featuers:\r\n * 1. Convert global CSS to inline CSS\r\n * 2. Sanitize an HTML document, remove unnecessary/dangerous attribute/nodes\r\n */\r\nexport default class HtmlSanitizer {\r\n    /**\r\n     * Convert global CSS to inline CSS if any\r\n     * @param html HTML source\r\n     * @param additionalStyleNodes (Optional) additional HTML STYLE elements used as global CSS\r\n     */\r\n    static convertInlineCss(html: string, additionalStyleNodes?: HTMLStyleElement[]) {\r\n        let sanitizer = new HtmlSanitizer({\r\n            additionalGlobalStyleNodes: additionalStyleNodes,\r\n        });\r\n        return sanitizer.exec(html, true /*convertCssOnly*/);\r\n    }\r\n\r\n    /**\r\n     * Sanitize HTML string, remove any unuseful HTML node/attribute/CSS.\r\n     * @param html HTML source string\r\n     * @param options Options used for this sanitizing process\r\n     */\r\n    static sanitizeHtml(html: string, options?: SanitizeHtmlOptions) {\r\n        options = options || {};\r\n        let sanitizer = new HtmlSanitizer(options);\r\n        let currentStyles =\r\n            options.currentElementOrStyle instanceof HTMLElement\r\n                ? getInheritableStyles(options.currentElementOrStyle)\r\n                : options.currentElementOrStyle;\r\n        return sanitizer.exec(\r\n            html,\r\n            options.convertCssOnly,\r\n            options.preserveFragmentOnly,\r\n            currentStyles\r\n        );\r\n    }\r\n\r\n    private elementCallbacks: ElementCallbackMap;\r\n    private styleCallbacks: StyleCallbackMap;\r\n    private attributeCallbacks: AttributeCallbackMap;\r\n    private allowedTags: string[];\r\n    private allowedAttributes: string[];\r\n    private defaultStyleValues: StringMap;\r\n    private additionalGlobalStyleNodes: HTMLStyleElement[];\r\n    private allowPreserveWhiteSpace: boolean;\r\n\r\n    /**\r\n     * Construct a new instance of HtmlSanitizer\r\n     * @param options Options for HtmlSanitizer\r\n     */\r\n    constructor(options?: HtmlSanitizerOptions) {\r\n        options = options || {};\r\n        this.elementCallbacks = cloneObject(options.elementCallbacks);\r\n        this.styleCallbacks = getStyleCallbacks(options.styleCallbacks);\r\n        this.attributeCallbacks = cloneObject(options.attributeCallbacks);\r\n        this.allowedTags = getAllowedTags(options.additionalAllowedTags);\r\n        this.allowedAttributes = getAllowedAttributes(options.additionalAllowAttributes);\r\n        this.defaultStyleValues = getDefaultStyleValues(options.additionalDefaultStyleValues);\r\n        this.additionalGlobalStyleNodes = options.additionalGlobalStyleNodes || [];\r\n        this.allowPreserveWhiteSpace = options.allowPreserveWhiteSpace;\r\n    }\r\n\r\n    /**\r\n     * Sanitize HTML string\r\n     * This function will do the following work:\r\n     * 1. Convert global CSS into inline CSS\r\n     * 2. Remove dangerous HTML tags and attributes\r\n     * 3. Remove useless CSS properties\r\n     * @param html The input HTML\r\n     * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing\r\n     * @param preserveFragmentOnly If set to true, only preserve the html content between &lt;!--StartFragment--&gt; and &lt;!--Endfragment--&gt;\r\n     * @param currentStyles Current inheritable CSS styles\r\n     */\r\n    exec(\r\n        html: string,\r\n        convertCssOnly?: boolean,\r\n        preserveFragmentOnly?: boolean,\r\n        currentStyles?: StringMap\r\n    ): string {\r\n        let doc = htmlToDom(html, preserveFragmentOnly);\r\n        if (doc) {\r\n            this.convertGlobalCssToInlineCss(doc);\r\n            if (!convertCssOnly) {\r\n                this.sanitize(doc.body, currentStyles);\r\n            }\r\n        }\r\n        return (doc && doc.body && doc.body.innerHTML) || '';\r\n    }\r\n\r\n    /**\r\n     * Sanitize an HTML element, remove unnecessary or dangerous elements/attribute/CSS rules\r\n     * @param rootNode Root node to sanitize\r\n     * @param currentStyles Current CSS styles. Inheritable styles in the given node which has\r\n     * the same value with current styles will be ignored.\r\n     */\r\n    sanitize(rootNode: HTMLElement, currentStyles?: StringMap) {\r\n        if (!rootNode) {\r\n            return '';\r\n        }\r\n        currentStyles = cloneObject(currentStyles, getInheritableStyles(null));\r\n        this.processNode(rootNode, currentStyles, {});\r\n    }\r\n\r\n    /**\r\n     * Convert global CSS into inline CSS\r\n     * @param rootNode The HTML Document\r\n     */\r\n    convertGlobalCssToInlineCss(rootNode: HTMLDocument) {\r\n        let styleNodes = toArray(rootNode.querySelectorAll('style'));\r\n        let styleSheets = this.additionalGlobalStyleNodes\r\n            .reverse()\r\n            .map(node => node.sheet as CSSStyleSheet)\r\n            .concat(styleNodes.map(node => node.sheet as CSSStyleSheet).reverse())\r\n            .filter(sheet => sheet);\r\n        for (let styleSheet of styleSheets) {\r\n            for (let j = styleSheet.cssRules.length - 1; j >= 0; j--) {\r\n                // Skip any none-style rule, i.e. @page\r\n                let styleRule = styleSheet.cssRules[j] as CSSStyleRule;\r\n                let text = styleRule && styleRule.style ? styleRule.style.cssText : null;\r\n                if (styleRule.type != CSSRule.STYLE_RULE || !text || !styleRule.selectorText) {\r\n                    continue;\r\n                }\r\n                // Make sure the selector is not empty\r\n                for (let selector of styleRule.selectorText.split(',')) {\r\n                    if (!selector || !selector.trim() || selector.indexOf(':') >= 0) {\r\n                        continue;\r\n                    }\r\n                    let nodes = toArray(rootNode.querySelectorAll(selector));\r\n                    // Always put existing styles after so that they have higher priority\r\n                    // Which means if both global style and inline style apply to the same element,\r\n                    // inline style will have higher priority\r\n                    nodes.forEach(node =>\r\n                        node.setAttribute('style', text + (node.getAttribute('style') || ''))\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        styleNodes.forEach(node => {\r\n            if (node.parentNode) {\r\n                node.parentNode.removeChild(node);\r\n            }\r\n        });\r\n    }\r\n\r\n    private processNode(node: Node, currentStyle: StringMap, context: Object) {\r\n        let nodeType = node.nodeType;\r\n        let isElement = nodeType == Node.ELEMENT_NODE;\r\n        let isText = nodeType == Node.TEXT_NODE;\r\n        let element = <HTMLElement>node;\r\n        let tag = isElement ? element.tagName.toUpperCase() : '';\r\n\r\n        if (\r\n            (isElement && !this.allowElement(element, tag, context)) ||\r\n            (isText && /^[\\r\\n]*$/g.test(node.nodeValue) && !currentStyle.insidePRE) ||\r\n            (!isElement && !isText)\r\n        ) {\r\n            node.parentNode.removeChild(node);\r\n        } else if (\r\n            isText &&\r\n            !this.allowPreserveWhiteSpace &&\r\n            currentStyle['white-space'] == 'pre'\r\n        ) {\r\n            node.nodeValue = node.nodeValue.replace(/^ /gm, '\\u00A0').replace(/ {2}/g, ' \\u00A0');\r\n        } else if (isElement) {\r\n            let thisStyle = cloneObject(currentStyle);\r\n            this.processAttributes(element, context);\r\n            this.processCss(element, tag, thisStyle, context);\r\n\r\n            // Special handling for PRE tag, need to preserve \\r\\n inside PRE\r\n            if (tag == 'PRE') {\r\n                thisStyle.insidePRE = 'true';\r\n            }\r\n\r\n            let child: Node = element.firstChild;\r\n            let next: Node;\r\n            for (; child; child = next) {\r\n                next = child.nextSibling;\r\n                this.processNode(child, thisStyle, context);\r\n            }\r\n        }\r\n    }\r\n\r\n    private processCss(element: HTMLElement, tag: string, thisStyle: StringMap, context: Object) {\r\n        let styleNode = element.getAttributeNode('style');\r\n        if (!styleNode) {\r\n            return;\r\n        }\r\n\r\n        let source = styleNode.value.split(';');\r\n        let result = source.filter(style => {\r\n            let pair: string[];\r\n\r\n            if (!style || style.trim() == '' || (pair = style.split(':')).length != 2) {\r\n                return false;\r\n            }\r\n\r\n            let name = pair[0].trim().toLowerCase();\r\n            let value = pair[1].trim().toLowerCase();\r\n            let callback = this.styleCallbacks[name];\r\n            let isInheritable = thisStyle[name] != undefined;\r\n            let keep =\r\n                (!callback || callback(value, element, context)) &&\r\n                value != 'inherit' &&\r\n                value.indexOf('expression') < 0 &&\r\n                name.substr(0, 1) != '-' &&\r\n                this.defaultStyleValues[name] != value &&\r\n                ((isInheritable && value != thisStyle[name]) ||\r\n                    (!isInheritable && value != 'initial' && value != 'normal'));\r\n            if (keep && isInheritable) {\r\n                thisStyle[name] = value;\r\n            }\r\n            return keep && (this.allowPreserveWhiteSpace || name != 'white-space');\r\n        });\r\n\r\n        if (source.length != result.length) {\r\n            if (result.length > 0) {\r\n                element.setAttribute('style', result.map(s => s.trim()).join('; '));\r\n            } else {\r\n                element.removeAttribute('style');\r\n            }\r\n        }\r\n    }\r\n\r\n    private processAttributes(element: HTMLElement, context: Object) {\r\n        for (let i = element.attributes.length - 1; i >= 0; i--) {\r\n            let attribute = element.attributes[i];\r\n            let name = attribute.name.toLowerCase().trim();\r\n            let value = attribute.value;\r\n            let callback = this.attributeCallbacks[name];\r\n\r\n            if (callback) {\r\n                value = callback(value, element, context);\r\n            } else if (this.allowedAttributes.indexOf(name) < 0) {\r\n                value = null;\r\n            }\r\n\r\n            if (\r\n                value === null ||\r\n                value === undefined ||\r\n                value.toLowerCase().indexOf('script:') >= 0\r\n            ) {\r\n                element.removeAttribute(name);\r\n            } else {\r\n                attribute.value = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    private allowElement(element: HTMLElement, tag: string, context: Object): boolean {\r\n        let callback = this.elementCallbacks[tag];\r\n        return callback\r\n            ? callback(element, context)\r\n            : this.allowedTags.indexOf(tag) >= 0 || tag.indexOf(':') > 0;\r\n    }\r\n}\r\n\r\nfunction toArray<T extends Node>(list: NodeListOf<T>): T[] {\r\n    return [].slice.call(list) as T[];\r\n}\r\n","import { cloneObject } from './cloneObject';\r\nimport { StringMap, StyleCallbackMap } from '../types/maps';\r\n\r\nconst ALLOWED_HTML_TAGS = (\r\n    'BODY,H1,H2,H3,H4,H5,H6,FORM,P,BR,NOBR,HR,ACRONYM,ABBR,ADDRESS,B,' +\r\n    'BDI,BDO,BIG,BLOCKQUOTE,CENTER,CITE,CODE,DEL,DFN,EM,FONT,I,INS,KBD,MARK,METER,PRE,PROGRESS,' +\r\n    'Q,RP,RT,RUBY,S,SAMP,SMALL,STRIKE,STRONG,SUB,SUP,TEMPLATE,TIME,TT,U,VAR,WBR,XMP,INPUT,TEXTAREA,' +\r\n    'BUTTON,SELECT,OPTGROUP,OPTION,LABEL,FIELDSET,LEGEND,DATALIST,OUTPUT,IMG,MAP,AREA,CANVAS,FIGCAPTION,' +\r\n    'FIGURE,PICTURE,A,NAV,UL,OL,LI,DIR,UL,DL,DT,DD,MENU,MENUITEM,TABLE,CAPTION,TH,TR,TD,THEAD,TBODY,' +\r\n    'TFOOT,COL,COLGROUP,DIV,SPAN,HEADER,FOOTER,MAIN,SECTION,ARTICLE,ASIDE,DETAILS,DIALOG,SUMMARY,DATA'\r\n).split(',');\r\n\r\nconst ALLOWED_HTML_ATTRIBUTES = (\r\n    'accept,align,alt,checked,cite,color,cols,colspan,contextmenu,' +\r\n    'coords,datetime,default,dir,dirname,disabled,download,face,headers,height,hidden,high,href,' +\r\n    'hreflang,ismap,kind,label,lang,list,low,max,maxlength,media,min,multiple,open,optimum,pattern,' +\r\n    'placeholder,readonly,rel,required,reversed,rows,rowspan,scope,selected,shape,size,sizes,span,' +\r\n    'spellcheck,src,srclang,srcset,start,step,style,tabindex,target,title,translate,type,usemap,value,' +\r\n    'width,wrap'\r\n).split(',');\r\n\r\nconst DEFAULT_STYLE_VALUES: { [name: string]: string } = {\r\n    'background-color': 'transparent',\r\n    'border-bottom-color': 'rgb(0, 0, 0)',\r\n    'border-bottom-style': 'none',\r\n    'border-bottom-width': '0px',\r\n    'border-image-outset': '0',\r\n    'border-image-repeat': 'stretch',\r\n    'border-image-slice': '100%',\r\n    'border-image-source': 'none',\r\n    'border-image-width': '1',\r\n    'border-left-color': 'rgb(0, 0, 0)',\r\n    'border-left-style': 'none',\r\n    'border-left-width': '0px',\r\n    'border-right-color': 'rgb(0, 0, 0)',\r\n    'border-right-style': 'none',\r\n    'border-right-width': '0px',\r\n    'border-top-color': 'rgb(0, 0, 0)',\r\n    'border-top-style': 'none',\r\n    'border-top-width': '0px',\r\n    'outline-color': 'transparent',\r\n    'outline-style': 'none',\r\n    'outline-width': '0px',\r\n    overflow: 'visible',\r\n    'text-decoration': 'none',\r\n    '-webkit-text-stroke-width': '0px',\r\n    'word-wrap': 'break-word',\r\n    'margin-left': '0px',\r\n    'margin-right': '0px',\r\n    padding: '0px',\r\n    'padding-top': '0px',\r\n    'padding-left': '0px',\r\n    'padding-right': '0px',\r\n    'padding-bottom': '0px',\r\n    border: '0px',\r\n    'border-top': '0px',\r\n    'border-left': '0px',\r\n    'border-right': '0px',\r\n    'border-bottom': '0px',\r\n    'vertical-align': 'baseline',\r\n    float: 'none',\r\n};\r\n\r\nexport function getAllowedTags(additionalTags: string[]): string[] {\r\n    return unique(ALLOWED_HTML_TAGS.concat(additionalTags || [])).map(tag => tag.toUpperCase());\r\n}\r\n\r\nexport function getAllowedAttributes(additionalAttributes: string[]): string[] {\r\n    return unique(ALLOWED_HTML_ATTRIBUTES.concat(additionalAttributes || [])).map(attr =>\r\n        attr.toLocaleLowerCase()\r\n    );\r\n}\r\n\r\nexport function getDefaultStyleValues(additionalDefaultStyles: StringMap): StringMap {\r\n    let result = cloneObject(DEFAULT_STYLE_VALUES);\r\n    if (additionalDefaultStyles) {\r\n        Object.keys(additionalDefaultStyles).forEach(name => {\r\n            let value = additionalDefaultStyles[name];\r\n            if (value !== null && value !== undefined) {\r\n                result[name] = value;\r\n            } else {\r\n                delete result[name];\r\n            }\r\n        });\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nexport function getStyleCallbacks(callbacks: StyleCallbackMap): StyleCallbackMap {\r\n    let result = cloneObject(callbacks);\r\n    result.position = result.position || removeValue;\r\n    result.width = result.width || removeWidthForLiAndDiv;\r\n    return result;\r\n}\r\n\r\nfunction removeValue(): null {\r\n    return null;\r\n}\r\n\r\nfunction removeWidthForLiAndDiv(value: string, element: HTMLElement) {\r\n    let tag = element.tagName;\r\n    return !(tag == 'LI' || tag == 'DIV');\r\n}\r\n\r\nfunction unique<T>(array: T[]): T[] {\r\n    return array.filter((value, index, self) => self.indexOf(value) == index);\r\n}\r\n","import { createWordConverter } from './wordConverter';\r\nimport { createWordConverterArguments } from './WordConverterArguments';\r\nimport { HtmlSanitizer } from 'roosterjs-html-sanitizer';\r\nimport { processNodeConvert, processNodesDiscovery } from './converterUtils';\r\n\r\n/** Converts all the Word generated list items in the specified node into standard HTML UL and OL tags */\r\nexport default function convertPastedContentFromWord(doc: HTMLDocument) {\r\n    let sanitizer = new HtmlSanitizer({\r\n        elementCallbacks: {\r\n            ['O:P']: () => false,\r\n        },\r\n        additionalAllowAttributes: ['class'],\r\n    });\r\n    sanitizer.sanitize(doc.body);\r\n\r\n    let wordConverter = createWordConverter();\r\n\r\n    // First find all the nodes that we need to check for list item information\r\n    // This call will return all the p and header elements under the root node.. These are the elements that\r\n    // Word uses a list items, so we'll only process them and avoid walking the whole tree.\r\n    let elements = doc.querySelectorAll('p');\r\n    if (elements.length > 0) {\r\n        wordConverter.wordConverterArgs = createWordConverterArguments(elements);\r\n        if (processNodesDiscovery(wordConverter)) {\r\n            processNodeConvert(wordConverter);\r\n        }\r\n    }\r\n}\r\n","import CustomData, { createCustomData } from './CustomData';\r\nimport WordConverterArguments from './WordConverterArguments';\r\n\r\n/** Processes HTML generated by Word, converting Word Lists into standard HTML UL and OL tags */\r\nexport default interface WordConverter {\r\n    /** Next unique id to be assigned to a list */\r\n    nextUniqueId: number;\r\n\r\n    /** Number of bullets converted */\r\n    numBulletsConverted: number;\r\n\r\n    /** Number of numbering converted */\r\n    numNumberedConverted: number;\r\n\r\n    /** The structure that records the status of the conversion */\r\n    wordConverterArgs: WordConverterArguments;\r\n\r\n    /** Custom data storage for list items */\r\n    customData: CustomData;\r\n}\r\n\r\n/** create an empty WordConverter */\r\nexport function createWordConverter(): WordConverter {\r\n    return {\r\n        nextUniqueId: 1,\r\n        numBulletsConverted: 0,\r\n        numNumberedConverted: 0,\r\n        wordConverterArgs: null,\r\n        customData: createCustomData(),\r\n    };\r\n}\r\n","import LevelLists, { createLevelLists } from './LevelLists';\r\nimport ListItemMetadata from './ListItemMetadata';\r\nimport ListMetadata from './ListMetadata';\r\n\r\n/** Contains the state of the WordConverter when called back after yielding */\r\nexport default interface WordConverterArguments {\r\n    /** The list of element nodes being processed */\r\n    nodes: NodeListOf<HTMLElement>;\r\n\r\n    /** The index of the element currently being processed */\r\n    currentIndex: number;\r\n\r\n    /**\r\n     * Holds the metadata for all the lists we have found\r\n     * key: unique list id, value: list metadata\r\n     */\r\n    lists: { [key: string]: ListMetadata };\r\n\r\n    /**\r\n     * Stores the list item metatada of the items we\r\n     * have found that need to be converted\r\n     */\r\n    listItems: ListItemMetadata[];\r\n\r\n    /**\r\n     * This array holds the list id of the lists we are processing\r\n     * that are next to each other.. This list will be used to determine\r\n     * if list items are next to each other or if they are separated...\r\n     * Separated items are ignored from the conversion\r\n     */\r\n\r\n    currentListIdsByLevels: LevelLists[];\r\n\r\n    /** Remembers the item that was last processed  */\r\n    lastProcessedItem: HTMLElement;\r\n}\r\n\r\n/** create an empty WordConverterArguments */\r\nexport function createWordConverterArguments(\r\n    nodes: NodeListOf<HTMLElement>\r\n): WordConverterArguments {\r\n    return {\r\n        nodes: nodes,\r\n        currentIndex: 0,\r\n        lists: {},\r\n        listItems: [],\r\n        currentListIdsByLevels: [createLevelLists()],\r\n        lastProcessedItem: null,\r\n    };\r\n}\r\n","import ListItemMetadata from './ListItemMetadata';\r\nimport ListMetadata from './ListMetadata';\r\nimport WordConverter from './wordConverter';\r\nimport WordConverterArguments from './WordConverterArguments';\r\nimport { createLevelLists } from './LevelLists';\r\nimport { getObject, setObject } from './CustomData';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\n/** Word list metadata style name */\r\nconst LOOKUP_DEPTH = 5;\r\n\r\n/** Name for the word list id property in the custom data */\r\nconst UNIQUE_LIST_ID_CUSTOM_DATA = 'UniqueListId';\r\n\r\n/** Word list metadata style name */\r\nconst MSO_LIST_STYLE_NAME = 'mso-list';\r\n\r\n/** Regular expression to match line breaks */\r\nconst LINE_BREAKS = /[\\n|\\r]/gi;\r\n\r\n/**\r\n * Handles the pass 1: Discovery\r\n * During discovery, we'll parse the metadata out of the elements and store it in the list items dictionary.\r\n * We'll detect cases where the list items for a particular ordered list are not next to each other. Word does these\r\n * for numbered headers, and we don't want to convert those, because the numbering would be completely wrong.\r\n */\r\nexport function processNodesDiscovery(wordConverter: WordConverter): boolean {\r\n    let args = wordConverter.wordConverterArgs;\r\n    while (args.currentIndex < args.nodes.length) {\r\n        let node = args.nodes.item(args.currentIndex);\r\n\r\n        // Try to get the list metadata for the specified node\r\n        let itemMetadata = getListItemMetadata(node);\r\n        if (itemMetadata) {\r\n            let levelInfo =\r\n                args.currentListIdsByLevels[itemMetadata.level - 1] || createLevelLists();\r\n            args.currentListIdsByLevels[itemMetadata.level - 1] = levelInfo;\r\n\r\n            // We need to drop some list information if this is not an item next to another\r\n            if (args.lastProcessedItem && getRealPreviousSibling(node) != args.lastProcessedItem) {\r\n                // This list item is not next to the previous one. This means that there is some content in between them\r\n                // so we need to reset our list of list ids per level\r\n                resetCurrentLists(args);\r\n            }\r\n\r\n            // Get the list metadata for the list that will hold this item\r\n            let listMetadata = levelInfo.listsMetadata[itemMetadata.wordListId];\r\n            if (!listMetadata) {\r\n                // Get the first item fake bullet.. This will be used later to check what is the right type of list\r\n                let firstFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\r\n\r\n                // This is a the first item of a list.. We'll create the list metadata using the information\r\n                // we already have from this first item\r\n                listMetadata = {\r\n                    numberOfItems: 0,\r\n                    uniqueListId: wordConverter.nextUniqueId++,\r\n                    firstFakeBullet: firstFakeBullet,\r\n\r\n                    // If the bullet we got is emtpy or not found, we ignore the list out.. this means\r\n                    // that this is not an item we need to convert of that the format doesn't match what\r\n                    // we are expecting\r\n                    ignore: !firstFakeBullet || firstFakeBullet.length == 0,\r\n\r\n                    // We'll use the first fake bullet to try to figure out which type of list we create. If this list has a second\r\n                    // item, we'll perform a better comparasion, but for one item lists, this will be check that will determine the list type\r\n                    tagName: getFakeBulletTagName(firstFakeBullet),\r\n                };\r\n                levelInfo.listsMetadata[itemMetadata.wordListId] = listMetadata;\r\n                args.lists[listMetadata.uniqueListId.toString()] = listMetadata;\r\n            } else if (!listMetadata.ignore && listMetadata.numberOfItems == 1) {\r\n                // This is the second item we've seen for this list.. we'll compare the 2 fake bullet\r\n                // items we have an decide if we create ordered or unordered lists based on this.\r\n                // This is the best way we can do this since we cannot read the metadata that Word\r\n                // puts in the head of the HTML...\r\n                let secondFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\r\n                listMetadata.tagName =\r\n                    listMetadata.firstFakeBullet == secondFakeBullet ? 'UL' : 'OL';\r\n            }\r\n\r\n            // Set the unique id to the list\r\n            itemMetadata.uniqueListId = listMetadata.uniqueListId;\r\n\r\n            // Check if we need to ignore this list... we'll either know already that we need to ignore\r\n            // it, or we'll know it because the previous list items are not next to this one\r\n            if (\r\n                listMetadata.ignore ||\r\n                (listMetadata.tagName == 'OL' &&\r\n                    listMetadata.numberOfItems > 0 &&\r\n                    levelInfo.currentUniqueListId != itemMetadata.uniqueListId)\r\n            ) {\r\n                // We need to ignore this item... and we also need to forget about the lists that\r\n                // are not at the root level\r\n                listMetadata.ignore = true;\r\n                args.currentListIdsByLevels[0].currentUniqueListId = -1;\r\n                args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, 1);\r\n            } else {\r\n                // This is an item we don't need to ignore... If added lists deep under this one before\r\n                // we'll drop their ids from the list of ids per level.. this is because this list item\r\n                // breaks the deeper lists.\r\n                if (args.currentListIdsByLevels.length > itemMetadata.level) {\r\n                    args.currentListIdsByLevels = args.currentListIdsByLevels.slice(\r\n                        0,\r\n                        itemMetadata.level\r\n                    );\r\n                }\r\n\r\n                levelInfo.currentUniqueListId = itemMetadata.uniqueListId;\r\n\r\n                // Add the list item into the list of items to be processed\r\n                args.listItems.push(itemMetadata);\r\n                listMetadata.numberOfItems++;\r\n            }\r\n\r\n            args.lastProcessedItem = node;\r\n        } else {\r\n            // Here, we know that this is not a list item, but we'll want to check if it is one \"no bullet\" list items...\r\n            // these can be created by creating a bullet and hitting delete on it it... The content will continue to be indented, but there will\r\n            // be no bullet and the list will continue correctly after that. Visually, it looks like the previous item has multiple lines, but\r\n            // the HTML generated has multiple paragraphs with the same class. We'll merge these when we find them, so the logic doesn't skips\r\n            // the list conversion thinking that the list items are not together...\r\n            let last = args.lastProcessedItem;\r\n            if (\r\n                last &&\r\n                getRealPreviousSibling(node) == last &&\r\n                node.tagName == last.tagName &&\r\n                node.className == last.className\r\n            ) {\r\n                // Add 2 line breaks and move all the nodes to the last item\r\n                last.appendChild(last.ownerDocument.createElement('br'));\r\n                last.appendChild(last.ownerDocument.createElement('br'));\r\n                while (node.firstChild != null) {\r\n                    last.appendChild(node.firstChild);\r\n                }\r\n\r\n                // Remove the item that we don't need anymore\r\n                node.parentNode.removeChild(node);\r\n            }\r\n        }\r\n\r\n        // Move to the next element are return true if more elements need to be processed\r\n        args.currentIndex++;\r\n    }\r\n\r\n    return args.listItems.length > 0;\r\n}\r\n\r\n/**\r\n * Handles the pass 2: Conversion\r\n * During conversion, we'll go over the elements that belong to a list that we've marked as a list to convert, and we'll perform the\r\n * conversion needed\r\n */\r\nexport function processNodeConvert(wordConverter: WordConverter): boolean {\r\n    let args = wordConverter.wordConverterArgs;\r\n    args.currentIndex = 0;\r\n\r\n    while (args.currentIndex < args.listItems.length) {\r\n        let metadata = args.listItems[args.currentIndex];\r\n        let node = metadata.originalNode;\r\n        let listMetadata = args.lists[metadata.uniqueListId.toString()];\r\n        if (!listMetadata.ignore) {\r\n            // We have a list item that we need to convert, get or create the list\r\n            // that hold this item out\r\n            let list = getOrCreateListForNode(wordConverter, node, metadata, listMetadata);\r\n            if (list) {\r\n                // Clean the element out.. this call gets rid of the fake bullet and unneeded nodes\r\n                cleanupListIgnore(node, LOOKUP_DEPTH);\r\n\r\n                // Create a new list item and transfer the children\r\n                let li = node.ownerDocument.createElement('LI');\r\n                while (node.firstChild) {\r\n                    li.appendChild(node.firstChild);\r\n                }\r\n\r\n                // Append the list item into the list\r\n                list.appendChild(li);\r\n\r\n                // Remove the node we just converted\r\n                node.parentNode.removeChild(node);\r\n\r\n                if (listMetadata.tagName == 'UL') {\r\n                    wordConverter.numBulletsConverted++;\r\n                } else {\r\n                    wordConverter.numNumberedConverted++;\r\n                }\r\n            }\r\n        }\r\n\r\n        args.currentIndex++;\r\n    }\r\n\r\n    return wordConverter.numBulletsConverted > 0 || wordConverter.numNumberedConverted > 0;\r\n}\r\n\r\n/**\r\n * Gets or creates the list (UL or OL) that holds this item out based on the\r\n * items content and the specified metadata\r\n */\r\nfunction getOrCreateListForNode(\r\n    wordConverter: WordConverter,\r\n    node: HTMLElement,\r\n    metadata: ListItemMetadata,\r\n    listMetadata: ListMetadata\r\n): Node {\r\n    // First get the last list next to this node under the specified level. This code\r\n    // path will return the list or will create lists if needed\r\n    let list = recurringGetOrCreateListAtNode(node, metadata.level, listMetadata);\r\n\r\n    // Here use the unique list ID to detect if we have the right list...\r\n    // it is possible to have 2 different lists next to each other with different formats, so\r\n    // we want to detect this an create separate lists for those cases\r\n    let listId = getObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA);\r\n\r\n    // If we have a list with and ID, but the ID is different than the ID for this list item, this\r\n    // is a completely new list, so we'll append a new list for that\r\n    if ((listId && listId != metadata.uniqueListId) || (!listId && list.firstChild)) {\r\n        let newList = node.ownerDocument.createElement(listMetadata.tagName);\r\n        list.parentNode.insertBefore(newList, list.nextSibling);\r\n        list = newList;\r\n    }\r\n\r\n    // Set the list id into the custom data\r\n    setObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA, metadata.uniqueListId);\r\n\r\n    // This call will convert the list if needed to the right type of list required. This can happen\r\n    // on the cases where the first list item for this list is located after a deeper list. for that\r\n    // case, we will have created a UL for it, and we may need to convert it\r\n    return convertListIfNeeded(wordConverter, list, listMetadata);\r\n}\r\n\r\n/**\r\n * Converts the list between UL and OL if needed, by using the fake bullet and\r\n * information already stored in the list itself\r\n */\r\nfunction convertListIfNeeded(\r\n    wordConverter: WordConverter,\r\n    list: Node,\r\n    listMetadata: ListMetadata\r\n): Node {\r\n    // Check if we need to convert the list out\r\n    if (listMetadata.tagName != getTagOfNode(list)) {\r\n        // We have the wrong list type.. convert it, set the id again and tranfer all the childs\r\n        let newList = list.ownerDocument.createElement(listMetadata.tagName);\r\n        setObject(\r\n            wordConverter.customData,\r\n            newList,\r\n            UNIQUE_LIST_ID_CUSTOM_DATA,\r\n            getObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA)\r\n        );\r\n        while (list.firstChild) {\r\n            newList.appendChild(list.firstChild);\r\n        }\r\n        list.parentNode.insertBefore(newList, list);\r\n        list.parentNode.removeChild(list);\r\n        list = newList;\r\n    }\r\n\r\n    return list;\r\n}\r\n\r\n/**\r\n * Gets or creates the specified list\r\n */\r\nfunction recurringGetOrCreateListAtNode(\r\n    node: HTMLElement,\r\n    level: number,\r\n    listMetadata: ListMetadata\r\n): Node {\r\n    let parent: Node = null;\r\n    let possibleList: Node;\r\n    if (level == 1) {\r\n        // Root case, we'll check if the list is the previous sibling of the node\r\n        possibleList = getRealPreviousSibling(node);\r\n    } else {\r\n        // If we get here, we are looking for level 2 or deeper... get the upper list\r\n        // and check if the last element is a list\r\n        parent = recurringGetOrCreateListAtNode(node, level - 1, null);\r\n        possibleList = parent.lastChild;\r\n    }\r\n\r\n    // Check the element that we got and verify that it is a list\r\n    if (possibleList && possibleList.nodeType == NodeType.Element) {\r\n        let tag = getTagOfNode(possibleList);\r\n        if (tag == 'UL' || tag == 'OL') {\r\n            // We have a list.. use it\r\n            return possibleList;\r\n        }\r\n    }\r\n\r\n    // If we get here, it means we don't have a list and we need to create one\r\n    // this code path will always create new lists as UL lists\r\n    let newList = node.ownerDocument.createElement(listMetadata ? listMetadata.tagName : 'UL');\r\n    if (level == 1) {\r\n        // For level 1, we'll insert the list beofre the node\r\n        node.parentNode.insertBefore(newList, node);\r\n    } else {\r\n        // Any level 2 or above, we insert the list as the last\r\n        // child of the upper level list\r\n        parent.appendChild(newList);\r\n    }\r\n\r\n    return newList;\r\n}\r\n\r\n/**\r\n * Cleans up the node children by removing the childs marked as mso-list: Ignore.\r\n * This nodes hold the fake bullet information that Word puts in and when\r\n * conversion is happening, we want to get rid of these elements\r\n */\r\nfunction cleanupListIgnore(node: Node, levels: number) {\r\n    let nodesToRemove: Node[] = [];\r\n\r\n    for (let child: Node = node.firstChild; child; child = child.nextSibling) {\r\n        // Clean up the item internally first if we need to based on the number of levels\r\n        if (child.nodeType == NodeType.Element && levels > 1) {\r\n            cleanupListIgnore(child, levels - 1);\r\n        }\r\n\r\n        // Try to convert word comments into ignore elements if we haven't done so for this element\r\n        child = fixWordListComments(child, true /*removeComments*/);\r\n\r\n        // Check if we can remove this item out\r\n        if (isEmptySpan(child) || isIgnoreNode(child)) {\r\n            nodesToRemove.push(child);\r\n        }\r\n    }\r\n\r\n    nodesToRemove.forEach(child => node.removeChild(child));\r\n}\r\n\r\n/**\r\n * Reads the word list metadada out of the specified node. If the node\r\n * is not a Word list item, it returns null.\r\n */\r\nfunction getListItemMetadata(node: HTMLElement): ListItemMetadata {\r\n    if (node.nodeType == NodeType.Element) {\r\n        let listatt = getStyleValue(node, MSO_LIST_STYLE_NAME);\r\n        if (listatt && listatt.length > 0) {\r\n            try {\r\n                // Word mso-list property holds 3 space separated values in the following format: lst1 level1 lfo0\r\n                // Where:\r\n                // (0) List identified for the metadata in the &lt;head&gt; of the document. We cannot read the &lt;head&gt; metada\r\n                // (1) Level of the list. This also maps to the &lt;head&gt; metadata that we cannot read, but\r\n                // for almost all cases, it maps to the list identation (or level). We'll use it as the\r\n                // list indentation value\r\n                // (2) Contains a specific list identifier.\r\n                // Example value: \"l0 level1 lfo1\"\r\n                let listprops = listatt.split(' ');\r\n                if (listprops.length == 3) {\r\n                    return <ListItemMetadata>{\r\n                        level: parseInt(listprops[1].substr('level'.length)),\r\n                        wordListId: listatt,\r\n                        originalNode: node,\r\n                        uniqueListId: 0,\r\n                    };\r\n                }\r\n            } catch (e) {}\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction isFakeBullet(fakeBullet: string): boolean {\r\n    return ['o', '', '', '-'].indexOf(fakeBullet) >= 0;\r\n}\r\n\r\n/** Given a fake bullet text, returns the type of list that should be used for it */\r\nfunction getFakeBulletTagName(fakeBullet: string): string {\r\n    return isFakeBullet(fakeBullet) ? 'UL' : 'OL';\r\n}\r\n\r\n/**\r\n * Finds the fake bullet text out of the specified node and returns it. For images, it will return\r\n * a bullet string. If not found, it returns null...\r\n */\r\nfunction getFakeBulletText(node: Node, levels: number): string {\r\n    // Word uses the following format for their bullets:\r\n    // &lt;p style=\"mso-list:l1 level1 lfo2\"&gt;\r\n    // &lt;span style=\"...\"&gt;\r\n    // &lt;span style=\"mso-list:Ignore\"&gt;1.&lt;span style=\"...\"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt;\r\n    // &lt;/span&gt;\r\n    // Content here...\r\n    // &lt;/p&gt;\r\n    //\r\n    // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That\r\n    // text or image node will be the fake bullet we are looking for\r\n    let result: string = null;\r\n    let child: Node = node.firstChild;\r\n    while (!result && child) {\r\n        // First, check if we need to convert the Word list comments into real elements\r\n        child = fixWordListComments(child, true /*removeComments*/);\r\n\r\n        // Check if this is the node that holds the fake bullets (mso-list: Ignore)\r\n        if (isIgnoreNode(child)) {\r\n            // Yes... this is the node that holds either the text or image data\r\n            result = child.textContent.trim();\r\n\r\n            // This is the case for image case\r\n            if (result.length == 0) {\r\n                result = 'o';\r\n            }\r\n        } else if (child.nodeType == NodeType.Element && levels > 1) {\r\n            // If this is an element and we are not in the last level, try to get the fake bullet\r\n            // out of the child\r\n            result = getFakeBulletText(child, levels - 1);\r\n        }\r\n\r\n        child = child.nextSibling;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * If the specified element is a Word List comments, this code verifies and fixes\r\n * the markup when needed to ensure that Chrome bullet conversions work as expected\r\n * -----\r\n * We'll convert &lt;!--[if !supportLists]--&gt; and &lt;!--[endif]--&gt; comments into\r\n * &lt;span style=\"mso-list:Ignore\"&gt;&lt;/span&gt;... Chrome has a bug where it drops the\r\n * styles of the span, but we'll use these comments to recreate them out\r\n */\r\nfunction fixWordListComments(child: Node, removeComments: boolean): Node {\r\n    if (child.nodeType == NodeType.Comment) {\r\n        let value = (child as Comment).data;\r\n        if (value && value.trim().toLowerCase() == '[if !supportlists]') {\r\n            // We have a list ignore start, find the end.. We know is not more than\r\n            // 3 nodes away, so we'll optimize our checks\r\n            let nextElement = child;\r\n            let endComment: Node = null;\r\n            for (let j = 0; j < 4; j++) {\r\n                nextElement = getRealNextSibling(nextElement);\r\n                if (!nextElement) {\r\n                    break;\r\n                }\r\n                if (nextElement.nodeType == NodeType.Comment) {\r\n                    value = (nextElement as Comment).data;\r\n                    if (value && value.trim().toLowerCase() == '[endif]') {\r\n                        endComment = nextElement;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // if we found the end node, wrap everything out\r\n            if (endComment) {\r\n                let newSpan = child.ownerDocument.createElement('span');\r\n                newSpan.setAttribute('style', 'mso-list: ignore');\r\n                nextElement = getRealNextSibling(child);\r\n                while (nextElement != endComment) {\r\n                    nextElement = nextElement.nextSibling as HTMLElement;\r\n                    newSpan.appendChild(nextElement.previousSibling);\r\n                }\r\n\r\n                // Insert the element out and use that one as the current child\r\n                endComment.parentNode.insertBefore(newSpan, endComment);\r\n\r\n                // Remove the comments out if the call specified it out\r\n                if (removeComments) {\r\n                    child.parentNode.removeChild(child);\r\n                    endComment.parentNode.removeChild(endComment);\r\n                }\r\n\r\n                // Last, make sure we return the new element out instead of the comment\r\n                child = newSpan;\r\n            }\r\n        }\r\n    }\r\n\r\n    return child;\r\n}\r\n\r\n/** Finds the real previous sibling, ignoring emtpy text nodes */\r\nfunction getRealPreviousSibling(node: Node): Node {\r\n    let prevSibling = node;\r\n    do {\r\n        prevSibling = prevSibling.previousSibling;\r\n    } while (prevSibling && isEmptyTextNode(prevSibling));\r\n    return prevSibling;\r\n}\r\n\r\n/** Finds the real next sibling, ignoring empty text nodes */\r\nfunction getRealNextSibling(node: Node): Node {\r\n    let nextSibling = node;\r\n    do {\r\n        nextSibling = nextSibling.nextSibling;\r\n    } while (nextSibling && isEmptyTextNode(nextSibling));\r\n\r\n    return nextSibling;\r\n}\r\n\r\n/**\r\n * Checks if the specified node is marked as a mso-list: Ignore. These\r\n * nodes need to be ignored when a list item is converted into standard\r\n * HTML lists\r\n */\r\nfunction isIgnoreNode(node: Node): boolean {\r\n    if (node.nodeType == NodeType.Element) {\r\n        let listatt = getStyleValue(node as HTMLElement, MSO_LIST_STYLE_NAME);\r\n        if (listatt && listatt.length > 0 && listatt.trim().toLowerCase() == 'ignore') {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/** Checks if the specified node is an empty span. */\r\nfunction isEmptySpan(node: Node): boolean {\r\n    return getTagOfNode(node) == 'SPAN' && !node.firstChild;\r\n}\r\n\r\n/** Reads the specified style value from the node */\r\nfunction getStyleValue(node: HTMLElement, styleName: string): string {\r\n    // Word uses non-standard names for the metadata that puts in the style of the element...\r\n    // Most browsers will not provide the information for those unstandard values throug the node.style\r\n    // property, so the only reliable way to read them is to get the attribute directly and do\r\n    // the required parsing..\r\n    let textStyle = node.getAttribute('style');\r\n    if (textStyle && textStyle.length > 0 && textStyle.indexOf(styleName) >= 0) {\r\n        // Split all the CSS name: value pairs\r\n        let inStyles = textStyle.split(';');\r\n        for (let i = 0; i < inStyles.length; i++) {\r\n            // Split the name and value\r\n            let nvpair = inStyles[i].split(':');\r\n            if (nvpair.length == 2 && nvpair[0].trim() == styleName) {\r\n                return nvpair[1].trim();\r\n            }\r\n        }\r\n    }\r\n\r\n    // As a backup mechanism, we'll still try to get the value from the style object\r\n    // Dictionary styles = (Dictionary)(object)node.Style;\r\n    // return (string)styles[styleName];\r\n    return null;\r\n}\r\n\r\n/** Checks if the node is an empty text node that can be ignored */\r\nfunction isEmptyTextNode(node: Node): boolean {\r\n    // No node is empty\r\n    if (!node) {\r\n        return true;\r\n    }\r\n\r\n    // Empty text node is empty\r\n    if (node.nodeType == NodeType.Text) {\r\n        let value = node.nodeValue;\r\n        value = value.replace(LINE_BREAKS, '');\r\n        return value.trim().length == 0;\r\n    }\r\n\r\n    // Span or Font with an empty child node is empty\r\n    let tagName = getTagOfNode(node);\r\n    if (node.firstChild == node.lastChild && (tagName == 'SPAN' || tagName == 'FONT')) {\r\n        return isEmptyTextNode(node.firstChild);\r\n    }\r\n\r\n    // If not found, then this is not empty\r\n    return false;\r\n}\r\n\r\n/** Resets the list */\r\nfunction resetCurrentLists(args: WordConverterArguments) {\r\n    for (let i = 0; i < args.currentListIdsByLevels.length; i++) {\r\n        let ll = args.currentListIdsByLevels[i];\r\n        if (ll) {\r\n            ll.currentUniqueListId = -1;\r\n        }\r\n    }\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\n\r\nvar ZERO_WIDTH_SPACE = '&#8203;';\r\n\r\n/**\r\n * Convert plain to HTML\r\n * @param text The plain text to convert\r\n * @returns HTML string to present the input text\r\n */\r\nexport default function textToHtml(text: string): string {\r\n    text = (text || '')\r\n        .replace(/&/g, '&amp;')\r\n        .replace(/</g, '&lt;')\r\n        .replace(/>/g, '&gt;')\r\n        .replace(/'/g, '&#39;')\r\n        .replace(/\"/g, '&quot;')\r\n        .replace(/^ /gm, '&nbsp;')\r\n        .replace(/\\r/g, '');\r\n    let lines = text.split('\\n');\r\n    if (lines.length == 2) {\r\n        text = `<span>${lines[0]}<br></span><span>${lines[1]}</span>`;\r\n    } else if (lines.length > 2) {\r\n        text = '';\r\n        let lineEnd = Browser.isIEOrEdge ? ZERO_WIDTH_SPACE : '<br>';\r\n        lines.forEach((line, i) => {\r\n            if (i == 0) {\r\n                text += `<span>${line}<br></span>`;\r\n            } else if (i == lines.length - 1) {\r\n                text += `<span>${line}</span>`;\r\n            } else {\r\n                text += `<div>${line}${lineEnd}</div>`;\r\n            }\r\n        });\r\n    }\r\n    text = text.replace(/\\s\\s/g, ' &nbsp;');\r\n    return text;\r\n}\r\n","import { applyFormat, getTagOfNode, wrap } from 'roosterjs-editor-dom';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport {\r\n    ChangeSource,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    ContentPosition,\r\n    ContentChangedEvent,\r\n    ExtractContentEvent,\r\n    DefaultFormat,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst WATERMARK_SPAN_ID = '_rooster_watermarkSpan';\r\nconst WATERMARK_REGEX = new RegExp(\r\n    `<span[^>]*id=['\"]?${WATERMARK_SPAN_ID}['\"]?[^>]*>[^<]*</span>`,\r\n    'ig'\r\n);\r\n\r\n/**\r\n * A watermark plugin to manage watermark string for roosterjs\r\n */\r\nexport default class Watermark implements EditorPlugin {\r\n    private editor: Editor;\r\n    private isWatermarkShowing: boolean;\r\n    private disposer: () => void;\r\n\r\n    /**\r\n     * Create an instance of Watermark plugin\r\n     * @param watermark The watermark string\r\n     */\r\n    constructor(private watermark: string, private format?: DefaultFormat) {\r\n        this.format = this.format || {\r\n            fontSize: '14px',\r\n            textColor: '#aaa',\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Watermark';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.showHideWatermark(false /*ignoreCachedState*/);\r\n        this.disposer = this.editor.addDomEventHandler({\r\n            focus: this.handleWatermark,\r\n            blur: this.handleWatermark,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.hideWatermark();\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.ContentChanged) {\r\n            // When content is changed from setContent() API, current cached state\r\n            // may not be accurate, so we ignore it\r\n            this.showHideWatermark((<ContentChangedEvent>event).source == ChangeSource.SetContent);\r\n        } else if (event.eventType == PluginEventType.ExtractContent && this.isWatermarkShowing) {\r\n            this.removeWartermarkFromHtml(event as ExtractContentEvent);\r\n        }\r\n    }\r\n\r\n    private handleWatermark = () => {\r\n        this.showHideWatermark(false /*ignoreCachedState*/);\r\n    };\r\n\r\n    private showHideWatermark(ignoreCachedState: boolean) {\r\n        if (this.editor.hasFocus() && (ignoreCachedState || this.isWatermarkShowing)) {\r\n            this.hideWatermark();\r\n            this.editor.focus();\r\n        } else if (\r\n            !this.editor.hasFocus() &&\r\n            (ignoreCachedState || !this.isWatermarkShowing) &&\r\n            this.editor.isEmpty(true /*trim*/)\r\n        ) {\r\n            this.showWatermark();\r\n        }\r\n    }\r\n\r\n    private showWatermark() {\r\n        let document = this.editor.getDocument();\r\n        let watermarkNode = wrap(\r\n            document.createTextNode(this.watermark),\r\n            `<span id=\"${WATERMARK_SPAN_ID}\"></span>`\r\n        ) as HTMLElement;\r\n        applyFormat(watermarkNode, this.format, this.editor.isDarkMode());\r\n        this.editor.insertNode(watermarkNode, {\r\n            position: ContentPosition.Begin,\r\n            updateCursor: false,\r\n            replaceSelection: false,\r\n            insertOnNewLine: false,\r\n        });\r\n        this.isWatermarkShowing = true;\r\n    }\r\n\r\n    private hideWatermark() {\r\n        this.editor.queryElements(`span[id=\"${WATERMARK_SPAN_ID}\"]`, span => {\r\n            let parentNode = span.parentNode;\r\n            this.editor.deleteNode(span);\r\n\r\n            // After remove watermark node, if it leaves an empty DIV, append a BR node into it to make it a regular empty line\r\n            if (\r\n                this.editor.contains(parentNode) &&\r\n                getTagOfNode(parentNode) == 'DIV' &&\r\n                !parentNode.firstChild\r\n            ) {\r\n                parentNode.appendChild(this.editor.getDocument().createElement('BR'));\r\n            }\r\n        });\r\n        this.isWatermarkShowing = false;\r\n    }\r\n\r\n    private removeWartermarkFromHtml(event: ExtractContentEvent) {\r\n        let content = event.content;\r\n        content = content.replace(WATERMARK_REGEX, '');\r\n        event.content = content;\r\n    }\r\n}\r\n","import { contains, fromHtml, getComputedStyle, VTable } from 'roosterjs-editor-dom';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport {\r\n    ContentPosition,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginMouseEvent,\r\n    ChangeSource,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst TABLE_RESIZE_HANDLE_KEY = 'TABLE_RESIZE_HANDLE';\r\nconst HANDLE_WIDTH = 6;\r\nconst CONTAINER_HTML = `<div style=\"position: fixed; cursor: col-resize; width: ${HANDLE_WIDTH}px; border: solid 0 #C6C6C6;\"></div>`;\r\n\r\n/**\r\n * TableResize plugin, provides the ability to resize a table by drag-and-drop\r\n */\r\nexport default class TableResize implements EditorPlugin {\r\n    private editor: Editor;\r\n    private onMouseOverDisposer: () => void;\r\n    private td: HTMLTableCellElement;\r\n    private pageX = -1;\r\n    private initialPageX: number;\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.onMouseOverDisposer = this.editor.addDomEventHandler('mouseover', this.onMouseOver);\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'TableResize';\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.detachMouseEvents();\r\n        this.editor = null;\r\n        this.onMouseOverDisposer();\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (\r\n            this.td &&\r\n            (event.eventType == PluginEventType.KeyDown ||\r\n                event.eventType == PluginEventType.ContentChanged ||\r\n                (event.eventType == PluginEventType.MouseDown && !this.clickIntoCurrentTd(event)))\r\n        ) {\r\n            this.td = null;\r\n            this.calcAndShowHandle();\r\n        }\r\n    }\r\n\r\n    private clickIntoCurrentTd(event: PluginMouseEvent) {\r\n        let mouseEvent = event.rawEvent;\r\n        let target = mouseEvent.target;\r\n        return (\r\n            target instanceof Node &&\r\n            contains(this.td, <Node>target, true /*treatSameNodeAsContain*/)\r\n        );\r\n    }\r\n\r\n    private onMouseOver = (e: MouseEvent) => {\r\n        let node = <HTMLElement>(e.srcElement || e.target);\r\n        if (\r\n            this.pageX < 0 &&\r\n            node &&\r\n            (node.tagName == 'TD' || node.tagName == 'TH') &&\r\n            node != this.td\r\n        ) {\r\n            this.td = <HTMLTableCellElement>node;\r\n            this.calcAndShowHandle();\r\n        }\r\n    };\r\n\r\n    private calcAndShowHandle() {\r\n        if (this.td) {\r\n            let tr = <HTMLTableRowElement>this.editor.getElementAtCursor('TR', this.td);\r\n            let table = <HTMLTableElement>this.editor.getElementAtCursor('TABLE', tr);\r\n            if (tr && table) {\r\n                let [left, top] = this.getPosition(table);\r\n                let handle = this.getResizeHandle();\r\n\r\n                left +=\r\n                    this.td.offsetLeft +\r\n                    (this.isRtl(table) ? 0 : this.td.offsetWidth - HANDLE_WIDTH);\r\n                handle.style.display = '';\r\n                handle.style.top = top + 'px';\r\n                handle.style.height = table.offsetHeight + 'px';\r\n                handle.style.left = left + 'px';\r\n            }\r\n        } else {\r\n            this.getResizeHandle().style.display = 'none';\r\n        }\r\n    }\r\n\r\n    private adjustHandle(pageX: number) {\r\n        let handle = this.getResizeHandle();\r\n        handle.style.left = handle.offsetLeft + pageX - this.pageX + 'px';\r\n        this.pageX = pageX;\r\n    }\r\n\r\n    private getPosition(e: HTMLElement): [number, number] {\r\n        let parent = <HTMLElement>e.offsetParent;\r\n        let [left, top] = parent ? this.getPosition(parent) : [0, 0];\r\n        return [left + e.offsetLeft - e.scrollLeft, top + e.offsetTop - e.scrollTop];\r\n    }\r\n\r\n    private getResizeHandle() {\r\n        return this.editor.getCustomData(\r\n            TABLE_RESIZE_HANDLE_KEY,\r\n            () => {\r\n                let document = this.editor.getDocument();\r\n                let handle = fromHtml(CONTAINER_HTML, document)[0] as HTMLElement;\r\n                this.editor.insertNode(handle, {\r\n                    position: ContentPosition.Outside,\r\n                    updateCursor: false,\r\n                    replaceSelection: false,\r\n                    insertOnNewLine: false,\r\n                });\r\n                handle.addEventListener('mousedown', this.onMouseDown);\r\n                return handle;\r\n            },\r\n            handle => {\r\n                handle.removeEventListener('mousedown', this.onMouseDown);\r\n                handle.parentNode.removeChild(handle);\r\n            }\r\n        );\r\n    }\r\n\r\n    private cancelEvent(e: MouseEvent) {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n    }\r\n\r\n    private onMouseDown = (e: MouseEvent) => {\r\n        if (!this.editor || this.editor.isDisposed()) {\r\n            return;\r\n        }\r\n\r\n        this.pageX = e.pageX;\r\n        this.initialPageX = e.pageX;\r\n        this.attachMouseEvents();\r\n\r\n        let handle = this.getResizeHandle();\r\n        handle.style.borderWidth = '0 1px';\r\n\r\n        this.cancelEvent(e);\r\n    };\r\n\r\n    private onMouseMove = (e: MouseEvent) => {\r\n        this.adjustHandle(e.pageX);\r\n        this.cancelEvent(e);\r\n    };\r\n\r\n    private onMouseUp = (e: MouseEvent) => {\r\n        this.detachMouseEvents();\r\n\r\n        let handle = this.getResizeHandle();\r\n        handle.style.borderWidth = '0';\r\n\r\n        let table = this.editor.getElementAtCursor('TABLE', this.td) as HTMLTableElement;\r\n        let cellPadding = parseInt(table.cellPadding);\r\n        cellPadding = isNaN(cellPadding) ? 0 : cellPadding;\r\n\r\n        if (e.pageX != this.initialPageX) {\r\n            let newWidth =\r\n                this.td.clientWidth -\r\n                cellPadding * 2 +\r\n                (e.pageX - this.initialPageX) * (this.isRtl(table) ? -1 : 1);\r\n            this.editor.addUndoSnapshot((start, end) => {\r\n                this.setTableColumnWidth(newWidth + 'px');\r\n                this.editor.select(start, end);\r\n            }, ChangeSource.Format);\r\n        }\r\n\r\n        this.pageX = -1;\r\n        this.calcAndShowHandle();\r\n        this.editor.focus();\r\n        this.cancelEvent(e);\r\n    };\r\n\r\n    private attachMouseEvents() {\r\n        if (this.editor && !this.editor.isDisposed()) {\r\n            let document = this.editor.getDocument();\r\n            document.addEventListener('mousemove', this.onMouseMove, true);\r\n            document.addEventListener('mouseup', this.onMouseUp, true);\r\n        }\r\n    }\r\n\r\n    private detachMouseEvents() {\r\n        if (this.editor && !this.editor.isDisposed()) {\r\n            let document = this.editor.getDocument();\r\n            document.removeEventListener('mousemove', this.onMouseMove, true);\r\n            document.removeEventListener('mouseup', this.onMouseUp, true);\r\n        }\r\n    }\r\n\r\n    private setTableColumnWidth(width: string) {\r\n        let vtable = new VTable(this.td);\r\n        vtable.table.style.width = '';\r\n        vtable.table.width = '';\r\n        vtable.forEachCellOfCurrentColumn(cell => {\r\n            if (cell.td) {\r\n                cell.td.style.width = cell.td == this.td ? width : '';\r\n            }\r\n        });\r\n        vtable.writeBack();\r\n        return this.editor.contains(this.td) ? this.td : vtable.getCurrentTd();\r\n    }\r\n\r\n    private isRtl(element: HTMLElement) {\r\n        return getComputedStyle(element, 'direction') == 'rtl';\r\n    }\r\n}\r\n","import { cacheGetContentSearcher, Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport { PluginEvent, PluginEventType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * An interface to define a replacement rule for CustomReplace plugin\r\n */\r\nexport type Replacement = {\r\n    /**\r\n     * Source string to replace from\r\n     */\r\n    sourceString: string;\r\n\r\n    /**\r\n     * HTML string to replace to\r\n     */\r\n    replacementHTML: string;\r\n\r\n    /**\r\n     * Whether the matching should be case sensitive\r\n     */\r\n    matchSourceCaseSensitive: boolean;\r\n};\r\n\r\nconst makeReplacement = (\r\n    sourceString: string,\r\n    replacementHTML: string,\r\n    matchSourceCaseSensitive: boolean\r\n): Replacement => ({ sourceString, replacementHTML, matchSourceCaseSensitive });\r\n\r\nconst defaultReplacements: Replacement[] = [\r\n    makeReplacement(':)', '', true),\r\n    makeReplacement(';)', '', true),\r\n    makeReplacement(':O', '', true),\r\n    makeReplacement(':o', '', true),\r\n    makeReplacement('<3', '', true),\r\n];\r\n\r\n/**\r\n * Wrapper for CustomReplaceContentEditFeature that provides an API for updating the\r\n * content edit feature\r\n */\r\nexport default class CustomReplacePlugin implements EditorPlugin {\r\n    private longestReplacementLength: number;\r\n    private editor: Editor;\r\n    private replacements: Replacement[];\r\n    private replacementEndCharacters: Set<string>;\r\n\r\n    /**\r\n     * Create instance of CustomReplace plugin\r\n     * @param replacements Replacement rules. If not passed, a default replacement rule set will be applied\r\n     */\r\n    constructor(replacements: Replacement[] = defaultReplacements) {\r\n        this.updateReplacements(replacements);\r\n    }\r\n\r\n    /**\r\n     * Set the replacements that this plugin is looking for.\r\n     * @param newReplacements new set of replacements for this plugin\r\n     */\r\n    updateReplacements(newReplacements: Replacement[]) {\r\n        this.replacements = newReplacements;\r\n        this.longestReplacementLength = getLongestReplacementSourceLength(this.replacements);\r\n        this.replacementEndCharacters = getReplacementEndCharacters(this.replacements);\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'CustomReplace';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin\r\n     * @param editor The editor instance\r\n     */\r\n    public initialize(editor: Editor): void {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose(): void {\r\n        this.editor = null;\r\n    }\r\n\r\n    public onPluginEvent(event: PluginEvent) {\r\n        if (this.editor.isInIME() || event.eventType != PluginEventType.Input) {\r\n            return;\r\n        }\r\n\r\n        // Exit early on input events that do not insert a replacement's final character.\r\n        if (event.rawEvent.data && !this.replacementEndCharacters.has(event.rawEvent.data)) {\r\n            return;\r\n        }\r\n\r\n        // Get the matching replacement\r\n        const range = this.editor.getSelectionRange();\r\n        if (range == null) {\r\n            return;\r\n        }\r\n        const searcher = cacheGetContentSearcher(event, this.editor);\r\n        const stringToSearch = searcher.getSubStringBefore(this.longestReplacementLength);\r\n\r\n        const replacement = this.getMatchingReplacement(stringToSearch);\r\n        if (replacement == null) {\r\n            return;\r\n        }\r\n\r\n        // Reconstruct a selection of the text on the document that matches the\r\n        // replacement we selected.\r\n        const matchingText = searcher.getSubStringBefore(replacement.sourceString.length);\r\n        const matchingRange = searcher.getRangeFromText(matchingText, true /* exactMatch */);\r\n\r\n        // parse the html string off the dom and inline the resulting element.\r\n        const parsingSpan = document.createElement('span');\r\n        parsingSpan.innerHTML = replacement.replacementHTML;\r\n        const nodeToInsert =\r\n            parsingSpan.childNodes.length == 1 ? parsingSpan.childNodes[0] : parsingSpan;\r\n\r\n        // Switch the node for the selection range\r\n        this.editor.performAutoComplete(() => {\r\n            matchingRange.deleteContents();\r\n            matchingRange.insertNode(nodeToInsert);\r\n            this.editor.select(nodeToInsert, PositionType.End);\r\n        });\r\n    }\r\n\r\n    private getMatchingReplacement(stringToSearch: string): Replacement | null {\r\n        if (stringToSearch.length == 0) {\r\n            return null;\r\n        }\r\n        const lowerCaseStringToSearch = stringToSearch.toLocaleLowerCase();\r\n        for (const replacement of this.replacements) {\r\n            const [sourceMatch, replacementMatch] = replacement.matchSourceCaseSensitive\r\n                ? [stringToSearch, replacement.sourceString]\r\n                : [lowerCaseStringToSearch, replacement.sourceString.toLocaleLowerCase()];\r\n\r\n            if (\r\n                sourceMatch.substring(sourceMatch.length - replacementMatch.length) ==\r\n                replacementMatch\r\n            ) {\r\n                return replacement;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getLongestReplacementSourceLength(replacements: Replacement[]): number {\r\n    return Math.max.apply(null, replacements.map(replacement => replacement.sourceString.length));\r\n}\r\n\r\nfunction getReplacementEndCharacters(replacements: Replacement[]): Set<string> {\r\n    const endChars = new Set<string>();\r\n    for (let replacement of replacements) {\r\n        const sourceString = replacement.sourceString;\r\n        if (sourceString.length == 0) {\r\n            continue;\r\n        }\r\n        const lastChar = sourceString[sourceString.length - 1];\r\n        if (!replacement.matchSourceCaseSensitive) {\r\n            endChars.add(lastChar.toLocaleLowerCase());\r\n            endChars.add(lastChar.toLocaleUpperCase());\r\n        } else {\r\n            endChars.add(lastChar);\r\n        }\r\n    }\r\n    return endChars;\r\n}\r\n","import TabPressPlugin from 'roosterjs-editor-gui/lib/EditorGui/plugins/TabPressPlugin';\r\nimport { ContentEdit, HyperLink, Paste } from 'roosterjs-editor-plugins';\r\nimport { EditorOptions, EditorPlugin } from 'roosterjs-editor-core';\r\nimport { EditorWithGui } from 'roosterjs-editor-gui';\r\n\r\nexport default function createEditorWithGui(\r\n    contentDiv: HTMLDivElement,\r\n    mergeFields: string[],\r\n    additionalPlugins?: EditorPlugin[],\r\n    initialContent?: string\r\n): EditorWithGui {\r\n    let plugins: EditorPlugin[] = [\r\n        new HyperLink(),\r\n        new Paste(),\r\n        new ContentEdit(),\r\n        new TabPressPlugin(),\r\n    ];\r\n\r\n    if (additionalPlugins) {\r\n        plugins = plugins.concat(additionalPlugins);\r\n    }\r\n\r\n    let options: EditorOptions = {\r\n        plugins: plugins,\r\n        initialContent: initialContent,\r\n        defaultFormat: {},\r\n    };\r\n\r\n    //let editor = createEditor(contentDiv, additionalPlugins, initialContent);\r\n\r\n    return new EditorWithGui(contentDiv, mergeFields, options);\r\n}\r\n","import { cacheGetElementAtCursor, Editor, EditorPlugin, Keys } from 'roosterjs-editor-core';\r\nimport { PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Insert tab sign on tab press outside li\r\n */\r\nexport default class TabPressPlugin implements EditorPlugin {\r\n    editor: Editor;\r\n\r\n    getName() {\r\n        return 'TabPressPlugin';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    getEditor() {\r\n        return this.editor;\r\n    }\r\n\r\n    isInListElement(event: PluginEvent) {\r\n        let li = cacheGetElementAtCursor(this.editor, event, 'LI,TABLE');\r\n        return null != li;\r\n    }\r\n\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.KeyDown) {\r\n            //tab press\r\n            if (event.rawEvent.keyCode == Keys.TAB && !this.isInListElement(event)) {\r\n                event.rawEvent.preventDefault();\r\n                if (!event.rawEvent.shiftKey) {\r\n                    let span = document.createElement('SPAN');\r\n                    span.appendChild(document.createTextNode('\\t'));\r\n                    span.style.whiteSpace = 'pre';\r\n                    this.editor.insertNode(span);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","import AlignCenterButton from './buttons/AlignCenterButton';\r\nimport AlignJustifyButton from './buttons/AlignJustifyButton';\r\nimport AlignLeftButton from './buttons/AlignLeftButton';\r\nimport AlignRightButton from './buttons/AlignRightButton';\r\nimport BoldButton from './buttons/BoldButton';\r\nimport BulletListButton from './buttons/BulletListButton';\r\nimport ClearStyleButton from './buttons/ClearStyleButton';\r\nimport DecreaseIndentButton from './buttons/DecreaseIndentButton';\r\nimport EditorGuiPlugin from './interfaces/EditorGuiPlugin';\r\nimport EditorGuiToolbarPlugin from './EditorGuiToolbarPlugin';\r\nimport EditorToolbarButton from './interfaces/EditorToolbarButton';\r\nimport FontSizeDropdownButton from './buttons/FontSizeDropdownButton';\r\nimport HeaderButton from './buttons/HeaderButton';\r\nimport IncreaseIndentButton from './buttons/IncreaseIndentButton';\r\nimport ItalicButton from './buttons/ItalicButton';\r\nimport MergeFieldsGuiPlugin from './guiplugins/MergeFieldsGuiPlugin';\r\nimport NumListButton from './buttons/NumListButton';\r\nimport PageBreakGuiPlugin from './guiplugins/PageBreakGuiPlugin';\r\nimport RedoButton from './buttons/RedoButton';\r\nimport Spacer from './buttons/Spacer';\r\nimport SubscriptButton from './buttons/SubscriptButton';\r\nimport SuperscriptButton from './buttons/SuperscriptButton';\r\nimport UnderlineButton from './buttons/UnderlineButton';\r\nimport UndoButton from './buttons/UndoButton';\r\nimport ZoomButton from './buttons/ZoomButton';\r\nimport { Editor, EditorOptions } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\n\r\nexport default class EditorWithGui {\r\n    private editor: Editor;\r\n\r\n    private contentDiv: HTMLDivElement;\r\n\r\n    private toolbarDiv: HTMLDivElement;\r\n\r\n    private editorWrapperDiv: HTMLDivElement;\r\n\r\n    private editorDiv: HTMLDivElement;\r\n\r\n    private workspaceDiv: HTMLDivElement;\r\n\r\n    private toolbar: Array<EditorToolbarButton>;\r\n\r\n    /**\r\n     * Create instance of ContentEdit plugin\r\n     * @param features An optional feature set to determine which features the plugin should provide\r\n     */\r\n    constructor(contentDiv: HTMLDivElement, mergefields: string[], options: EditorOptions = {}) {\r\n        this.contentDiv = contentDiv;\r\n        this.contentDiv.style.position = 'relative';\r\n\r\n        this.toolbarDiv = <HTMLDivElement>document.createElement('div');\r\n        this.toolbarDiv.className = 'roosterjs-toolbar';\r\n\r\n        this.workspaceDiv = <HTMLDivElement>document.createElement('div');\r\n        this.workspaceDiv.className = 'roosterjs-workspace';\r\n\r\n        this.editorWrapperDiv = <HTMLDivElement>document.createElement('div');\r\n        this.editorWrapperDiv.className = 'roosterjs-wrapper-editor';\r\n\r\n        this.editorDiv = <HTMLDivElement>document.createElement('div');\r\n        this.editorDiv.className = 'roosterjs-editor';\r\n\r\n        this.editorWrapperDiv.appendChild(this.editorDiv);\r\n\r\n        this.workspaceDiv.appendChild(this.editorWrapperDiv);\r\n\r\n        this.contentDiv.appendChild(this.toolbarDiv);\r\n        this.contentDiv.appendChild(this.workspaceDiv);\r\n\r\n        let toolbarplugin = new EditorGuiToolbarPlugin();\r\n        toolbarplugin.setEditorGui(this);\r\n\r\n        options.plugins.push(toolbarplugin);\r\n\r\n        let guiplugins = new Array<EditorGuiPlugin>();\r\n\r\n        guiplugins.push(new PageBreakGuiPlugin('newpage'));\r\n        guiplugins.push(new MergeFieldsGuiPlugin(mergefields, 'merge-field'));\r\n\r\n        for (let g of guiplugins) {\r\n            g.initialize(this);\r\n        }\r\n        //options.plugins.push(new TabPressPlugin());\r\n\r\n        this.editor = new Editor(this.editorDiv, options);\r\n\r\n        this.toolbar = new Array();\r\n        this.toolbar.push(\r\n            new BoldButton(this.editor),\r\n            new ItalicButton(this.editor),\r\n            new UnderlineButton(this.editor),\r\n            new SubscriptButton(this.editor),\r\n            new SuperscriptButton(this.editor),\r\n            new Spacer(this.editor),\r\n\r\n            new FontSizeDropdownButton(this.editor),\r\n            new Spacer(this.editor),\r\n            new HeaderButton(this.editor),\r\n            new Spacer(this.editor),\r\n\r\n            new BulletListButton(this.editor),\r\n            new NumListButton(this.editor),\r\n            new DecreaseIndentButton(this.editor),\r\n            new IncreaseIndentButton(this.editor),\r\n            new Spacer(this.editor),\r\n\r\n            new AlignLeftButton(this.editor),\r\n            new AlignCenterButton(this.editor),\r\n            new AlignRightButton(this.editor),\r\n            new AlignJustifyButton(this.editor),\r\n            new Spacer(this.editor),\r\n\r\n            new ClearStyleButton(this.editor),\r\n            new Spacer(this.editor),\r\n\r\n            new UndoButton(this.editor),\r\n            new RedoButton(this.editor),\r\n            new Spacer(this.editor),\r\n            new ZoomButton(this)\r\n        );\r\n\r\n        if (guiplugins) {\r\n            this.toolbar.push(new Spacer(this.editor));\r\n\r\n            for (let g of guiplugins) {\r\n                this.toolbar.push(g.getButton());\r\n            }\r\n        }\r\n\r\n        this.toolbar.forEach(e => {\r\n            e.append(this.toolbarDiv);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * getEditor\r\n     */\r\n    public getEditor() {\r\n        return this.editor;\r\n    }\r\n\r\n    public updateState(state: FormatState) {\r\n        this.toolbar.forEach(element => {\r\n            element.updateState(state);\r\n        });\r\n    }\r\n\r\n    public getContentDiv() {\r\n        return this.contentDiv;\r\n    }\r\n\r\n    public getEditorDiv() {\r\n        return this.editorDiv;\r\n    }\r\n\r\n    public getEditorWrapper() {\r\n        return this.editorWrapperDiv;\r\n    }\r\n\r\n    public getWorkspace() {\r\n        return this.workspaceDiv;\r\n    }\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { Alignment, FormatState } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getFormatState, setAlignment } from 'roosterjs-editor-api';\r\n\r\nexport default class AlignCenterButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'aligncenter';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.textCenter;\r\n    }\r\n\r\n    doAction() {\r\n        setAlignment(this.editor, Alignment.Center);\r\n        this.updateState(getFormatState(this.editor));\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        if (state.alignCenter) {\r\n            this.span.classList.add('checked');\r\n        } else {\r\n            this.span.classList.remove('checked');\r\n        }\r\n    }\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\nimport { getFormatState, setJustifyFull } from 'roosterjs-editor-api';\r\n\r\nexport default class AlignJustifyButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'aligncenter';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.textJustify;\r\n    }\r\n\r\n    doAction() {\r\n        setJustifyFull(this.editor);\r\n        this.updateState(getFormatState(this.editor));\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        if (state.alignJustify) {\r\n            this.span.classList.add('checked');\r\n        } else {\r\n            this.span.classList.remove('checked');\r\n        }\r\n    }\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { Alignment, FormatState } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getFormatState, setAlignment } from 'roosterjs-editor-api';\r\n\r\nexport default class AlignLeftButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'alignleft';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.textLeft;\r\n    }\r\n\r\n    doAction() {\r\n        setAlignment(this.editor, Alignment.Left);\r\n        this.updateState(getFormatState(this.editor));\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        if (state.alignLeft) {\r\n            this.span.classList.add('checked');\r\n        } else {\r\n            this.span.classList.remove('checked');\r\n        }\r\n    }\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { Alignment, FormatState } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getFormatState, setAlignment } from 'roosterjs-editor-api';\r\n\r\nexport default class AlignRightButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'aligncenter';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.textRight;\r\n    }\r\n\r\n    doAction() {\r\n        setAlignment(this.editor, Alignment.Right);\r\n        this.updateState(getFormatState(this.editor));\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        if (state.alignRight) {\r\n            this.span.classList.add('checked');\r\n        } else {\r\n            this.span.classList.remove('checked');\r\n        }\r\n    }\r\n}\r\n","import EditorToolbarButton from '../interfaces/EditorToolbarButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\nimport { getFormatState } from 'roosterjs-editor-api';\r\nimport { toggleBold } from 'roosterjs-editor-api';\r\n/**\r\n * Interface of an editor plugin\r\n */\r\nexport default class BoldButton implements EditorToolbarButton {\r\n    private editor: Editor;\r\n    private span: HTMLElement;\r\n\r\n    constructor(editor: Editor) {\r\n        this.editor = editor;\r\n        this.span = this.generateElement();\r\n    }\r\n\r\n    getName(): string {\r\n        return 'bold';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.bold;\r\n    }\r\n\r\n    doAction() {\r\n        toggleBold(this.editor);\r\n        this.updateState(getFormatState(this.editor));\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        if (state.isBold) {\r\n            this.span.classList.add('checked');\r\n        } else {\r\n            this.span.classList.remove('checked');\r\n        }\r\n    }\r\n\r\n    public append(div: HTMLDivElement) {\r\n        div.appendChild(this.span);\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of this plugin\r\n     */\r\n    getCssClassName: () => string;\r\n\r\n    public generateElement(): HTMLSpanElement {\r\n        let span = <HTMLSpanElement>document.createElement('span');\r\n        span.className = 'btn';\r\n        span.innerHTML = this.getIcon();\r\n        span.addEventListener('click', (e: MouseEvent) => {\r\n            this.doAction();\r\n        });\r\n        return span;\r\n    }\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\nimport { getFormatState, toggleBullet } from 'roosterjs-editor-api';\r\n\r\nexport default class BulletListButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'bulletlist';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.bulletList;\r\n    }\r\n\r\n    doAction() {\r\n        toggleBullet(this.editor);\r\n        this.updateState(getFormatState(this.editor));\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        if (state.isBullet) {\r\n            this.span.classList.add('checked');\r\n        } else {\r\n            this.span.classList.remove('checked');\r\n        }\r\n    }\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { clearBlockFormat, clearFormat } from 'roosterjs-editor-api';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\n\r\nexport default class ClearStyleButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'clearstyle';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.clearStyle;\r\n    }\r\n\r\n    doAction() {\r\n        clearFormat(this.editor);\r\n\r\n        let selection = this.editor.getSelection();\r\n\r\n        if (selection != null) {\r\n            if (selection.isCollapsed) {\r\n                clearBlockFormat(this.editor);\r\n            }\r\n        }\r\n    }\r\n\r\n    updateState(state: FormatState) {}\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState, Indentation } from 'roosterjs-editor-types';\r\nimport { setIndentation } from 'roosterjs-editor-api';\r\n\r\nexport default class DecreaseIndentButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'decreaseindent';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.decIndent;\r\n    }\r\n\r\n    doAction() {\r\n        setIndentation(this.editor, Indentation.Decrease);\r\n    }\r\n\r\n    updateState(state: FormatState) {}\r\n}\r\n","import EditorWithGui from './EditorWithGui';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport { getFormatState } from 'roosterjs-editor-api';\r\nimport { PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\nexport default class EditorGuiToolbarPlugin implements EditorPlugin {\r\n    editor: Editor;\r\n    gui: EditorWithGui;\r\n\r\n    getName() {\r\n        return 'EditorGuiToolbar';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    getEditor() {\r\n        return this.editor;\r\n    }\r\n\r\n    setEditorGui(gui: EditorWithGui) {\r\n        this.gui = gui;\r\n    }\r\n\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (\r\n            this.gui &&\r\n            this.editor &&\r\n            (event.eventType == PluginEventType.KeyUp ||\r\n                event.eventType == PluginEventType.MouseUp ||\r\n                event.eventType == PluginEventType.ContentChanged)\r\n        ) {\r\n            let state = getFormatState(this.editor, event);\r\n            this.gui.updateState(state);\r\n        }\r\n    }\r\n}\r\n","import EditorToolbarButton from '../interfaces/EditorToolbarButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\nimport { getFormatState, setFontSize } from 'roosterjs-editor-api';\r\n\r\nconst sizes = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 36];\r\n\r\nexport default class FontSizeDropdownButton implements EditorToolbarButton {\r\n    private editor: Editor;\r\n    private span: HTMLElement;\r\n    private spanLabel: HTMLElement;\r\n\r\n    private optionsSpans: Map<number, HTMLElement> = new Map();\r\n\r\n    constructor(editor: Editor) {\r\n        this.editor = editor;\r\n        this.span = this.generateElement();\r\n    }\r\n\r\n    getName(): string {\r\n        return 'fontsize';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.fontSize;\r\n    }\r\n\r\n    doAction(size: string) {\r\n        //toggleUnderline(this.editor);\r\n\r\n        setFontSize(this.editor, size + 'pt');\r\n        this.updateState(getFormatState(this.editor));\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        let size = parseInt(state.fontSize);\r\n\r\n        if (this.optionsSpans.has(size)) {\r\n            if (this.optionsSpans.get(size).classList.contains('selected')) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.optionsSpans.forEach((v, key) => {\r\n            if (key != size) {\r\n                v.classList.remove('selected');\r\n            } else {\r\n                v.classList.add('selected');\r\n                this.spanLabel.innerHTML = key + '';\r\n            }\r\n        });\r\n    }\r\n\r\n    public append(div: HTMLDivElement) {\r\n        div.appendChild(this.span);\r\n    }\r\n\r\n    public generateElement(): HTMLSpanElement {\r\n        let span = <HTMLSpanElement>document.createElement('span');\r\n        span.className = 'btn dropdown';\r\n        span.innerHTML = this.getIcon();\r\n\r\n        this.spanLabel = <HTMLSpanElement>document.createElement('span');\r\n        this.spanLabel.innerHTML = '12';\r\n        span.appendChild(this.spanLabel);\r\n\r\n        document.addEventListener('click', (e: MouseEvent) => {\r\n            var ec = e.target as HTMLElement;\r\n\r\n            if (this.span.classList.contains('opened') && !this.span.contains(ec)) {\r\n                this.span.classList.remove('opened');\r\n            }\r\n        });\r\n\r\n        span.addEventListener('click', (e: MouseEvent) => {\r\n            this.editor.focus();\r\n\r\n            if (this.span.classList.contains('opened')) {\r\n                this.span.classList.remove('opened');\r\n            } else {\r\n                this.span.classList.add('opened');\r\n            }\r\n        });\r\n\r\n        let optionsDiv = <HTMLDivElement>document.createElement('div');\r\n        optionsDiv.className = 'options';\r\n\r\n        sizes.forEach(a => {\r\n            var o = <HTMLSpanElement>document.createElement('span');\r\n            o.className = 'option';\r\n            o.setAttribute('data-size', a + '');\r\n            o.innerHTML = a + '';\r\n            optionsDiv.appendChild(o);\r\n\r\n            this.optionsSpans.set(a, o);\r\n        });\r\n\r\n        optionsDiv.addEventListener('click', (e: MouseEvent) => {\r\n            let target = e.target;\r\n\r\n            if (target && target instanceof HTMLElement) {\r\n                let tw = target as HTMLElement;\r\n                this.doAction(tw.dataset.size);\r\n            }\r\n        });\r\n\r\n        span.appendChild(optionsDiv);\r\n        return span;\r\n    }\r\n}\r\n","import EditorToolbarButton from '../interfaces/EditorToolbarButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\nimport { getFormatState, toggleHeader } from 'roosterjs-editor-api';\r\n\r\ninterface HeaderStyle {\r\n    level: number;\r\n    name: string;\r\n    style: (node: HTMLElement) => void;\r\n}\r\n\r\nconst sizes: { [key: string]: HeaderStyle } = {\r\n    empty: {\r\n        level: 0,\r\n        name: 'Tekst',\r\n        style: (node: HTMLElement) => {\r\n            node.classList.add('text');\r\n        },\r\n    },\r\n    h1: {\r\n        level: 1,\r\n        name: 'Naglowek 1',\r\n        style: (node: HTMLElement) => {\r\n            node.classList.add('h1');\r\n        },\r\n    },\r\n    h2: {\r\n        level: 2,\r\n        name: 'Naglowek 2',\r\n        style: (node: HTMLElement) => {\r\n            node.classList.add('h2');\r\n        },\r\n    },\r\n};\r\n\r\nexport default class HeaderButton implements EditorToolbarButton {\r\n    private editor: Editor;\r\n    private span: HTMLElement;\r\n    private spanLabel: HTMLElement;\r\n\r\n    private optionsSpans: Map<number, HTMLElement> = new Map();\r\n\r\n    constructor(editor: Editor) {\r\n        this.editor = editor;\r\n        this.span = this.generateElement();\r\n    }\r\n\r\n    getName(): string {\r\n        return 'fontsize';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.header;\r\n    }\r\n\r\n    doAction(size: string) {\r\n        toggleHeader(this.editor, parseInt(size));\r\n        this.updateState(getFormatState(this.editor));\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        let size = state.headerLevel;\r\n\r\n        if (this.optionsSpans.has(size)) {\r\n            if (this.optionsSpans.get(size).classList.contains('selected')) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.optionsSpans.forEach((v, key) => {\r\n            if (key != size) {\r\n                v.classList.remove('selected');\r\n            } else {\r\n                v.classList.add('selected');\r\n            }\r\n        });\r\n\r\n        Object.keys(sizes).forEach(key => {\r\n            let element = sizes[key];\r\n\r\n            if (element.level == size) {\r\n                this.spanLabel.innerHTML = sizes[key].name;\r\n            }\r\n        });\r\n    }\r\n\r\n    public append(div: HTMLDivElement) {\r\n        div.appendChild(this.span);\r\n    }\r\n\r\n    public generateElement(): HTMLSpanElement {\r\n        let span = <HTMLSpanElement>document.createElement('span');\r\n        span.className = 'btn dropdown';\r\n        span.innerHTML = this.getIcon();\r\n\r\n        this.spanLabel = <HTMLSpanElement>document.createElement('span');\r\n        this.spanLabel.innerHTML = sizes.empty.name;\r\n\r\n        span.appendChild(this.spanLabel);\r\n\r\n        document.addEventListener('click', (e: MouseEvent) => {\r\n            var ec = e.target as HTMLElement;\r\n\r\n            if (this.span.classList.contains('opened') && !this.span.contains(ec)) {\r\n                this.span.classList.remove('opened');\r\n            }\r\n        });\r\n\r\n        span.addEventListener('click', (e: MouseEvent) => {\r\n            this.editor.focus();\r\n\r\n            if (this.span.classList.contains('opened')) {\r\n                this.span.classList.remove('opened');\r\n            } else {\r\n                this.span.classList.add('opened');\r\n            }\r\n        });\r\n\r\n        let optionsDiv = <HTMLDivElement>document.createElement('div');\r\n        optionsDiv.className = 'options';\r\n\r\n        Object.keys(sizes).forEach(key => {\r\n            let element = sizes[key];\r\n            var o = <HTMLSpanElement>document.createElement('span');\r\n            o.className = 'option';\r\n            o.setAttribute('data-size', element.level + '');\r\n            o.innerHTML = element.name;\r\n            element.style(o);\r\n\r\n            optionsDiv.appendChild(o);\r\n\r\n            this.optionsSpans.set(element.level, o);\r\n        });\r\n\r\n        optionsDiv.addEventListener('click', (e: MouseEvent) => {\r\n            let target = e.target;\r\n\r\n            if (target && target instanceof HTMLElement) {\r\n                let tw = target as HTMLElement;\r\n                this.doAction(tw.dataset.size);\r\n            }\r\n        });\r\n\r\n        span.appendChild(optionsDiv);\r\n        return span;\r\n    }\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState, Indentation } from 'roosterjs-editor-types';\r\nimport { setIndentation } from 'roosterjs-editor-api';\r\n\r\nexport default class IncreaseIndentButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'increaseindent';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.incIndent;\r\n    }\r\n\r\n    doAction() {\r\n        setIndentation(this.editor, Indentation.Increase);\r\n    }\r\n\r\n    updateState(state: FormatState) {}\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\nimport { getFormatState, toggleItalic } from 'roosterjs-editor-api';\r\n\r\nexport default class ItalicButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'italic';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.italic;\r\n    }\r\n\r\n    doAction() {\r\n        toggleItalic(this.editor);\r\n        this.updateState(getFormatState(this.editor));\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        if (state.isItalic) {\r\n            this.span.classList.add('checked');\r\n        } else {\r\n            this.span.classList.remove('checked');\r\n        }\r\n    }\r\n}\r\n","import AbstractButton from '../buttons/AbstractButton';\r\nimport createSidebar from '../utils/createSidebar';\r\nimport DOM from '../utils/DOM';\r\nimport EditorGuiPlugin from '../interfaces/EditorGuiPlugin';\r\nimport EditorToolbarButton from '../interfaces/EditorToolbarButton';\r\nimport icons from '../icons/icons';\r\nimport { ChangeSource, FormatState } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { EditorWithGui } from 'roosterjs-editor-gui';\r\n\r\n/**\r\n * Insert tab sign on tab press outside li\r\n */\r\nexport default class MergeFieldsGuiPlugin implements EditorGuiPlugin {\r\n    editor: EditorWithGui;\r\n    button: MergeFieldButton;\r\n    fields: string[];\r\n\r\n    dialog: HTMLDivElement;\r\n    sidebar: HTMLDivElement;\r\n    cssClass: string;\r\n\r\n    constructor(fields: string[], cssClass?: string) {\r\n        this.fields = fields;\r\n        this.cssClass = cssClass;\r\n    }\r\n\r\n    getName() {\r\n        return 'MergeFields';\r\n    }\r\n\r\n    initialize(editor: EditorWithGui) {\r\n        this.editor = editor;\r\n        this.button = new MergeFieldButton(this.editor.getEditor(), () => {\r\n            if (this.sidebar.classList.contains('hidden')) {\r\n                this.sidebar.classList.remove('hidden');\r\n                this.button.setChecked();\r\n            } else {\r\n                this.sidebar.classList.add('hidden');\r\n                this.button.setUnChecked();\r\n            }\r\n\r\n            this.editor.getEditor().focus();\r\n        });\r\n\r\n        this.dialog = DOM.div('options');\r\n\r\n        this.fields.forEach(a => {\r\n            let opt = document.createElement('span');\r\n            opt.className = 'option';\r\n            opt.dataset.val = a;\r\n            opt.innerText = a;\r\n            this.dialog.appendChild(opt);\r\n        });\r\n\r\n        this.sidebar = createSidebar(editor, 'Wstaw pole', this.dialog);\r\n\r\n        this.editor.getWorkspace().appendChild(this.sidebar);\r\n\r\n        this.dialog.addEventListener('click', e => {\r\n            this.dialogClick(e);\r\n        });\r\n    }\r\n\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    dialogClick(e: MouseEvent) {\r\n        let target = e.target;\r\n\r\n        if (target && target instanceof HTMLElement) {\r\n            let n = target as HTMLElement;\r\n\r\n            this.insertField(n.dataset.val);\r\n        }\r\n    }\r\n\r\n    insertField(text: string) {\r\n        let editor = this.editor.getEditor();\r\n\r\n        if (!editor.isDisposed()) {\r\n            editor.focus();\r\n            editor.addUndoSnapshot(() => {\r\n                const span = document.createElement('a');\r\n                span.setAttribute('href', 'javascript:void(0);');\r\n                span.setAttribute('data-mergefield', 'merge');\r\n                span.innerHTML = text;\r\n\r\n                if (!this.cssClass) {\r\n                    span.style.backgroundColor = 'rgba(131, 208, 242, 0.4)';\r\n                    span.style.border = '1px solid rgb(131, 208, 242)';\r\n                } else {\r\n                    span.className = this.cssClass;\r\n                }\r\n\r\n                editor.insertNode(span);\r\n            }, ChangeSource.Format);\r\n        }\r\n    }\r\n\r\n    getEditor() {\r\n        return this.editor;\r\n    }\r\n\r\n    getButton(): EditorToolbarButton {\r\n        return this.button;\r\n    }\r\n}\r\n\r\nclass MergeFieldButton extends AbstractButton {\r\n    action: () => void;\r\n    constructor(editor: Editor, action: () => void) {\r\n        super(editor);\r\n        this.action = action;\r\n    }\r\n\r\n    setChecked() {\r\n        this.span.classList.add('checked');\r\n    }\r\n\r\n    setUnChecked() {\r\n        this.span.classList.remove('checked');\r\n    }\r\n\r\n    getName(): string {\r\n        return 'addmergefield';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.mergeField;\r\n    }\r\n\r\n    doAction() {\r\n        this.action();\r\n    }\r\n\r\n    updateState(state: FormatState) {}\r\n}\r\n","import DOM from './DOM';\r\nimport { EditorWithGui } from 'roosterjs-editor-gui/lib';\r\n\r\n/**\r\n * Set indentation at selection\r\n * If selection contains bullet/numbering list, increase/decrease indentation will\r\n * increase/decrease the list level by one.\r\n * @param editor The editor instance\r\n * @param indentation The indentation option:\r\n * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation\r\n */\r\nexport default function createSidebar(\r\n    editor: EditorWithGui,\r\n    title: string,\r\n    content: HTMLDivElement\r\n): HTMLDivElement {\r\n    // prettier-ignore\r\n    return DOM.div(\r\n        'sidebar hidden',\r\n        [\r\n            DOM.div(\r\n                'sidebar-title',\r\n                [\r\n                    DOM.text(title)\r\n                ]\r\n            ),\r\n            DOM.div(\r\n                'sidebar-content',\r\n                [content]\r\n            )\r\n        ]\r\n    );\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\nimport { getFormatState, toggleNumbering } from 'roosterjs-editor-api';\r\n\r\nexport default class NumListButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'numlist';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.numList;\r\n    }\r\n\r\n    doAction() {\r\n        toggleNumbering(this.editor);\r\n        this.updateState(getFormatState(this.editor));\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        if (state.isNumbering) {\r\n            this.span.classList.add('checked');\r\n        } else {\r\n            this.span.classList.remove('checked');\r\n        }\r\n    }\r\n}\r\n","import AbstractButton from '../buttons/AbstractButton';\r\nimport EditorGuiPlugin from '../interfaces/EditorGuiPlugin';\r\nimport EditorToolbarButton from '../interfaces/EditorToolbarButton';\r\nimport icons from '../icons/icons';\r\nimport { ChangeSource, ContentPosition, FormatState } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { EditorWithGui } from 'roosterjs-editor-gui';\r\n\r\n/**\r\n * Insert tab sign on tab press outside li\r\n */\r\nexport default class PageBreakGuiPlugin implements EditorGuiPlugin {\r\n    editor: EditorWithGui;\r\n    button: PageBreakButton;\r\n\r\n    cssClass?: string;\r\n\r\n    constructor(cssClass?: string) {\r\n        this.cssClass = cssClass;\r\n    }\r\n\r\n    getName() {\r\n        return 'PageBreak';\r\n    }\r\n\r\n    /**\r\n     * add click event listener\r\n     * to remove pagebreak on click\r\n     */\r\n    private attachClickListener() {\r\n        this.editor.getEditorDiv().addEventListener('click', e => {\r\n            let editor = this.editor.getEditor();\r\n\r\n            if (!editor.isDisposed()) {\r\n                if (e.target && e.target instanceof HTMLDivElement) {\r\n                    let div = e.target as HTMLDivElement;\r\n                    if (div.classList.contains('page-break')) {\r\n                        editor.addUndoSnapshot(() => {\r\n                            div.parentElement.removeChild(div);\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    initialize(editor: EditorWithGui) {\r\n        this.editor = editor;\r\n\r\n        this.attachClickListener();\r\n\r\n        this.button = new PageBreakButton(this.editor.getEditor(), () => {\r\n            let editor = this.editor.getEditor();\r\n\r\n            if (!editor.isDisposed()) {\r\n                editor.focus();\r\n                editor.addUndoSnapshot(() => {\r\n                    let nextdiv = editor.getDocument().createElement('DIV');\r\n                    nextdiv.innerHTML = '<br>';\r\n\r\n                    editor.insertNode(nextdiv, {\r\n                        insertOnNewLine: true,\r\n                        position: ContentPosition.SelectionStart,\r\n                    });\r\n\r\n                    let div = editor.getDocument().createElement('DIV');\r\n                    div.className = 'page-break';\r\n\r\n                    if (!this.cssClass) {\r\n                        div.style.padding = '5px 0';\r\n                        div.style.margin = '10px 0';\r\n                        div.style.color = '#666';\r\n                        div.style.backgroundColor = '#eaeaea';\r\n                        div.style.fontSize = '11px';\r\n                        div.style.fontFamily = 'sans-serif';\r\n                        div.style.width = '100%';\r\n                        div.style.textAlign = 'center';\r\n                    } else {\r\n                        div.classList.add(this.cssClass);\r\n                    }\r\n\r\n                    div.innerHTML =\r\n                        '&centerdot;&centerdot;&centerdot;&centerdot;&centerdot;&centerdot;&centerdot;&centerdot;&centerdot;&centerdot; Page Break &centerdot;&centerdot;&centerdot;&centerdot;&centerdot;&centerdot;&centerdot;&centerdot;&centerdot;&centerdot;';\r\n                    div.setAttribute('contenteditable', 'false');\r\n\r\n                    editor.insertNode(div, {\r\n                        insertOnNewLine: true,\r\n                        position: ContentPosition.SelectionStart,\r\n                    });\r\n                }, ChangeSource.Format);\r\n            }\r\n        });\r\n    }\r\n\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    getEditor() {\r\n        return this.editor;\r\n    }\r\n\r\n    getButton(): EditorToolbarButton {\r\n        return this.button;\r\n    }\r\n}\r\n\r\nclass PageBreakButton extends AbstractButton {\r\n    action: () => void;\r\n    constructor(editor: Editor, action: () => void) {\r\n        super(editor);\r\n        this.action = action;\r\n    }\r\n\r\n    getName(): string {\r\n        return 'addmergefield';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.pageBreak;\r\n    }\r\n\r\n    doAction() {\r\n        this.action();\r\n    }\r\n\r\n    updateState(state: FormatState) {}\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\n\r\nexport default class RedoButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'redo';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.redo;\r\n    }\r\n\r\n    doAction() {\r\n        this.editor.redo();\r\n        //this.updateState(getFormatState(this.editor));\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        if (!state.canRedo) {\r\n            this.span.classList.add('disabled');\r\n        } else {\r\n            this.span.classList.remove('disabled');\r\n        }\r\n    }\r\n}\r\n","import EditorToolbarButton from '../interfaces/EditorToolbarButton';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Interface of an editor plugin\r\n */\r\nexport default class Spacer implements EditorToolbarButton {\r\n    private span: HTMLElement;\r\n\r\n    constructor(editor: Editor) {\r\n        this.span = this.generateElement();\r\n    }\r\n\r\n    getName(): string {\r\n        return 'spacer';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return '';\r\n    }\r\n\r\n    doAction() {\r\n        //empty\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        //empty\r\n    }\r\n\r\n    public append(div: HTMLDivElement) {\r\n        div.appendChild(this.span);\r\n    }\r\n\r\n    public generateElement(): HTMLSpanElement {\r\n        let span = <HTMLSpanElement>document.createElement('span');\r\n        span.className = 'spacer';\r\n        span.innerHTML = '';\r\n        return span;\r\n    }\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\nimport { getFormatState, toggleSubscript } from 'roosterjs-editor-api';\r\n\r\nexport default class SubscriptButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'sup';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.subscript;\r\n    }\r\n\r\n    doAction() {\r\n        toggleSubscript(this.editor);\r\n        this.updateState(getFormatState(this.editor));\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        if (state.isSubscript) {\r\n            this.span.classList.add('checked');\r\n        } else {\r\n            this.span.classList.remove('checked');\r\n        }\r\n    }\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\nimport { getFormatState, toggleSuperscript } from 'roosterjs-editor-api';\r\n\r\nexport default class SuperscriptButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'sup';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.superscript;\r\n    }\r\n\r\n    doAction() {\r\n        toggleSuperscript(this.editor);\r\n        this.updateState(getFormatState(this.editor));\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        if (state.isSuperscript) {\r\n            this.span.classList.add('checked');\r\n        } else {\r\n            this.span.classList.remove('checked');\r\n        }\r\n    }\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\nimport { getFormatState, toggleUnderline } from 'roosterjs-editor-api';\r\n\r\nexport default class UnderlineButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'underline';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.underline;\r\n    }\r\n\r\n    doAction() {\r\n        toggleUnderline(this.editor);\r\n        this.updateState(getFormatState(this.editor));\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        if (state.isUnderline) {\r\n            this.span.classList.add('checked');\r\n        } else {\r\n            this.span.classList.remove('checked');\r\n        }\r\n    }\r\n}\r\n","import AbstractButton from './AbstractButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\n\r\nexport default class UndoButton extends AbstractButton {\r\n    constructor(editor: Editor) {\r\n        super(editor);\r\n    }\r\n\r\n    getName(): string {\r\n        return 'undo';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.undo;\r\n    }\r\n\r\n    doAction() {\r\n        this.editor.undo();\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        if (!state.canUndo) {\r\n            this.span.classList.add('disabled');\r\n        } else {\r\n            this.span.classList.remove('disabled');\r\n        }\r\n    }\r\n}\r\n","import EditorToolbarButton from '../interfaces/EditorToolbarButton';\r\nimport icons from '../icons/icons';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { EditorWithGui } from 'roosterjs-editor-gui/lib';\r\nimport { FormatState } from 'roosterjs-editor-types';\r\n\r\nconst sizes = [50, 90, 100, 110, 120, 130, 140, 150, 200];\r\n\r\nexport default class ZoomButton implements EditorToolbarButton {\r\n    private editor: Editor;\r\n    private span: HTMLElement;\r\n    private spanLabel: HTMLElement;\r\n    private wrapper: HTMLElement;\r\n\r\n    private optionsSpans: Map<number, HTMLElement> = new Map();\r\n\r\n    constructor(editor: EditorWithGui) {\r\n        this.wrapper = editor.getEditorDiv();\r\n        this.editor = editor.getEditor();\r\n        this.span = this.generateElement();\r\n    }\r\n\r\n    getName(): string {\r\n        return 'zoom';\r\n    }\r\n\r\n    getIcon(): string {\r\n        return icons.zoom;\r\n    }\r\n\r\n    doAction(size: string) {\r\n        let zoom = parseFloat(size) / 100;\r\n        this.wrapper.style.zoom = zoom + '';\r\n\r\n        let s = parseInt(size);\r\n\r\n        this.optionsSpans.forEach((v, key) => {\r\n            if (key != s) {\r\n                v.classList.remove('selected');\r\n            } else {\r\n                v.classList.add('selected');\r\n                this.spanLabel.innerHTML = size + '%';\r\n            }\r\n        });\r\n    }\r\n\r\n    updateState(state: FormatState) {\r\n        //nothing\r\n    }\r\n\r\n    public append(div: HTMLDivElement) {\r\n        div.appendChild(this.span);\r\n    }\r\n\r\n    public generateElement(): HTMLSpanElement {\r\n        let span = <HTMLSpanElement>document.createElement('span');\r\n        span.className = 'btn dropdown';\r\n        span.innerHTML = this.getIcon();\r\n\r\n        this.spanLabel = <HTMLSpanElement>document.createElement('span');\r\n        this.spanLabel.innerHTML = '100%';\r\n\r\n        span.appendChild(this.spanLabel);\r\n\r\n        document.addEventListener('click', (e: MouseEvent) => {\r\n            var ec = e.target as HTMLElement;\r\n\r\n            if (this.span.classList.contains('opened') && !this.span.contains(ec)) {\r\n                this.span.classList.remove('opened');\r\n            }\r\n        });\r\n\r\n        span.addEventListener('click', (e: MouseEvent) => {\r\n            this.editor.focus();\r\n\r\n            if (this.span.classList.contains('opened')) {\r\n                this.span.classList.remove('opened');\r\n            } else {\r\n                this.span.classList.add('opened');\r\n            }\r\n        });\r\n\r\n        let optionsDiv = <HTMLDivElement>document.createElement('div');\r\n        optionsDiv.className = 'options';\r\n\r\n        sizes.forEach(a => {\r\n            var o = <HTMLSpanElement>document.createElement('span');\r\n            o.className = 'option';\r\n            o.setAttribute('data-size', a + '');\r\n            o.innerHTML = a + '%';\r\n            optionsDiv.appendChild(o);\r\n\r\n            this.optionsSpans.set(a, o);\r\n        });\r\n\r\n        optionsDiv.addEventListener('click', (e: MouseEvent) => {\r\n            let target = e.target;\r\n\r\n            if (target && target instanceof HTMLElement) {\r\n                let tw = target as HTMLElement;\r\n                this.doAction(tw.dataset.size);\r\n            }\r\n        });\r\n\r\n        span.appendChild(optionsDiv);\r\n        return span;\r\n    }\r\n}\r\n","export { default as ImageResize } from './ImageResize';\r\n","import { contains, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\nimport {\r\n    ContentChangedEvent,\r\n    ChangeSource,\r\n    NodeType,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    ExtractContentEvent,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst BEGIN_TAG = 'RoosterJsImageResizingBegin';\r\nconst END_TAG = 'RoosterJsImageResizingEnd';\r\nconst EXTRACT_HTML_REGEX = new RegExp(\r\n    `<!--${BEGIN_TAG}-->[\\\\s\\\\S]*(<img\\\\s[^>]+>)[\\\\s\\\\S]*<!--${END_TAG}-->`,\r\n    'gim'\r\n);\r\nconst DELETE_KEYCODE = 46;\r\nconst BACKSPACE_KEYCODE = 8;\r\nconst SHIFT_KEYCODE = 16;\r\nconst CTRL_KEYCODE = 17;\r\nconst ALT_KEYCODE = 18;\r\n\r\n/**\r\n * ImageResize plugin provides the ability to resize an inline image in editor\r\n */\r\nexport default class ImageResize implements EditorPlugin {\r\n    private editor: Editor;\r\n    private startPageX: number;\r\n    private startPageY: number;\r\n    private startWidth: number;\r\n    private startHeight: number;\r\n    private resizeDiv: HTMLElement;\r\n    private direction: string;\r\n    private disposer: () => void;\r\n\r\n    /**\r\n     * Create a new instance of ImageResize\r\n     * @param minWidth Minimum width of image when resize in pixel, default value is 10\r\n     * @param minHeight Minimum height of image when resize in pixel, default value is 10\r\n     * @param selectionBorderColor Color of resize border and handles, default value is #DB626C\r\n     * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false\r\n     * @param resizableImageSelector Selector for picking which image is resizable (e.g. for all images not placeholders), note\r\n     * that the tag must be IMG regardless what the selector is\r\n     */\r\n    constructor(\r\n        private minWidth: number = 10,\r\n        private minHeight: number = 10,\r\n        private selectionBorderColor: string = '#DB626C',\r\n        private forcePreserveRatio: boolean = false,\r\n        private resizableImageSelector: string = 'img'\r\n    ) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'ImageResize';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.disposer = editor.addDomEventHandler({\r\n            dragstart: this.onDragStart,\r\n            blur: this.onBlur,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        if (this.resizeDiv) {\r\n            this.hideResizeHandle();\r\n        }\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(e: PluginEvent) {\r\n        if (e.eventType == PluginEventType.MouseDown) {\r\n            const event = e.rawEvent;\r\n            const target = <HTMLElement>(event.srcElement || event.target);\r\n\r\n            if (getTagOfNode(target) == 'IMG') {\r\n                const parent = target.parentNode as HTMLElement;\r\n                const elements = parent\r\n                    ? ([].slice.call(\r\n                          parent.querySelectorAll(this.resizableImageSelector)\r\n                      ) as HTMLElement[])\r\n                    : [];\r\n                if (elements.indexOf(target) < 0) {\r\n                    return;\r\n                }\r\n\r\n                target.contentEditable = 'false';\r\n                const currentImg = this.getSelectedImage();\r\n                if (currentImg && currentImg != target) {\r\n                    this.hideResizeHandle();\r\n                }\r\n\r\n                if (!this.resizeDiv) {\r\n                    this.showResizeHandle(<HTMLImageElement>target);\r\n                }\r\n            } else if (this.resizeDiv && !contains(this.resizeDiv, target)) {\r\n                this.hideResizeHandle();\r\n            }\r\n        } else if (e.eventType == PluginEventType.KeyDown && this.resizeDiv) {\r\n            const event = e.rawEvent;\r\n            if (event.which == DELETE_KEYCODE || event.which == BACKSPACE_KEYCODE) {\r\n                this.editor.addUndoSnapshot(() => {\r\n                    this.removeResizeDiv(this.resizeDiv);\r\n                });\r\n                this.resizeDiv = null;\r\n                event.preventDefault();\r\n                this.resizeDiv = null;\r\n            } else if (\r\n                event.which != SHIFT_KEYCODE &&\r\n                event.which != CTRL_KEYCODE &&\r\n                event.which != ALT_KEYCODE\r\n            ) {\r\n                this.hideResizeHandle(true /*selectImage*/);\r\n            }\r\n        } else if (\r\n            e.eventType == PluginEventType.ContentChanged &&\r\n            (<ContentChangedEvent>e).source != ChangeSource.ImageResize\r\n        ) {\r\n            this.editor.queryElements('img', this.removeResizeDivIfAny);\r\n            this.resizeDiv = null;\r\n        } else if (e.eventType == PluginEventType.ExtractContent) {\r\n            const event = <ExtractContentEvent>e;\r\n            event.content = this.extractHtml(event.content);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select a given IMG element, show the resize handle\r\n     * @param img The IMG element to select\r\n     */\r\n    showResizeHandle(img: HTMLImageElement) {\r\n        this.resizeDiv = this.createResizeDiv(img);\r\n        img.contentEditable = 'false';\r\n        this.editor.select(this.resizeDiv, PositionType.After);\r\n    }\r\n\r\n    /**\r\n     * Hide resize handle of current selected image\r\n     * @param selectImageAfterUnSelect Optional, when set to true, select the image element after hide the resize handle\r\n     */\r\n    hideResizeHandle(selectImageAfterUnSelect?: boolean) {\r\n        let img = this.getSelectedImage();\r\n        let parent = this.resizeDiv && this.resizeDiv.parentNode;\r\n        if (parent) {\r\n            if (img) {\r\n                img.removeAttribute('contentEditable');\r\n                let referenceNode =\r\n                    this.resizeDiv.previousSibling &&\r\n                    this.resizeDiv.previousSibling.nodeType == NodeType.Comment\r\n                        ? this.resizeDiv.previousSibling\r\n                        : this.resizeDiv;\r\n                parent.insertBefore(img, referenceNode);\r\n\r\n                if (selectImageAfterUnSelect) {\r\n                    this.editor.select(img);\r\n                } else {\r\n                    this.editor.select(img, PositionType.After);\r\n                }\r\n            }\r\n            this.removeResizeDiv(this.resizeDiv);\r\n            this.resizeDiv = null;\r\n        }\r\n    }\r\n\r\n    private startResize = (e: MouseEvent) => {\r\n        let img = this.getSelectedImage();\r\n        if (this.editor && img) {\r\n            this.startPageX = e.pageX;\r\n            this.startPageY = e.pageY;\r\n            this.startWidth = img.clientWidth;\r\n            this.startHeight = img.clientHeight;\r\n            this.editor.addUndoSnapshot();\r\n\r\n            let document = this.editor.getDocument();\r\n            document.addEventListener('mousemove', this.doResize, true /*useCapture*/);\r\n            document.addEventListener('mouseup', this.finishResize, true /*useCapture*/);\r\n            this.direction = (<HTMLElement>(e.srcElement || e.target)).style.cursor;\r\n        }\r\n\r\n        this.stopEvent(e);\r\n    };\r\n\r\n    private doResize = (e: MouseEvent) => {\r\n        let img = this.getSelectedImage();\r\n        if (this.editor && img) {\r\n            let widthChange = e.pageX - this.startPageX;\r\n            let heightChange = e.pageY - this.startPageY;\r\n            let newWidth = Math.max(\r\n                this.startWidth + (this.isWest(this.direction) ? -widthChange : widthChange),\r\n                this.minWidth\r\n            );\r\n            let newHeight = Math.max(\r\n                this.startHeight + (this.isNorth(this.direction) ? -heightChange : heightChange),\r\n                this.minHeight\r\n            );\r\n\r\n            if (this.forcePreserveRatio || e.shiftKey) {\r\n                let ratio =\r\n                    this.startWidth > 0 && this.startHeight > 0\r\n                        ? (this.startWidth * 1.0) / this.startHeight\r\n                        : 0;\r\n                if (ratio > 0) {\r\n                    if (newWidth < newHeight * ratio) {\r\n                        newWidth = newHeight * ratio;\r\n                    } else {\r\n                        newHeight = newWidth / ratio;\r\n                    }\r\n                }\r\n            }\r\n\r\n            img.style.width = newWidth + 'px';\r\n            img.style.height = newHeight + 'px';\r\n        }\r\n        this.stopEvent(e);\r\n    };\r\n\r\n    private finishResize = (e: MouseEvent) => {\r\n        var img = this.getSelectedImage() as HTMLImageElement;\r\n        if (this.editor && img) {\r\n            let document = this.editor.getDocument();\r\n            document.removeEventListener('mousemove', this.doResize, true /*useCapture*/);\r\n            document.removeEventListener('mouseup', this.finishResize, true /*useCapture*/);\r\n            let width = img.clientWidth;\r\n            let height = img.clientHeight;\r\n            img.style.width = width + 'px';\r\n            img.style.height = height + 'px';\r\n            img.width = width;\r\n            img.height = height;\r\n            this.resizeDiv.style.width = '';\r\n            this.resizeDiv.style.height = '';\r\n        }\r\n        this.direction = null;\r\n        this.editor.addUndoSnapshot();\r\n        this.editor.triggerContentChangedEvent(ChangeSource.ImageResize);\r\n        this.stopEvent(e);\r\n    };\r\n\r\n    private createResizeDiv(target: HTMLElement) {\r\n        let document = this.editor.getDocument();\r\n        let resizeDiv = document.createElement('DIV');\r\n        let parent = target.parentNode;\r\n        parent.insertBefore(resizeDiv, target);\r\n        parent.insertBefore(document.createComment(BEGIN_TAG), resizeDiv);\r\n        parent.insertBefore(document.createComment(END_TAG), resizeDiv.nextSibling);\r\n\r\n        resizeDiv.style.position = 'relative';\r\n        resizeDiv.style.display = 'inline-flex';\r\n        resizeDiv.contentEditable = 'false';\r\n        resizeDiv.addEventListener('click', this.stopEvent);\r\n        resizeDiv.appendChild(target);\r\n        ['nw', 'ne', 'sw', 'se'].forEach(pos => {\r\n            let div = document.createElement('DIV');\r\n            resizeDiv.appendChild(div);\r\n            div.style.position = 'absolute';\r\n            div.style.width = '7px';\r\n            div.style.height = '7px';\r\n            div.style.backgroundColor = this.selectionBorderColor;\r\n            div.style.cursor = pos + '-resize';\r\n            if (this.isNorth(pos)) {\r\n                div.style.top = '-3px';\r\n            } else {\r\n                div.style.bottom = '-3px';\r\n            }\r\n            if (this.isWest(pos)) {\r\n                div.style.left = '-3px';\r\n            } else {\r\n                div.style.right = '-3px';\r\n            }\r\n            div.addEventListener('mousedown', this.startResize);\r\n        });\r\n        let div = document.createElement('DIV');\r\n        resizeDiv.appendChild(div);\r\n        div.style.position = 'absolute';\r\n        div.style.top = '0';\r\n        div.style.left = '0';\r\n        div.style.right = '0';\r\n        div.style.bottom = '0';\r\n        div.style.border = 'solid 1px ' + this.selectionBorderColor;\r\n        div.style.pointerEvents = 'none';\r\n        return resizeDiv;\r\n    }\r\n\r\n    private stopEvent = (e: UIEvent) => {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n    };\r\n\r\n    private removeResizeDiv(resizeDiv: HTMLElement) {\r\n        if (this.editor && this.editor.contains(resizeDiv)) {\r\n            [resizeDiv.previousSibling, resizeDiv.nextSibling].forEach(comment => {\r\n                if (comment && comment.nodeType == NodeType.Comment) {\r\n                    this.editor.deleteNode(comment);\r\n                }\r\n            });\r\n            this.editor.deleteNode(resizeDiv);\r\n        }\r\n    }\r\n\r\n    private removeResizeDivIfAny = (img: HTMLImageElement) => {\r\n        let div = img && (img.parentNode as HTMLElement);\r\n        let previous = div && div.previousSibling;\r\n        let next = div && div.nextSibling;\r\n        if (\r\n            previous &&\r\n            previous.nodeType == NodeType.Comment &&\r\n            previous.nodeValue == BEGIN_TAG &&\r\n            next &&\r\n            next.nodeType == NodeType.Comment &&\r\n            next.nodeValue == END_TAG\r\n        ) {\r\n            div.parentNode.insertBefore(img, div);\r\n            this.removeResizeDiv(div);\r\n        }\r\n    };\r\n\r\n    private onBlur = (e: FocusEvent) => {\r\n        this.hideResizeHandle();\r\n    };\r\n\r\n    private extractHtml(html: string): string {\r\n        return html.replace(EXTRACT_HTML_REGEX, (...groups: string[]) => {\r\n            return groups[1].replace(\r\n                /(\\s*contenteditable=\"false\"(\\/?>)|contenteditable=\"false\"\\s*)/im,\r\n                '$2'\r\n            );\r\n        });\r\n    }\r\n\r\n    private getSelectedImage(): HTMLElement {\r\n        return this.resizeDiv ? <HTMLElement>this.resizeDiv.getElementsByTagName('IMG')[0] : null;\r\n    }\r\n\r\n    private isNorth(direction: string): boolean {\r\n        return direction && direction.substr(0, 1) == 'n';\r\n    }\r\n\r\n    private isWest(direction: string): boolean {\r\n        return direction && direction.substr(1, 1) == 'w';\r\n    }\r\n\r\n    private onDragStart = (e: DragEvent) => {\r\n        if ((e.srcElement || e.target) == this.getSelectedImage()) {\r\n            this.hideResizeHandle(true);\r\n        }\r\n    };\r\n}\r\n","export { default as PickerPlugin, EditorPickerPluginInterface } from './PickerPlugin';\r\nexport { PickerPluginOptions, PickerDataProvider } from './PickerDataProvider';\r\n","import { Browser, createRange, PartialInlineElement } from 'roosterjs-editor-dom';\r\nimport { PickerDataProvider, PickerPluginOptions } from './PickerDataProvider';\r\nimport { replaceWithNode } from 'roosterjs-editor-api';\r\nimport {\r\n    ChangeSource,\r\n    NodePosition,\r\n    PluginDomEvent,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginInputEvent,\r\n    PluginKeyboardEvent,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    cacheGetContentSearcher,\r\n    Editor,\r\n    EditorPlugin,\r\n    isCharacterValue,\r\n    isModifierKey,\r\n} from 'roosterjs-editor-core';\r\n\r\n// Character codes.\r\n// IE11 uses different character codes. which are noted below.\r\n// If adding a new key, test in IE to figure out what the code is.\r\nconst BACKSPACE_CHARCODE = 'Backspace';\r\nconst TAB_CHARCODE = 'Tab';\r\nconst ENTER_CHARCODE = 'Enter';\r\nconst ESC_CHARCODE = !Browser.isIE ? 'Escape' : 'Esc';\r\nconst LEFT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowLeft' : 'Left';\r\nconst UP_ARROW_CHARCODE = !Browser.isIE ? 'ArrowUp' : 'Up';\r\nconst RIGHT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowRight' : 'Right';\r\nconst DOWN_ARROW_CHARCODE = !Browser.isIE ? 'ArrowDown' : 'Down';\r\nconst DELETE_CHARCODE = !Browser.isIE ? 'Delete' : 'Del';\r\n\r\n// Input event input types.\r\nconst DELETE_CONTENT_BACKWARDS_INPUT_TYPE = 'deleteContentBackwards';\r\n\r\n// Unidentified key, the code for Android keyboard events.\r\nconst UNIDENTIFIED_KEY = 'Unidentified';\r\n\r\n/**\r\n * Interface for PickerPlugin\r\n */\r\nexport interface EditorPickerPluginInterface<T extends PickerDataProvider = PickerDataProvider>\r\n    extends EditorPlugin {\r\n    dataProvider: T;\r\n}\r\n\r\n/**\r\n * PickerPlugin represents a plugin of editor which can handle picker related behaviors, including\r\n * - Show picker when special trigger key is pressed\r\n * - Hide picker\r\n * - Change selection in picker by Up/Down/Left/Right\r\n * - Apply selected item in picker\r\n *\r\n * PickerPlugin doesn't provide any UI, it just wraps related DOM events and invoke callback functions.\r\n * To show a picker UI, you need to build your own UI component. Please reference to\r\n * https://github.com/microsoft/roosterjs/tree/master/publish/samplesite/scripts/controls/samplepicker\r\n */\r\nexport default class PickerPlugin<T extends PickerDataProvider = PickerDataProvider>\r\n    implements EditorPickerPluginInterface<T> {\r\n    private editor: Editor;\r\n    private eventHandledOnKeyDown: boolean;\r\n    private blockSuggestions: boolean;\r\n    private isSuggesting: boolean;\r\n    private lastKnownRange: Range;\r\n\r\n    // For detecting backspace in Android\r\n    private isPendingInputEventHandling: boolean = false;\r\n    private currentInputLength: number;\r\n    private newInputLength: number;\r\n\r\n    constructor(public readonly dataProvider: T, private pickerOptions: PickerPluginOptions) {}\r\n\r\n    /**\r\n     * Get a friendly name\r\n     */\r\n    getName() {\r\n        return 'Picker';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    public initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.dataProvider.onInitalize(\r\n            (htmlNode: Node) => {\r\n                this.editor.focus();\r\n\r\n                let wordToReplace = this.getWord(null);\r\n\r\n                // Safari drops our focus out so we get an empty word to replace when we call getWord.\r\n                // We fall back to using the lastKnownRange to try to get around this.\r\n                if ((!wordToReplace || wordToReplace.length == 0) && this.lastKnownRange) {\r\n                    this.editor.select(this.lastKnownRange);\r\n                    wordToReplace = this.getWord(null);\r\n                }\r\n\r\n                let insertNode = () => {\r\n                    if (wordToReplace) {\r\n                        replaceWithNode(\r\n                            this.editor,\r\n                            wordToReplace,\r\n                            htmlNode,\r\n                            true /* exactMatch */\r\n                        );\r\n                    } else {\r\n                        this.editor.insertNode(htmlNode);\r\n                    }\r\n                    this.setIsSuggesting(false);\r\n                };\r\n\r\n                if (this.pickerOptions.handleAutoComplete) {\r\n                    this.editor.performAutoComplete(insertNode, this.pickerOptions.changeSource);\r\n                } else {\r\n                    this.editor.addUndoSnapshot(insertNode, this.pickerOptions.changeSource);\r\n                }\r\n            },\r\n            (isSuggesting: boolean) => {\r\n                this.setIsSuggesting(isSuggesting);\r\n            },\r\n            editor\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose() {\r\n        this.editor = null;\r\n        this.dataProvider.onDispose();\r\n    }\r\n\r\n    /**\r\n     * Check if the plugin should handle the given event exclusively.\r\n     * Handle an event exclusively means other plugin will not receive this event in\r\n     * onPluginEvent method.\r\n     * If two plugins will return true in willHandleEventExclusively() for the same event,\r\n     * the final result depends on the order of the plugins are added into editor\r\n     * @param event The event to check\r\n     */\r\n    public willHandleEventExclusively(event: PluginEvent) {\r\n        return (\r\n            this.isSuggesting &&\r\n            (event.eventType == PluginEventType.KeyDown ||\r\n                event.eventType == PluginEventType.KeyUp ||\r\n                event.eventType == PluginEventType.Input)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    public onPluginEvent(event: PluginEvent) {\r\n        switch (event.eventType) {\r\n            case PluginEventType.ContentChanged:\r\n                if (event.source == ChangeSource.SetContent && this.dataProvider.onContentChanged) {\r\n                    // Stop suggesting since content is fully changed\r\n                    if (this.isSuggesting) {\r\n                        this.setIsSuggesting(false);\r\n                    }\r\n\r\n                    // Undos and other major changes to document content fire this type of event.\r\n                    // Inform the data provider of the current picker placed elements in the body.\r\n                    let elementIds: string[] = [];\r\n                    this.editor.queryElements(\r\n                        \"[id^='\" + this.pickerOptions.elementIdPrefix + \"']\",\r\n                        element => {\r\n                            if (element.id) {\r\n                                elementIds.push(element.id);\r\n                            }\r\n                        }\r\n                    );\r\n                    this.dataProvider.onContentChanged(elementIds);\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.KeyDown:\r\n                this.eventHandledOnKeyDown = false;\r\n                if (event.rawEvent.key == UNIDENTIFIED_KEY) {\r\n                    // On Android, the key for KeyboardEvent is \"Unidentified\",\r\n                    // so handling should be done using the input rather than key down event\r\n                    // Since the key down event happens right before the input event, calculate the input\r\n                    // length here in preparation for onAndroidInputEvent\r\n                    this.currentInputLength = this.calcInputLength(event);\r\n                    this.isPendingInputEventHandling = true;\r\n                } else {\r\n                    this.onKeyDownEvent(event);\r\n                    this.isPendingInputEventHandling = false;\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.Input:\r\n                if (this.isPendingInputEventHandling) {\r\n                    this.onAndroidInputEvent(event);\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.KeyUp:\r\n                if (!this.eventHandledOnKeyDown && this.shouldHandleKeyUpEvent(event)) {\r\n                    this.onKeyUpDomEvent(event);\r\n                    this.isPendingInputEventHandling = false;\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.MouseUp:\r\n                if (this.isSuggesting) {\r\n                    this.setIsSuggesting(false);\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.Scroll:\r\n                if (this.dataProvider.onScroll) {\r\n                    // Dispatch scroll event to data provider\r\n                    this.dataProvider.onScroll(event.scrollContainer);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    private setLastKnownRange(range: Range) {\r\n        this.lastKnownRange = range;\r\n    }\r\n\r\n    private setIsSuggesting(isSuggesting: boolean) {\r\n        this.isSuggesting = isSuggesting;\r\n\r\n        if (!isSuggesting) {\r\n            this.setLastKnownRange(null);\r\n        }\r\n        this.dataProvider.onIsSuggestingChanged(isSuggesting);\r\n\r\n        this.setAriaOwns(isSuggesting);\r\n        this.setAriaActiveDescendant(isSuggesting ? 0 : null);\r\n    }\r\n\r\n    private cancelDefaultKeyDownEvent(event: PluginKeyboardEvent) {\r\n        this.eventHandledOnKeyDown = true;\r\n        event.rawEvent.preventDefault();\r\n        event.rawEvent.stopImmediatePropagation();\r\n    }\r\n\r\n    private getIdValue(node: Node): string {\r\n        let element = node as Element;\r\n        return element.attributes && element.attributes.getNamedItem('id')\r\n            ? (element.attributes.getNamedItem('id').value as string)\r\n            : null;\r\n    }\r\n\r\n    private getWordBeforeCursor(event: PluginKeyboardEvent): string {\r\n        let searcher = cacheGetContentSearcher(event, this.editor);\r\n        return searcher ? searcher.getWordBefore() : null;\r\n    }\r\n\r\n    private replaceNode(currentNode: Node, replacementNode: Node) {\r\n        if (currentNode) {\r\n            this.editor.deleteNode(currentNode);\r\n        }\r\n        if (replacementNode) {\r\n            this.editor.insertNode(replacementNode);\r\n        }\r\n    }\r\n\r\n    private getRangeUntilAt(event: PluginKeyboardEvent): Range {\r\n        let PositionContentSearcher = cacheGetContentSearcher(event, this.editor);\r\n        let startPos: NodePosition;\r\n        let endPos: NodePosition;\r\n        PositionContentSearcher.forEachTextInlineElement(textInline => {\r\n            let hasMatched = false;\r\n            let nodeContent = textInline.getTextContent();\r\n            let nodeIndex = nodeContent ? nodeContent.length : -1;\r\n            while (nodeIndex >= 0) {\r\n                if (nodeContent[nodeIndex] == this.pickerOptions.triggerCharacter) {\r\n                    startPos = textInline.getStartPosition().move(nodeIndex);\r\n                    hasMatched = true;\r\n                    break;\r\n                }\r\n                nodeIndex--;\r\n            }\r\n\r\n            if (hasMatched) {\r\n                endPos = textInline.getEndPosition();\r\n            }\r\n\r\n            return hasMatched;\r\n        });\r\n        return createRange(startPos, endPos) || this.editor.getDocument().createRange();\r\n    }\r\n\r\n    private shouldHandleKeyUpEvent(event: PluginKeyboardEvent) {\r\n        // onKeyUpDomEvent should only be called when a key that produces a character value is pressed\r\n        // This check will always fail on Android since the KeyboardEvent's key is \"Unidentified\"\r\n        // However, we don't need to check for modifier events on mobile, so can ignore this check\r\n        return (\r\n            event.rawEvent.key == UNIDENTIFIED_KEY ||\r\n            isCharacterValue(event.rawEvent) ||\r\n            (this.isSuggesting && !isModifierKey(event.rawEvent))\r\n        );\r\n    }\r\n\r\n    private onKeyUpDomEvent(event: PluginKeyboardEvent) {\r\n        if (this.isSuggesting) {\r\n            // Word before cursor represents the text prior to the cursor, up to and including the trigger symbol.\r\n            const wordBeforeCursor = this.getWord(event);\r\n            const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\r\n            const trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\r\n\r\n            // If we hit a case where wordBeforeCursor is just the trigger character,\r\n            // that means we've gotten a onKeyUp event right after it's been typed.\r\n            // Otherwise, update the query string when:\r\n            // 1. There's an actual value\r\n            // 2. That actual value isn't just pure whitespace\r\n            // 3. That actual value isn't more than 4 words long (at which point we assume the person kept typing)\r\n            // Otherwise, we want to dismiss the picker plugin's UX.\r\n            if (\r\n                wordBeforeCursor == this.pickerOptions.triggerCharacter ||\r\n                (trimmedWordBeforeCursor &&\r\n                    trimmedWordBeforeCursor.length > 0 &&\r\n                    trimmedWordBeforeCursor.split(' ').length <= 4)\r\n            ) {\r\n                this.dataProvider.queryStringUpdated(\r\n                    trimmedWordBeforeCursor,\r\n                    wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\r\n                );\r\n                this.setLastKnownRange(this.editor.getSelectionRange());\r\n            } else {\r\n                this.setIsSuggesting(false);\r\n            }\r\n        } else {\r\n            let wordBeforeCursor = this.getWordBeforeCursor(event);\r\n            if (!this.blockSuggestions) {\r\n                if (\r\n                    wordBeforeCursor != null &&\r\n                    wordBeforeCursor.split(' ').length <= 4 &&\r\n                    wordBeforeCursor[0] == this.pickerOptions.triggerCharacter\r\n                ) {\r\n                    this.setIsSuggesting(true);\r\n                    const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\r\n                    let trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\r\n                    this.dataProvider.queryStringUpdated(\r\n                        trimmedWordBeforeCursor,\r\n                        wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\r\n                    );\r\n                    this.setLastKnownRange(this.editor.getSelectionRange());\r\n                    if (this.dataProvider.setCursorPoint) {\r\n                        // Determine the bounding rectangle for the @mention\r\n                        let searcher = cacheGetContentSearcher(event, this.editor);\r\n                        let rangeNode = this.editor.getDocument().createRange();\r\n                        let nodeBeforeCursor = searcher.getInlineElementBefore().getContainerNode();\r\n                        let rangeStartSuccessfullySet = this.setRangeStart(\r\n                            rangeNode,\r\n                            nodeBeforeCursor,\r\n                            wordBeforeCursor\r\n                        );\r\n                        if (!rangeStartSuccessfullySet) {\r\n                            // VSO 24891: Out of range error is occurring because nodeBeforeCursor\r\n                            // is not including the trigger character. In this case, the node before\r\n                            // the node before cursor is the trigger character, and this is where the range should start.\r\n                            let nodeBeforeNodeBeforeCursor = nodeBeforeCursor.previousSibling;\r\n                            this.setRangeStart(\r\n                                rangeNode,\r\n                                nodeBeforeNodeBeforeCursor,\r\n                                this.pickerOptions.triggerCharacter\r\n                            );\r\n                        }\r\n                        let rect = rangeNode.getBoundingClientRect();\r\n\r\n                        // Safari's support for range.getBoundingClientRect is incomplete.\r\n                        // We perform this check to fall back to getClientRects in case it's at the page origin.\r\n                        if (rect.left == 0 && rect.bottom == 0 && rect.top == 0) {\r\n                            rect = rangeNode.getClientRects()[0];\r\n                        }\r\n\r\n                        if (rect) {\r\n                            rangeNode.detach();\r\n\r\n                            // Display the @mention popup in the correct place\r\n                            let targetPoint = { x: rect.left, y: (rect.bottom + rect.top) / 2 };\r\n                            let bufferZone = (rect.bottom - rect.top) / 2;\r\n                            this.dataProvider.setCursorPoint(targetPoint, bufferZone);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (\r\n                    wordBeforeCursor != null &&\r\n                    wordBeforeCursor[0] != this.pickerOptions.triggerCharacter\r\n                ) {\r\n                    this.blockSuggestions = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private onKeyDownEvent(event: PluginKeyboardEvent) {\r\n        let keyboardEvent = event.rawEvent;\r\n        if (this.isSuggesting) {\r\n            if (keyboardEvent.key == ESC_CHARCODE) {\r\n                this.setIsSuggesting(false);\r\n                this.blockSuggestions = true;\r\n                this.cancelDefaultKeyDownEvent(event);\r\n            } else if (\r\n                this.dataProvider.shiftHighlight &&\r\n                (this.pickerOptions.isHorizontal\r\n                    ? keyboardEvent.key == LEFT_ARROW_CHARCODE ||\r\n                      keyboardEvent.key == RIGHT_ARROW_CHARCODE\r\n                    : keyboardEvent.key == UP_ARROW_CHARCODE ||\r\n                      keyboardEvent.key == DOWN_ARROW_CHARCODE)\r\n            ) {\r\n                this.dataProvider.shiftHighlight(\r\n                    this.pickerOptions.isHorizontal\r\n                        ? keyboardEvent.key == RIGHT_ARROW_CHARCODE\r\n                        : keyboardEvent.key == DOWN_ARROW_CHARCODE\r\n                );\r\n\r\n                if (this.dataProvider.getSelectedIndex) {\r\n                    this.setAriaActiveDescendant(this.dataProvider.getSelectedIndex());\r\n                }\r\n\r\n                this.cancelDefaultKeyDownEvent(event);\r\n            } else if (\r\n                this.dataProvider.selectOption &&\r\n                (keyboardEvent.key == ENTER_CHARCODE || keyboardEvent.key == TAB_CHARCODE)\r\n            ) {\r\n                this.dataProvider.selectOption();\r\n                this.cancelDefaultKeyDownEvent(event);\r\n            } else {\r\n                // Currently no op.\r\n            }\r\n        } else {\r\n            if (keyboardEvent.key == BACKSPACE_CHARCODE) {\r\n                const nodeRemoved = this.tryRemoveNode(event);\r\n                if (nodeRemoved) {\r\n                    this.cancelDefaultKeyDownEvent(event);\r\n                }\r\n            } else if (keyboardEvent.key == DELETE_CHARCODE) {\r\n                let searcher = cacheGetContentSearcher(event, this.editor);\r\n                let nodeAfterCursor = searcher.getInlineElementAfter()\r\n                    ? searcher.getInlineElementAfter().getContainerNode()\r\n                    : null;\r\n                let nodeId = nodeAfterCursor ? this.getIdValue(nodeAfterCursor) : null;\r\n                if (nodeId && nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0) {\r\n                    let replacementNode = this.dataProvider.onRemove(nodeAfterCursor, false);\r\n                    this.replaceNode(nodeAfterCursor, replacementNode);\r\n                    this.cancelDefaultKeyDownEvent(event);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private onAndroidInputEvent(event: PluginInputEvent) {\r\n        this.newInputLength = this.calcInputLength(event);\r\n\r\n        if (\r\n            this.newInputLength < this.currentInputLength ||\r\n            (event.rawEvent as any).inputType === DELETE_CONTENT_BACKWARDS_INPUT_TYPE\r\n        ) {\r\n            const nodeRemoved = this.tryRemoveNode(event);\r\n            if (nodeRemoved) {\r\n                this.eventHandledOnKeyDown = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private calcInputLength(event: PluginEvent) {\r\n        const wordBeforCursor = this.getInlineElementBeforeCursor(event);\r\n        return wordBeforCursor ? wordBeforCursor.length : 0;\r\n    }\r\n\r\n    private tryRemoveNode(event: PluginDomEvent): boolean {\r\n        const searcher = cacheGetContentSearcher(event, this.editor);\r\n        const inlineElementBefore = searcher.getInlineElementBefore();\r\n        const nodeBeforeCursor = inlineElementBefore\r\n            ? inlineElementBefore.getContainerNode()\r\n            : null;\r\n        const nodeId = nodeBeforeCursor ? this.getIdValue(nodeBeforeCursor) : null;\r\n        const inlineElementAfter = searcher.getInlineElementAfter();\r\n\r\n        if (\r\n            nodeId &&\r\n            nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0 &&\r\n            (inlineElementAfter == null || !(inlineElementAfter instanceof PartialInlineElement))\r\n        ) {\r\n            const replacementNode = this.dataProvider.onRemove(nodeBeforeCursor, true);\r\n            if (replacementNode) {\r\n                this.replaceNode(nodeBeforeCursor, replacementNode);\r\n                if (this.isPendingInputEventHandling) {\r\n                    this.editor.runAsync(() => {\r\n                        this.editor.select(replacementNode, PositionType.After);\r\n                    });\r\n                } else {\r\n                    this.editor.select(replacementNode, PositionType.After);\r\n                }\r\n            } else {\r\n                this.editor.deleteNode(nodeBeforeCursor);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private getWord(event: PluginKeyboardEvent) {\r\n        let wordFromRange = this.getRangeUntilAt(event).toString();\r\n        let wordFromCache = this.getWordBeforeCursor(event);\r\n        // VSO 24891: In picker, trigger and mention are separated into two nodes.\r\n        // In this case, wordFromRange is the trigger character while wordFromCache is the whole string,\r\n        // so wordFromCache is what we want to return.\r\n        if (\r\n            wordFromRange == this.pickerOptions.triggerCharacter &&\r\n            wordFromRange != wordFromCache\r\n        ) {\r\n            return wordFromCache;\r\n        }\r\n        return wordFromRange;\r\n    }\r\n\r\n    private setRangeStart(rangeNode: Range, node: Node, target: string) {\r\n        let nodeOffset = node ? node.textContent.lastIndexOf(target) : -1;\r\n        if (nodeOffset > -1) {\r\n            rangeNode.setStart(node, nodeOffset);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private setAriaOwns(isSuggesting: boolean) {\r\n        this.editor.setEditorDomAttribute(\r\n            'aria-owns',\r\n            isSuggesting && this.pickerOptions.suggestionsLabel\r\n                ? this.pickerOptions.suggestionsLabel\r\n                : null\r\n        );\r\n    }\r\n\r\n    private setAriaActiveDescendant(selectedIndex: number) {\r\n        this.editor.setEditorDomAttribute(\r\n            'aria-activedescendant',\r\n            selectedIndex != null && this.pickerOptions.suggestionLabelPrefix\r\n                ? this.pickerOptions.suggestionLabelPrefix + selectedIndex.toString()\r\n                : null\r\n        );\r\n    }\r\n\r\n    private getInlineElementBeforeCursor(event: PluginEvent): string {\r\n        const searcher = cacheGetContentSearcher(event, this.editor);\r\n        const element = searcher ? searcher.getInlineElementBefore() : null;\r\n        return element ? element.getTextContent() : null;\r\n    }\r\n}\r\n"],"sourceRoot":""}